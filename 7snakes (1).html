<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rainbow Snake Races - Collisions & Merging</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; }
        canvas { border: 1px solid #333; }
        .panel { position: absolute; background: rgba(0, 0, 0, 0.7); padding: 10px 15px; border-radius: 8px; box-shadow: 0 0 15px rgba(255, 255, 255, 0.2); z-index: 10; }
        .scores { top: 10px; left: 10px; font-size: 16px; }
        .master-tally { top: 10px; right: 10px; font-size: 16px; text-align: right; }
        .modal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; font-size: 24px; background: rgba(0, 0, 0, 0.9); padding: 30px; border-radius: 15px; width: 500px; z-index: 20; }
        .modal h2 { margin-top: 0; }
        .modal button { margin: 5px; padding: 12px 20px; font-size: 18px; cursor: pointer; color: white; border: 2px solid white; border-radius: 8px; transition: all 0.3s; background: transparent; }
        .prediction-buttons button:hover { transform: scale(1.1); box-shadow: 0 0 10px var(--btn-color, white); }
        #finalRankings { list-style-type: none; padding: 0; margin: 15px 0; font-size: 18px; text-align: left; }
        #finalRankings li { padding: 4px; border-radius: 5px; }
        #predictionTimerText { font-size: 16px; color: #ccc; margin-top: 15px; height: 20px; }
        .prediction-display p { margin: 10px 0; font-size: 22px; }
        .prediction-display span { font-weight: bold; }
        #roundStartCountdown { font-size: 32px; margin-top: 20px; color: #FFFF00; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="scores panel" id="scoreBoard"></div>
    <div class="master-tally panel" id="masterTally"></div>
    <div class="modal" id="resultsScreen"> <h2 id="winnerText">Snake Wins!</h2> <p id="raceTime"></p> <div id="predictionResult"></div> <ol id="finalRankings"></ol> </div>
    <div class="modal" id="predictionScreen"> <h2>Predict the Winner!</h2> <p>You have 5 seconds to choose a snake.</p> <div id="predictionButtons"></div> <p id="predictionTimerText"></p> </div>
    <div class="modal" id="preRoundScreen"> <h2>Predictions Locked In!</h2> <div class="prediction-display"> <p id="userPredictionText"></p> <p id="aiPredictionText"></p> </div> <h3 id="roundStartCountdown"></h3> </div>

    <script>
        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const resultsScreenDiv = document.getElementById('resultsScreen'), winnerTextDiv = document.getElementById('winnerText'), raceTimeDiv = document.getElementById('raceTime'), finalRankingsDiv = document.getElementById('finalRankings'), predictionScreenDiv = document.getElementById('predictionScreen'), predictionButtonsDiv = document.getElementById('predictionButtons'), predictionResultDiv = document.getElementById('predictionResult'), masterTallyDiv = document.getElementById('masterTally'), predictionTimerTextDiv = document.getElementById('predictionTimerText'), preRoundScreenDiv = document.getElementById('preRoundScreen'), userPredictionTextDiv = document.getElementById('userPredictionText'), aiPredictionTextDiv = document.getElementById('aiPredictionText'), roundStartCountdownDiv = document.getElementById('roundStartCountdown');

        canvas.width = 900; canvas.height = 700;

        // --- UPDATED: Faster snake speed ---
        const SNAKE_SPEED = 12; 
        const SNAKE_THICKNESS = 14, BUBBLE_RADIUS = 8, WIN_SCORE = 100;
        const VICTORY_CIRCLE_RADIUS = 200, TRAIL_LENGTH = 250;
        const SNAKE_PUSH_AMOUNT = 7; // How much snakes push each other on collision

        const RAINBOW_SNAKES = [ { color: '#FF0000', name: 'Red' }, { color: '#FFA500', name: 'Orange' }, { color: '#FFFF00', name: 'Yellow' }, { color: '#00FF00', name: 'Green' }, { color: '#0000FF', name: 'Blue' }, { color: '#4B0082', name: 'Indigo' }, { color: '#EE82EE', name: 'Violet' } ];

        // --- NEW: Game State Machine ---
        let gameState = 'LOADING'; // Possible states: LOADING, PREDICTION, PRE_ROUND, RACING, RESULTS, INTERMISSION
        let stateEndTime = 0;
        let snakes = [], bubbles = [], roundStartTime;
        let victoryAnimationState = { active: false, winner: null, frame: 0 };
        let userPrediction = null, aiPrediction = null, totalRounds = 0, correctPredictions = 0, aiCorrectPredictions = 0;
        let winTally = {}; RAINBOW_SNAKES.forEach(s => winTally[s.name] = 0);
        let predictionTimeoutId = null, predictionCountdownIntervalId = null;

        // --- Classes ---
        class Snake { constructor(color, name) { this.segments = [{ x: Math.random() * (canvas.width - 200) + 100, y: Math.random() * (canvas.height - 200) + 100 }]; this.colors = [color]; this.eyeOffset = 12; this.eyeRadius = 14; this.pupilRadius = 6; this.targetBubble = null; this.score = 0; this.color = color; this.name = name; this.victoryTrail = []; } move(target) { if (!target) return; const head = this.segments[0]; const angle = Math.atan2(target.y - head.y, target.x - head.x); const dx = Math.cos(angle) * SNAKE_SPEED; const dy = Math.sin(angle) * SNAKE_SPEED; const newHead = { x: head.x + dx, y: head.y + dy }; this.segments.unshift(newHead); this.segments.pop(); } grow(color, growth = 1) { const lastSegment = this.segments[this.segments.length - 1]; for (let i = 0; i < growth; i++) { this.segments.push({ ...lastSegment }); this.colors.push(color); } } draw(target) { if (!target) target = { x: canvas.width / 2, y: canvas.height / 2 }; this.segments.forEach((segment, i) => { ctx.beginPath(); ctx.fillStyle = this.colors[i] || this.color; ctx.arc(segment.x, segment.y, SNAKE_THICKNESS, 0, Math.PI * 2); ctx.fill(); }); const head = this.segments[0]; const angle = Math.atan2(target.y - head.y, target.x - head.x); [-Math.PI / 4, Math.PI / 4].forEach(eyeAngle => { const eyeX = head.x + Math.cos(angle + eyeAngle) * this.eyeOffset; const eyeY = head.y + Math.sin(angle + eyeAngle) * this.eyeOffset; ctx.beginPath(); ctx.fillStyle = 'white'; ctx.arc(eyeX, eyeY, this.eyeRadius, 0, Math.PI * 2); ctx.fill(); const pupilDx = target.x - head.x; const pupilDy = target.y - head.y; const pupilDist = Math.hypot(pupilDx, pupilDy); const normalizedPupilDx = pupilDx / pupilDist || 0; const normalizedPupilDy = pupilDy / pupilDist || 0; ctx.beginPath(); ctx.fillStyle = 'black'; ctx.arc(eyeX + normalizedPupilDx * this.eyeRadius / 2, eyeY + normalizedPupilDy * this.eyeRadius / 2, this.pupilRadius, 0, Math.PI * 2); ctx.fill(); }); } drawVictoryAnimation(frame) { const centerX = canvas.width / 2; const centerY = canvas.height / 2; const angle = frame * 0.05; const x = centerX + Math.cos(angle) * VICTORY_CIRCLE_RADIUS; const y = centerY + Math.sin(angle) * VICTORY_CIRCLE_RADIUS; this.victoryTrail.unshift({ x, y }); if (this.victoryTrail.length > TRAIL_LENGTH) this.victoryTrail.pop(); this.victoryTrail.forEach((pos, i) => { const alpha = 1 - (i / TRAIL_LENGTH); const hexAlpha = Math.floor(alpha * 200).toString(16).padStart(2, '0'); ctx.beginPath(); ctx.fillStyle = `${this.color}${hexAlpha}`; ctx.arc(pos.x, pos.y, SNAKE_THICKNESS, 0, Math.PI * 2); ctx.fill(); }); this.segments[0] = { x, y }; this.draw({ x: centerX, y: centerY }); } }
        class Bubble { constructor(color, x, y, mergeCount = 1) { this.x = x ?? Math.random() * canvas.width; this.y = y ?? Math.random() * canvas.height; this.color = color; this.mergeCount = mergeCount; this.radius = BUBBLE_RADIUS * Math.sqrt(this.mergeCount); this.speed = (Math.random() * 2 + 1) / this.mergeCount; this.direction = Math.random() * Math.PI * 2; } move() { this.x += Math.cos(this.direction) * this.speed; this.y += Math.sin(this.direction) * this.speed; if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) this.direction = Math.PI - this.direction; if (this.y - this.radius <= 0 || this.y + this.radius >= canvas.height) this.direction = -this.direction; this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x)); this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y)); } draw() { ctx.beginPath(); ctx.fillStyle = this.color; ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } }
        
        // --- Core Logic Helpers ---
        function getClosestBubble(snake, bubbles) { const sameColorBubbles = bubbles.filter(b => b.color === snake.color); if (sameColorBubbles.length === 0) return null; return sameColorBubbles.reduce((closest, bubble) => { const dist = Math.hypot(snake.segments[0].x - bubble.x, snake.segments[0].y - bubble.y); return (!closest || dist < closest.dist) ? { bubble, dist } : closest; }, null).bubble; }
        function updateScoreboard() { const sortedSnakes = [...snakes].sort((a, b) => b.score - a.score); const scoreBoard = document.getElementById('scoreBoard'); scoreBoard.innerHTML = `<h3>Current Scores</h3>` + sortedSnakes.map((snake, index) => `<div style="color: ${snake.color}; font-weight: bold;">${index + 1}. ${snake.name}: ${snake.score} ${index === 0 ? 'üëë' : ''}</div>`).join(''); }
        function updateMasterTally() { const sortedTally = Object.entries(winTally).sort(([, a], [, b]) => b - a); const userAccuracy = totalRounds > 0 ? ((correctPredictions / totalRounds) * 100).toFixed(1) : "0.0"; const aiAccuracy = totalRounds > 0 ? ((aiCorrectPredictions / totalRounds) * 100).toFixed(1) : "0.0"; masterTallyDiv.innerHTML = `<h3>Master Tally</h3>` + sortedTally.map(([name, wins]) => { const snakeInfo = RAINBOW_SNAKES.find(s => s.name === name); return `<div style="color: ${snakeInfo.color}; font-weight: bold;">${name}: ${wins} wins</div>`; }).join('') + `<hr style="border-color: #555; margin: 10px 0;"><div>Your Accuracy: ${userAccuracy}% (${correctPredictions}/${totalRounds})</div><div>AI Accuracy: ${aiAccuracy}% (${aiCorrectPredictions}/${totalRounds})</div>`; }
        
        // --- NEW: Collision and Merging Handlers ---
        function handleSnakeCollisions() {
            for (let i = 0; i < snakes.length; i++) {
                for (let j = i + 1; j < snakes.length; j++) {
                    const snakeA = snakes[i]; const snakeB = snakes[j];
                    const headA = snakeA.segments[0]; const headB = snakeB.segments[0];
                    const dist = Math.hypot(headA.x - headB.x, headA.y - headB.y);

                    if (dist < SNAKE_THICKNESS * 2) {
                        const overlap = (SNAKE_THICKNESS * 2 - dist) / 2;
                        const dx = headA.x - headB.x; const dy = headA.y - headB.y;
                        const nx = dx / dist; const ny = dy / dist; // Normalized vector
                        
                        headA.x += nx * (overlap + SNAKE_PUSH_AMOUNT); headA.y += ny * (overlap + SNAKE_PUSH_AMOUNT);
                        headB.x -= nx * (overlap + SNAKE_PUSH_AMOUNT); headB.y -= ny * (overlap + SNAKE_PUSH_AMOUNT);
                    }
                }
            }
        }
        function handleBubbleMerging() {
            const toRemove = new Set();
            const toAdd = [];
            for (let i = 0; i < bubbles.length; i++) {
                if (toRemove.has(bubbles[i])) continue;
                for (let j = i + 1; j < bubbles.length; j++) {
                    if (toRemove.has(bubbles[j])) continue;
                    
                    const bubbleA = bubbles[i]; const bubbleB = bubbles[j];
                    if (bubbleA.color !== bubbleB.color) continue;
                    
                    const dist = Math.hypot(bubbleA.x - bubbleB.x, bubbleA.y - bubbleB.y);
                    if (dist < bubbleA.radius + bubbleB.radius) {
                        toRemove.add(bubbleA); toRemove.add(bubbleB);
                        
                        const totalMerge = bubbleA.mergeCount + bubbleB.mergeCount;
                        const newX = (bubbleA.x * bubbleA.mergeCount + bubbleB.x * bubbleB.mergeCount) / totalMerge;
                        const newY = (bubbleA.y * bubbleA.mergeCount + bubbleB.y * bubbleB.mergeCount) / totalMerge;
                        
                        toAdd.push(new Bubble(bubbleA.color, newX, newY, totalMerge));
                        break; // bubbleA is now marked for removal, so we can break its inner loop
                    }
                }
            }
            if (toRemove.size > 0) {
                bubbles = bubbles.filter(b => !toRemove.has(b));
                bubbles.push(...toAdd);
            }
        }

        // --- Game State and Flow Management ---
        function changeState(newState, durationSeconds) {
            gameState = newState;
            if (durationSeconds) { stateEndTime = Date.now() + durationSeconds * 1000; }
            // Hide all modals by default
            [predictionScreenDiv, preRoundScreenDiv, resultsScreenDiv].forEach(div => div.style.display = 'none');

            switch (newState) {
                case 'PREDICTION':
                    predictionScreenDiv.style.display = 'block';
                    userPrediction = null; aiPrediction = null;
                    predictionButtonsDiv.innerHTML = RAINBOW_SNAKES.map(s => `<button style="--btn-color: ${s.color}; border-color: ${s.color};" onclick="handleUserPrediction('${s.color}')">${s.name}</button>`).join('');
                    let countdown = 5;
                    predictionTimerTextDiv.textContent = `Auto-picking in ${countdown}...`;
                    predictionCountdownIntervalId = setInterval(() => { countdown--; predictionTimerTextDiv.textContent = `Auto-picking in ${countdown}...`; }, 1000);
                    predictionTimeoutId = setTimeout(handleUserTimeout, 5000);
                    break;

                case 'PRE_ROUND':
                    preRoundScreenDiv.style.display = 'block';
                    if (userPrediction) { userPredictionTextDiv.innerHTML = `You Predicted: <span style="color: ${userPrediction.color};">${userPrediction.name}</span>`;
                    } else { userPredictionTextDiv.innerHTML = `You did not make a prediction.`; }
                    aiPrediction = RAINBOW_SNAKES[Math.floor(Math.random() * RAINBOW_SNAKES.length)];
                    aiPredictionTextDiv.innerHTML = `ü§ñ AI Predicts: <span style="color: ${aiPrediction.color};">${aiPrediction.name}</span>`;
                    break;
                
                case 'RACING':
                    snakes = RAINBOW_SNAKES.map(s => new Snake(s.color, s.name));
                    bubbles = [];
                    RAINBOW_SNAKES.forEach(s => { for (let i = 0; i < 5; i++) { bubbles.push(new Bubble(s.color)); } });
                    updateScoreboard();
                    updateMasterTally();
                    roundStartTime = Date.now();
                    break;

                case 'RESULTS':
                    resultsScreenDiv.style.display = 'block';
                    victoryAnimationState.active = true;
                    break;
                
                case 'INTERMISSION':
                    victoryAnimationState.active = false;
                    break;
            }
        }
        function handleUserPrediction(color) { clearTimeout(predictionTimeoutId); clearInterval(predictionCountdownIntervalId); userPrediction = RAINBOW_SNAKES.find(s => s.color === color); changeState('PRE_ROUND', 3); }
        function handleUserTimeout() { clearInterval(predictionCountdownIntervalId); userPrediction = null; changeState('PRE_ROUND', 3); }

        function endRound(winner) {
            totalRounds++; const raceDuration = ((Date.now() - roundStartTime) / 1000).toFixed(2);
            winTally[winner.name]++;
            let predictionHTML = '';
            if (userPrediction) { if (winner.name === userPrediction.name) { correctPredictions++; predictionHTML += `<p style="color: lightgreen;">‚úÖ You predicted correctly!</p>`; } else { predictionHTML += `<p style="color: lightcoral;">‚ùå Your prediction (${userPrediction.name}) was incorrect.</p>`; } }
            if (aiPrediction) { if (winner.name === aiPrediction.name) { aiCorrectPredictions++; predictionHTML += `<p style="color: lightblue;">ü§ñ The AI predicted correctly!</p>`; } else { predictionHTML += `<p style="color: lightcoral;">ü§ñ The AI's prediction (${aiPrediction.name}) was incorrect.</p>`; } }
            predictionResultDiv.innerHTML = predictionHTML;
            winnerTextDiv.style.color = winner.color; winnerTextDiv.textContent = `${winner.name} Snake Wins!`;
            raceTimeDiv.textContent = `Race Time: ${raceDuration} seconds`;
            const finalRankings = [...snakes].sort((a, b) => b.score - a.score);
            finalRankingsDiv.innerHTML = finalRankings.map((snake, index) => `<li style="background: ${index % 2 === 0 ? 'rgba(255,255,255,0.1)' : 'transparent'};"><span style="color: ${snake.color}; font-weight: bold;">${index + 1}. ${snake.name} (${snake.score} pts)</span></li>`).join('');
            updateMasterTally();
            victoryAnimationState.winner = winner; victoryAnimationState.frame = 0;
            changeState('RESULTS', 5);
        }

        // --- Main Game Loop ---
        function gameLoop() {
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            // State-driven logic
            switch (gameState) {
                case 'PRE_ROUND':
                    const timeLeft = Math.ceil((stateEndTime - Date.now()) / 1000);
                    roundStartCountdownDiv.textContent = `Race starts in ${timeLeft}...`;
                    if (Date.now() >= stateEndTime) changeState('RACING');
                    break;

                case 'RACING':
                    bubbles.forEach(bubble => { bubble.move(); bubble.draw(); });
                    snakes.forEach(snake => {
                        const target = getClosestBubble(snake, bubbles);
                        snake.move(target);
                        snake.draw(target);
                        if (target && Math.hypot(snake.segments[0].x - target.x, snake.segments[0].y - target.y) < SNAKE_THICKNESS + target.radius) {
                            snake.score += target.mergeCount;
                            snake.grow(snake.color, target.mergeCount);
                            bubbles = bubbles.filter(b => b !== target);
                            for (let i = 0; i < target.mergeCount; i++) { bubbles.push(new Bubble(snake.color)); }
                            updateScoreboard();
                            if (snake.score >= WIN_SCORE) { endRound(snake); }
                        }
                    });
                    handleSnakeCollisions();
                    handleBubbleMerging();
                    break;

                case 'RESULTS':
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height); // Dim background
                    victoryAnimationState.winner.drawVictoryAnimation(victoryAnimationState.frame++);
                    if (Date.now() >= stateEndTime) changeState('INTERMISSION', 3);
                    break;

                case 'INTERMISSION':
                    ctx.font = '40px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = 'white';
                    ctx.fillText("Get set for the next round...", canvas.width / 2, canvas.height / 2);
                    if (Date.now() >= stateEndTime) changeState('PREDICTION');
                    break;
            }
            requestAnimationFrame(gameLoop);
        }
        
        changeState('PREDICTION');
        gameLoop();
    </script>
</body>
</html>