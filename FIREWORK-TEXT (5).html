<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fireworks Creator - Greg Seymour AI Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Montserrat:wght@700&family=Lobster&family=Bangers&family=Pacifico&family=Orbitron:wght@700&family=Russo+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --gui-bg: rgba(20, 20, 35, 0.9);
            --gui-border: rgba(120, 120, 255, 0.4);
            --accent-color-1: #8a2be2;
            --accent-color-2: #4169e1;
            --text-color: #f0f0f8;
            --input-bg: rgba(0, 0, 0, 0.3);
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            cursor: pointer;
            background-image: radial-gradient(circle at 50% 50%, #1a1a2a 0%, #000000 100%);
        }

        /* --- NEW: GUI STYLES --- */
        #guiContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--gui-bg);
            backdrop-filter: blur(10px);
            border: 2px solid var(--gui-border);
            border-radius: 15px;
            color: var(--text-color);
            padding: 25px;
            font-family: 'Montserrat', sans-serif;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.3);
            z-index: 100;
            transition: opacity 0.5s, transform 0.5s;
        }

        #guiContainer.hidden {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            pointer-events: none;
        }

        #guiContainer h1, #guiContainer h2 {
            text-align: center;
            font-family: 'Cinzel', serif;
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .gui-section {
            margin-bottom: 25px;
            border-top: 1px solid var(--gui-border);
            padding-top: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .input-group input[type="text"] {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid var(--gui-border);
            color: var(--text-color);
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            box-sizing: border-box;
        }

        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
        }

        .checkbox-container {
            position: relative;
            background: var(--input-bg);
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .checkbox-container:hover {
            background: rgba(138, 43, 226, 0.3);
        }
        .checkbox-container input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
        }
        .checkbox-container label {
            cursor: pointer;
            display: block;
            padding-left: 30px;
        }
        .checkmark {
            position: absolute;
            top: 10px;
            left: 10px;
            height: 20px;
            width: 20px;
            background-color: #333;
            border: 1px solid var(--gui-border);
            border-radius: 4px;
        }
        .checkbox-container input:checked ~ .checkmark {
            background: linear-gradient(45deg, var(--accent-color-1), var(--accent-color-2));
        }
        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
            left: 6px;
            top: 2px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 3px 3px 0;
            transform: rotate(45deg);
        }
        .checkbox-container input:checked ~ .checkmark:after {
            display: block;
        }

        .controls-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .select-buttons button {
            background: none;
            border: none;
            color: var(--accent-color-2);
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            padding: 5px;
        }
        .select-buttons button:hover {
            text-decoration: underline;
        }
        
        #launchButton {
            display: block;
            width: 100%;
            padding: 15px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            color: white;
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 20px;
        }
        #launchButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.5);
        }

        #menuButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            font-family: 'Orbitron', sans-serif;
            background: var(--gui-bg);
            color: var(--text-color);
            border: 2px solid var(--gui-border);
            border-radius: 8px;
            cursor: pointer;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        #menuButton.visible {
            opacity: 1;
            pointer-events: all;
        }
    </style>
</head>
<body>
    <div id="guiContainer">
        <h1>Fireworks Creator</h1>
        
        <div class="gui-section">
            <h2>1. Your Message</h2>
            <div class="input-group" id="messageInputs">
                <!-- Inputs will be generated by JS -->
            </div>
        </div>

        <div class="gui-section">
            <div class="controls-group">
                <h2>2. Color Palettes</h2>
                <div class="select-buttons">
                    <button data-action="select-all" data-target="palette-checkboxes">All</button> |
                    <button data-action="deselect-all" data-target="palette-checkboxes">None</button>
                </div>
            </div>
            <div class="checkbox-grid" id="palette-checkboxes"></div>
        </div>
        
        <div class="gui-section">
            <div class="controls-group">
                <h2>3. Fonts</h2>
                 <div class="select-buttons">
                    <button data-action="select-all" data-target="font-checkboxes">All</button> |
                    <button data-action="deselect-all" data-target="font-checkboxes">None</button>
                </div>
            </div>
            <div class="checkbox-grid" id="font-checkboxes"></div>
        </div>

        <div class="gui-section">
            <div class="controls-group">
                <h2>4. Firework Types</h2>
                 <div class="select-buttons">
                    <button data-action="select-all" data-target="firework-checkboxes">All</button> |
                    <button data-action="deselect-all" data-target="firework-checkboxes">None</button>
                </div>
            </div>
            <div class="checkbox-grid" id="firework-checkboxes"></div>
        </div>
        
        <div class="gui-section">
            <div class="checkbox-container">
                <input type="checkbox" id="randomize-checkbox">
                <label for="randomize-checkbox">Let the AI Decide! (Randomize Selections)</label>
                <span class="checkmark"></span>
            </div>
        </div>

        <button id="launchButton">Launch Show</button>
    </div>

    <button id="menuButton">Change Show</button>
    <canvas id="fireworksCanvas"></canvas>

    <script>
        // --- Core Canvas and Context ---
        const canvas = document.getElementById('fireworksCanvas');
        const ctx = canvas.getContext('2d');

        // --- GUI Elements ---
        const guiContainer = document.getElementById('guiContainer');
        const menuButton = document.getElementById('menuButton');
        const launchButton = document.getElementById('launchButton');
        
        // --- Constants & Palettes ---
        const COLOR_PALETTES = {
            "NEON_PARTY": [295, 200, 120, 30, 330], "OCEAN_BREEZE": [180, 200, 220, 240],
            "SUNSET": [15, 30, 45, 60], "GOLD_AND_SILVER": [50, 0],
            "ROYAL_PURPLE": [260, 275, 290, 45], "EMBER_GLOW": [5, 15, 25, 35],
            "FOREST_MYSTERY": [120, 140, 160, 60], "CYBERPUNK": [310, 180, 220],
            "MINT_CHOCOLATE": [150, 90, 30], "COSMIC_DUST": [250, 320, 210],
            "PATRIOTIC": [360, 240, 0], "LOVE": [350, 0, 340],
            "SPRING_MEADOW": [120, 80, 340, 60], "VOLCANIC_FURY": [0, 15, 30, 45],
            "NORTHERN_LIGHTS": [160, 180, 280, 300], "CANDY_SHOP": [330, 190, 60],
            "DEEP_SPACE": [240, 260, 310, 0]
        };
        const FONT_LIST = ['Cinzel', 'Montserrat', 'Lobster', 'Bangers', 'Pacifico', 'Orbitron', 'Russo One'];
        const FIREWORK_TYPES = ['NORMAL', 'HEART', 'STAR', 'WEEPING_WILLOW', 'CRACKLE_BURST'];

        // --- Configuration ---
        const TEXT_REVEAL_DELAY = 90;
        const LETTER_REVEAL_SPEED = 12;
        const RESET_DELAY = 400; 
        const FIREWORK_LEAD_TIME = 70;
        const TARGETED_FIREWORK_COUNT = 3;
        const CRACKLE_CHANCE = 0.4;
        const STAR_COUNT = 350; // Increased for a richer background
        const CLICK_FIREWORK_TYPES = ['HEART', 'STAR', 'WEEPING_WILLOW', 'CRACKLE_BURST'];

        // --- State Variables ---
        let fireworks = [], particles = [], sparklingLetters = [], stars = [];
        let textLayout = [], currentShowConfig;
        let framesSinceStart = 0, lettersRevealed = 0;
        let isComplete = false, framesSinceComplete = 0;
        let currentPalette; 
        let targetedFireworkLaunched = false;
        let clickFireworkTypeIndex = 0;
        
        // --- NEW: GUI and Sequence State ---
        let animationFrameId;
        let isGuiVisible = true;
        let showSequence = [];
        let currentSequenceIndex = 0;
        let menuButtonTimeout;
        let initialBlackoutTimeout;


        // --- Utility ---
        const random = (min, max) => Math.random() * (max - min) + min;
        const pickRandom = (arr) => arr[Math.floor(random(0, arr.length))];

        const getRandomPaletteColor = (palette = currentPalette) => {
            if (!palette || palette.length === 0) return 'hsl(0, 100%, 80%)'; 
            const baseHue = palette[Math.floor(random(0, palette.length))];
            const saturation = baseHue === 0 ? random(0, 10) : 100;
            return `hsl(${baseHue + random(-10, 10)}, ${saturation}%, ${random(65, 85)}%)`;
        };

        // --- Text Layout (Multi-line support, unchanged) ---
        function calculateTextLayout() {
            sparklingLetters = [];
            textLayout = [];
            lettersRevealed = 0;
            
            const size = Math.min(180, canvas.width / (Math.max(...currentShowConfig.lines.map(l => l.length)) * 0.7));

            ctx.font = `bold ${size}px ${currentShowConfig.font}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lines = currentShowConfig.lines;
            const numLines = lines.length;
            if (numLines === 0) return;

            const lineHeight = size * 1.3;
            const totalBlockHeight = (numLines - 1) * lineHeight;
            const startY = canvas.height / 2 - totalBlockHeight / 2;
            
            const layoutLine = (text, y) => {
                const lineWidth = ctx.measureText(text).width;
                let currentX = canvas.width / 2 - lineWidth / 2;
                for (const char of text) {
                    const charWidth = ctx.measureText(char).width;
                    textLayout.push({ char, x: currentX + charWidth / 2, y });
                    currentX += charWidth;
                }
            };
            
            lines.forEach((line, index) => {
                if (line) {
                    const lineY = startY + (index * lineHeight);
                    layoutLine(line, lineY);
                }
            });
        }
        
        // --- MODIFIED: Starfield can now be colored by selected palettes ---
        function createStarfield(palettesToUse = []) {
            stars = [];
            const useWhite = palettesToUse.length === 0;
            for (let i = 0; i < STAR_COUNT; i++) {
                const color = useWhite 
                    ? `rgba(255, 255, 255, ${random(0.1, 0.5)})`
                    : getRandomPaletteColor(pickRandom(palettesToUse));

                stars.push({
                    x: random(0, canvas.width),
                    y: random(0, canvas.height),
                    size: random(0.5, 2),
                    color: color,
                });
            }
        }

        // --- Classes (Particle, Firework, etc. - mostly unchanged) ---
        class Particle {
            constructor(x, y, color, velocity, gravity = 0.03, canCrackle = false) {
                this.x = x; this.y = y; this.color = color;
                this.velocity = velocity;
                this.alpha = 1; this.gravity = gravity; this.friction = 0.99;
                this.canCrackle = canCrackle;
            }
            draw() {
                ctx.save(); ctx.globalAlpha = this.alpha; ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color; ctx.fill(); ctx.restore();
            }
            update() {
                this.velocity.x *= this.friction; this.velocity.y *= this.friction;
                this.velocity.y += this.gravity; this.x += this.velocity.x;
                this.y += this.velocity.y; this.alpha -= 0.015;
                if (this.canCrackle && this.alpha > 0.7 && random(0, 1) < 0.1) {
                    this.canCrackle = false;
                    for (let i = 0; i < 5; i++) particles.push(new CrackleParticle(this.x, this.y));
                }
            }
        }
        class CrackleParticle extends Particle {
            constructor(x, y) {
                super(x, y, `hsl(50, 100%, ${random(80, 100)}%)`, { x: random(-2, 2), y: random(-2, 2) });
                this.alpha = 0.8; this.gravity = 0;
            }
            update(){ super.update(); this.alpha -= 0.08; }
        }
        class Firework {
            constructor(options = {}) {
                this.x = options.x ?? random(canvas.width * 0.2, canvas.width * 0.8);
                this.y = options.y ?? canvas.height;
                this.targetX = options.targetX ?? random(canvas.width * 0.2, canvas.width * 0.8);
                this.targetY = options.targetY ?? random(canvas.height * 0.2, canvas.height * 0.4);
                this.color = getRandomPaletteColor();
                const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                const speed = random(9, 14);
                this.velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                this.trail = []; this.exploded = false;
                this.type = options.type ?? currentShowConfig.fireworkType;
            }
            draw() {
                ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color; ctx.fill();
            }
            update() {
                this.y += this.velocity.y; this.x += this.velocity.x;
                this.velocity.y += 0.02;
                if (Math.hypot(this.targetX - this.x, this.targetY - this.y) < 5) {
                    this.exploded = true; this.explode();
                }
            }
            explode() {
                const particleCount = this.type === 'HEART' ? 100 : 150;
                for (let i = 0; i < particleCount; i++) {
                    let velocity, gravity = 0.03, particleColor = getRandomPaletteColor();
                    const canCrackle = random(0, 1) < CRACKLE_CHANCE;
                    switch (this.type) {
                        case 'HEART': {
                            const t = random(0, Math.PI * 2), speed = random(0.5, 1.5);
                            velocity = { x: (16 * Math.pow(Math.sin(t), 3)) * speed * 0.2, y: -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) * speed * 0.2 };
                            break;
                        }
                        case 'STAR': {
                            const angle = (i / particleCount) * Math.PI * 4, radius = (i % 2 === 0) ? 1 : 0.5, speed = random(2, 5);
                            velocity = { x: Math.cos(angle) * speed * radius, y: Math.sin(angle) * speed * radius };
                            break;
                        }
                        case 'WEEPING_WILLOW': {
                            const angle = random(-Math.PI / 4, Math.PI / 4) - Math.PI / 2, speed = random(1, 6);
                            velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            gravity = 0.08;
                            break;
                        }
                        case 'CRACKLE_BURST': {
                            particles.push(new CrackleParticle(this.x, this.y)); continue;
                        }
                        default: { // NORMAL
                            const angle = random(0, Math.PI * 2), speed = random(1, 8);
                            velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                        }
                    }
                    if (velocity) particles.push(new Particle(this.x, this.y, particleColor, velocity, gravity, canCrackle));
                }
            }
        }
        class SparklingLetter {
            constructor(char, x, y, color) {
                this.char = char; this.x = x; this.y = y; this.color = color;
                this.alpha = 0; this.scale = 0; this.scaleVelocity = 0.3; this.isBouncing = true;
                const size = Math.min(180, canvas.width / (Math.max(...currentShowConfig.lines.map(l => l.length)) * 0.7));
                this.size = size;
            }
            draw() {
                ctx.save(); ctx.globalAlpha = this.alpha;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowColor = this.color; ctx.shadowBlur = 15;
                ctx.font = `bold ${this.scale * this.size}px ${currentShowConfig.font}`;
                ctx.fillStyle = this.color;
                ctx.fillText(this.char, this.x, this.y); ctx.restore();
            }
            update() {
                if(this.alpha < 1) this.alpha += 0.08;
                if (this.isBouncing) {
                    this.scale += this.scaleVelocity; this.scaleVelocity -= 0.02;
                    if (this.scaleVelocity < -0.15) this.isBouncing = false;
                } else {
                    if (this.scale < 1) this.scale = Math.min(1, this.scale + 0.05);
                    else if (this.scale > 1) this.scale = Math.max(1, this.scale - 0.05);
                }
            }
        }


        // --- Main Animation Loop and Control ---
        function resetAnimation() {
            if (isGuiVisible || showSequence.length === 0) {
                stopAnimation();
                return;
            }

            fireworks = []; particles = []; sparklingLetters = [];
            isComplete = false;
            framesSinceStart = 0; framesSinceComplete = 0;
            targetedFireworkLaunched = false;
            
            // Get the next show config from our user-defined sequence
            currentSequenceIndex = (currentSequenceIndex + 1) % showSequence.length;
            currentShowConfig = showSequence[currentSequenceIndex];
            currentPalette = COLOR_PALETTES[currentShowConfig.palette];
            
            // Recalculate stars and layout for the new show
            createStarfield([currentPalette]);
            calculateTextLayout();
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            stars.forEach(star => {
                ctx.fillStyle = star.color;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            framesSinceStart++;
            
            // Launch firework to reveal next letter
            if (!isComplete && lettersRevealed < textLayout.length && !targetedFireworkLaunched) {
                const revealFrame = TEXT_REVEAL_DELAY + (lettersRevealed * LETTER_REVEAL_SPEED);
                if (framesSinceStart >= revealFrame - FIREWORK_LEAD_TIME) {
                    const nextLetter = textLayout[lettersRevealed];
                    if (nextLetter && nextLetter.char !== ' ') {
                        for (let i = 0; i < TARGETED_FIREWORK_COUNT; i++) {
                            fireworks.push(new Firework({ targetX: nextLetter.x, targetY: nextLetter.y }));
                        }
                    }
                    targetedFireworkLaunched = true;
                }
            }
            
            [...fireworks, ...particles, ...sparklingLetters].forEach(obj => {
                obj.update();
                obj.draw();
            });

            fireworks = fireworks.filter(fw => !fw.exploded);
            particles = particles.filter(p => p.alpha > 0);
            
            if (framesSinceStart > TEXT_REVEAL_DELAY && lettersRevealed < textLayout.length) {
                if ((framesSinceStart - TEXT_REVEAL_DELAY) % LETTER_REVEAL_SPEED === 0) {
                    const layout = textLayout[lettersRevealed];
                    if (layout && layout.char !== ' ') {
                        const color = getRandomPaletteColor();
                        sparklingLetters.push(new SparklingLetter(layout.char, layout.x, layout.y, color));
                    }
                    lettersRevealed++;
                    targetedFireworkLaunched = false;
                }
            }
            
            if (!isComplete && lettersRevealed === textLayout.length && textLayout.length > 0) {
                isComplete = true; framesSinceComplete = 0;
            }
            if (isComplete) {
                framesSinceComplete++;
                if (framesSinceComplete > RESET_DELAY) {
                    resetAnimation();
                }
            }
        }

        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
             ctx.fillStyle = 'black';
             ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // --- NEW: GUI Setup and Handling ---
        function populateGui() {
            // Message Inputs
            const messageContainer = document.getElementById('messageInputs');
            for (let i = 0; i < 5; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = `Line ${i + 1}`;
                messageContainer.appendChild(input);
            }

            // Checkbox creation helper
            const createCheckboxes = (containerId, items) => {
                const container = document.getElementById(containerId);
                items.forEach(item => {
                    const name = item.replace(/_/g, ' ');
                    const el = document.createElement('div');
                    el.className = 'checkbox-container';
                    el.innerHTML = `
                        <input type="checkbox" id="check-${item}" value="${item}">
                        <label for="check-${item}">${name}</label>
                        <span class="checkmark"></span>`;
                    container.appendChild(el);
                });
            };

            createCheckboxes('palette-checkboxes', Object.keys(COLOR_PALETTES));
            createCheckboxes('font-checkboxes', FONT_LIST);
            createCheckboxes('firework-checkboxes', FIREWORK_TYPES);
        }

        function handleLaunch() {
            // 1. Gather selections
            const lines = [...document.querySelectorAll('#messageInputs input')]
                .map(input => input.value.trim())
                .filter(line => line.length > 0);
            
            if (lines.length === 0) {
                alert("Please enter at least one line of text for your message.");
                return;
            }

            const getSelected = (containerId) => [...document.querySelectorAll(`#${containerId} input:checked`)].map(cb => cb.value);
            
            let selectedPalettes = getSelected('palette-checkboxes');
            let selectedFonts = getSelected('font-checkboxes');
            let selectedFireworkTypes = getSelected('firework-checkboxes');
            
            if (document.getElementById('randomize-checkbox').checked) {
                selectedPalettes = [pickRandom(Object.keys(COLOR_PALETTES))];
                selectedFonts = [pickRandom(FONT_LIST)];
                selectedFireworkTypes = [pickRandom(FIREWORK_TYPES)];
            }
            
            if (selectedPalettes.length === 0) selectedPalettes.push('NEON_PARTY');
            if (selectedFonts.length === 0) selectedFonts.push('Cinzel');
            if (selectedFireworkTypes.length === 0) selectedFireworkTypes.push('NORMAL');
            
            // 2. Build the show sequence
            showSequence = [];
            const allSelections = [
                ...selectedPalettes.map(p => ({ type: 'palette', value: p })),
                ...selectedFonts.map(f => ({ type: 'font', value: f })),
                ...selectedFireworkTypes.map(t => ({ type: 'fireworkType', value: t }))
            ];
            
            // Shuffle for variety
            for (let i = allSelections.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allSelections[i], allSelections[j]] = [allSelections[j], allSelections[i]];
            }
            
            allSelections.forEach(selection => {
                showSequence.push({
                    lines: lines,
                    palette: selection.type === 'palette' ? selection.value : pickRandom(selectedPalettes),
                    font: selection.type === 'font' ? selection.value : pickRandom(selectedFonts),
                    fireworkType: selection.type === 'fireworkType' ? selection.value : pickRandom(selectedFireworkTypes),
                });
            });

            // 3. Hide GUI and start the show
            isGuiVisible = false;
            guiContainer.classList.add('hidden');
            clearTimeout(initialBlackoutTimeout);
            
            // Black screen for 3 seconds
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            stars = [];

            initialBlackoutTimeout = setTimeout(() => {
                currentSequenceIndex = -1; // So the first call to resetAnimation starts at 0
                resetAnimation();
                animate();
            }, 3000);
        }

        function showGui() {
            stopAnimation();
            isGuiVisible = true;
            guiContainer.classList.remove('hidden');
            menuButton.classList.remove('visible');
        }
        
        function handleUserActivity() {
            if (isGuiVisible) return;
            menuButton.classList.add('visible');
            clearTimeout(menuButtonTimeout);
            menuButtonTimeout = setTimeout(() => {
                menuButton.classList.remove('visible');
            }, 4000);
        }


        // --- Event Listeners and Initialization ---
        function onResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (!isGuiVisible) {
                createStarfield();
                calculateTextLayout();
            }
        }
        
        window.addEventListener('resize', onResize);
        window.addEventListener('mousemove', handleUserActivity);
        
        canvas.addEventListener('click', (e) => {
             if (isGuiVisible) return;
             handleUserActivity(); // Show menu button on click too
             const fireworkType = CLICK_FIREWORK_TYPES[clickFireworkTypeIndex];
             fireworks.push(new Firework({ targetX: e.clientX, targetY: e.clientY, type: fireworkType }));
             clickFireworkTypeIndex = (clickFireworkTypeIndex + 1) % CLICK_FIREWORK_TYPES.length;
        });

        launchButton.addEventListener('click', handleLaunch);
        menuButton.addEventListener('click', showGui);

        document.querySelectorAll('[data-action]').forEach(button => {
            button.addEventListener('click', (e) => {
                const action = e.target.dataset.action;
                const targetId = e.target.dataset.target;
                const checkboxes = document.querySelectorAll(`#${targetId} input[type="checkbox"]`);
                checkboxes.forEach(cb => {
                    cb.checked = (action === 'select-all');
                });
            });
        });

        // --- Initial Setup ---
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        populateGui();
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    </script>
</body>
</html>