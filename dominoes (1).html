<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whimsical Domino Master</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #444;
            color: white;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .label { font-size: 10px; color: #0ff; text-transform: uppercase; letter-spacing: 2px; }
        .group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        button {
            background: #222; border: 1px solid #555; color: white;
            padding: 8px 12px; border-radius: 6px; cursor: pointer;
            font-size: 11px; transition: 0.2s;
        }
        button:hover { background: #0ff; color: #000; border-color: #fff; }
        button.active { background: #0ff; color: #000; font-weight: bold; }

        #follow-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 0, 0.2);
            color: #0f0;
            padding: 8px 20px;
            border-radius: 20px;
            border: 1px solid #0f0;
            font-size: 12px;
            display: none;
            pointer-events: none;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="ui">
        <div class="label">Pattern Gallery</div>
        <div class="group">
            <button onclick="window.layout('heart')">Heart ‚ù§Ô∏è</button>
            <button onclick="window.layout('spiral')">Spiral üåÄ</button>
            <button onclick="window.layout('infinity')">Infinity ‚ôæÔ∏è</button>
            <button onclick="window.layout('zigzag')">Zig-Zag ‚ö°</button>
        </div>

        <div class="label">Camera Mode</div>
        <div class="group">
            <button id="btnFree" class="active" onclick="window.setFollow(false)">Free Orbit</button>
            <button id="btnFollow" onclick="window.setFollow(true)">Follow Lead</button>
        </div>

        <button onclick="window.reset()" style="margin-top:10px; background: #d00; border: none; font-weight: bold;">RESET SCENE</button>
    </div>

    <div id="follow-status">üé• CINEMATIC TRACKING ACTIVE</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Settings ---
        const COUNT = 600;
        const DIM = { w: 0.15, h: 1.0, d: 0.5 }; // d is the length (the way it falls)
        const SPACING = 0.45; 

        let scene, camera, renderer, controls, raycaster, mouse;
        let dominoes = [];
        let leadDomino = null;
        let isFollow = false;
        let startMarker;
        let currentPattern = 'heart';

        class Domino {
            constructor(index) {
                this.index = index;
                // Create geometry: Pivot at the BOTTOM edge (0,0,0)
                const geo = new THREE.BoxGeometry(DIM.w, DIM.h, DIM.d);
                geo.translate(0, DIM.h / 2, 0); 
                
                this.material = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.1,
                    metalness: 0.5
                });
                
                this.mesh = new THREE.Mesh(geo, this.material);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                
                this.reset();
                scene.add(this.mesh);
            }

            reset() {
                this.state = 'standing';
                this.angle = 0;
                this.velocity = 0;
                this.mesh.rotation.set(0, 0, 0);
                
                // Whimsical color gradient
                const hue = (this.index / COUNT);
                this.material.color.setHSL(hue, 0.8, 0.5);
                this.material.emissive.setHSL(hue, 0.8, 0.2);
            }

            place(x, z, rotY) {
                this.mesh.position.set(x, 0, z);
                this.mesh.rotation.y = rotY;
                this.rotY = rotY;
                this.reset();
                this.mesh.visible = true;
                if(this.index === 0) this.material.emissive.setHex(0x00ff00);
            }

            update(dt) {
                if (this.state === 'falling') {
                    this.velocity += 15 * dt;
                    this.angle += this.velocity * dt;

                    if (this.angle >= 1.4) {
                        this.angle = 1.4;
                        this.state = 'down';
                    }

                    // Physics: Fall length-ways (Forward on local Z axis)
                    this.mesh.rotation.set(0, this.rotY, 0);
                    this.mesh.rotateX(-this.angle);

                    this.triggerNext();
                    leadDomino = this;
                }
            }

            triggerNext() {
                if (this.angle < 0.3) return;
                const next = dominoes[this.index + 1];
                if (next && next.state === 'standing' && next.mesh.visible) {
                    const d = this.mesh.position.distanceTo(next.mesh.position);
                    if (d < 0.8) next.state = 'falling';
                }
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.FogExp2(0x020205, 0.04);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
            camera.position.set(20, 15, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 100;

            const sun = new THREE.DirectionalLight(0xffffff, 2);
            sun.position.set(10, 30, 10);
            sun.castShadow = true;
            scene.add(sun);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 500),
                new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.2 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Green Start Arrow
            const arrowGeo = new THREE.ConeGeometry(0.4, 0.8, 4);
            startMarker = new THREE.Mesh(arrowGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            startMarker.rotation.x = Math.PI;
            scene.add(startMarker);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            for(let i=0; i < COUNT; i++) dominoes.push(new Domino(i));
            
            window.layout('heart');
            window.addEventListener('mousedown', onClick);
            window.addEventListener('resize', onResize);
        }

        window.layout = function(type) {
            currentPattern = type;
            dominoes.forEach(d => d.mesh.visible = false);
            leadDomino = null;
            startMarker.visible = true;

            const points = [];
            if (type === 'heart') {
                for (let i = 0; i < COUNT; i++) {
                    const t = (i / COUNT) * Math.PI * 2;
                    const x = 16 * Math.pow(Math.sin(t), 3) * 0.6;
                    const z = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.6;
                    points.push(new THREE.Vector3(x, 0, z));
                }
            } else if (type === 'spiral') {
                for (let i = 0; i < COUNT; i++) {
                    const a = 0.1 * i;
                    const r = 0.08 * i;
                    points.push(new THREE.Vector3(r * Math.cos(a), 0, r * Math.sin(a)));
                }
            } else if (type === 'infinity') {
                for (let i = 0; i < COUNT; i++) {
                    const t = (i / COUNT) * Math.PI * 2;
                    const x = 15 * Math.sin(t);
                    const z = 15 * Math.sin(t) * Math.cos(t);
                    points.push(new THREE.Vector3(x, 0, z));
                }
            } else if (type === 'zigzag') {
                for (let i = 0; i < COUNT; i++) {
                    const x = (i * 0.4) - (COUNT * 0.2);
                    const z = Math.sin(i * 0.15) * 6;
                    points.push(new THREE.Vector3(x, 0, z));
                }
            }

            // Correct orientation: Each domino faces the next one
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const nextP = points[i + 1] || points[i];
                const rotY = Math.atan2(nextP.x - p.x, nextP.z - p.z);
                dominoes[i].place(p.x, p.z, rotY);
            }

            startMarker.position.set(dominoes[0].mesh.position.x, 3, dominoes[0].mesh.position.z);
            camera.position.set(25, 20, 25);
            controls.target.set(0,0,0);
        };

        window.setFollow = function(val) {
            isFollow = val;
            document.getElementById('btnFree').className = !val ? 'active' : '';
            document.getElementById('btnFollow').className = val ? 'active' : '';
            document.getElementById('follow-status').style.display = (val && leadDomino) ? 'block' : 'none';
        };

        window.reset = function() { window.layout(currentPattern); };

        function onClick(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(dominoes.filter(d => d.mesh.visible).map(d => d.mesh));
            if (hits.length > 0) {
                const d = dominoes.find(dom => dom.mesh === hits[0].object);
                d.state = 'falling';
                startMarker.visible = false;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = 0.016;

            dominoes.forEach(d => { if(d.mesh.visible) d.update(dt); });

            // Marker Bouncing
            if(startMarker.visible) {
                startMarker.position.y = 2.5 + Math.sin(Date.now() * 0.005) * 0.5;
                startMarker.rotation.y += 0.02;
            }

            // Chase Camera Logic
            if (isFollow && leadDomino && leadDomino.state !== 'standing') {
                const offset = 8;
                const camX = leadDomino.mesh.position.x - Math.sin(leadDomino.rotY) * offset;
                const camZ = leadDomino.mesh.position.z - Math.cos(leadDomino.rotY) * offset;
                const targetCamPos = new THREE.Vector3(camX, 5, camZ);
                
                camera.position.lerp(targetCamPos, 0.05);
                controls.target.lerp(leadDomino.mesh.position, 0.1);
                document.getElementById('follow-status').style.display = 'block';
            } else {
                document.getElementById('follow-status').style.display = 'none';
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>