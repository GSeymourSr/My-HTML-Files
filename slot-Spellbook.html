<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emoji Sorcerer's Spellbook (Cleaned)</title>
  <style>
    :root {
      /* --- Emoji Sorcerer's Spellbook Theme --- */
      --bg-color-main: #2c1f39;
      --bg-color-accent: #1e1528;
      --machine-border: #FFD700;
      --title-bg: linear-gradient(to bottom, #7B1FA2, #4A148C);
      --title-text-color: #EDE7F6;
      --title-shadow: rgba(0,0,0,0.5);
      --money-color: #FFEB3B;
      --reels-bg: #4527A0;
      --reel-bg: #5E35B1;
      --button-bg: linear-gradient(to bottom, #AB47BC, #8E44AD);
      --button-border: #6A1B9A;
      --button-hover-bg: linear-gradient(to bottom, #CE93D8, #AB47BC);
      --spin-button-bg: linear-gradient(to bottom, #FFB300, #FF8F00);
      --spin-button-border: #FF6F00;
      --message-bg: rgba(40, 20, 60, 0.92);
      --message-text-color: #FCE4EC;
      --message-win-color: #4CAF50;
      --message-bigwin-color: #FFC107;
      --paytable-bg: rgba(69, 39, 160, 0.97);
      --paytable-text-color: #D1C4E9;
      --paytable-header-bg: rgba(123, 31, 162, 0.9);

      --bonus-bg: rgba(30, 21, 40, 0.98);
      --bonus-text: #E1BEE7;
      --bonus-item-bg: #7E57C2;
      --bonus-item-hover-bg: #9575CD;

      --reel-width: 70px;
      --reel-height: 70px; /* Matches JS config.symbolHeight */
      --symbol-size: 45px;
      --num-reels: 5; /* Matches JS config.reelCount */
      --num-rows: 5;  /* Matches JS config.rowCount */
      --reel-gap: 6px;

      --g-color1: #FF6B6B; --g-color2: #FFA26B; --g-color3: #FFD76B;
      --g-color4: #4ECDC4; --g-color5: #54A0FF;
    }

    @keyframes gradientTextFlow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    .animated-gradient-text {
        background-size: 250% 250%;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent !important; /* Ensure gradient is visible */
        animation: gradientTextFlow 8s linear infinite;
        display: inline-block; /* Needed for background-clip to work as expected on span/div */
    }

    body {
      margin: 0;
      font-family: 'Cinzel Decorative', 'Times New Roman', serif;
      background: linear-gradient(135deg, var(--bg-color-accent) 0%, var(--bg-color-main) 100%);
      color: var(--paytable-text-color);
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      width: 100vw;
      overflow: hidden;
      box-sizing: border-box;
    }

    #app-wrapper {
        display: flex; /* Will be set to flex by JS after title screen */
        width: 100%;
        height: 100%;
        padding: 10px; /* Outer padding for the whole game area */
        box-sizing: border-box;
    }

    #title-screen {
        display: flex; /* Initially visible */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        height: 100%;
        width: 100%;
        background: linear-gradient(135deg, #311B92, #1A237E 50%, #0D47A1);
        position: fixed;
        top: 0;
        left: 0;
        z-index: 100;
        padding: 20px;
        box-sizing: border-box;
    }
    #title-screen .main-title-ts {
        font-size: clamp(2.5rem, 7vw, 4.5rem);
        font-weight: bold;
        margin-bottom: 15px;
        font-family: 'Nosifer', 'Metamorphous', cursive;
        background-image: linear-gradient(90deg, var(--money-color), #FFEE58, #FCE4EC, var(--money-color));
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    #title-screen .sub-title-ts {
        font-size: clamp(1rem, 2.2vw, 1.5rem);
        color: #D1C4E9;
        margin-bottom: 30px;
        max-width: 70%;
        line-height: 1.5;
        font-family: 'Cinzel Decorative', serif;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    }
    #title-screen #start-button {
        font-family: 'MedievalSharp', cursive;
        font-size: clamp(1.4rem, 4vw, 2rem);
        padding: 12px 30px;
        border-radius: 8px;
        background: linear-gradient(145deg, #FFB300, #FF8F00);
        border: 3px solid #FFFDE7;
        color: #4A0072;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 0 15px #FFB300, 0 5px 10px rgba(0, 0, 0, 0.3);
        text-shadow: 1px 1px 1px rgba(255,255,255,0.2);
        text-transform: uppercase;
        font-weight: bold;
    }
    #title-screen #start-button:hover {
        transform: scale(1.05);
        box-shadow: 0 0 25px #FFB300, 0 7px 15px rgba(0, 0, 0, 0.4);
    }

    /* #game-title-header REMOVED as per request */

    #game-layout-container {
        display: none; /* Initially hidden, shown by JS */
        flex-direction: row; /* Default for wider screens: paytable left, game right */
        width: 100%;
        height: 100%;
        gap: 10px;
        align-items: stretch;
        box-sizing: border-box;
    }
    #paytable-panel {
        flex: 0 0 280px;
        background: var(--paytable-bg); border-radius: 10px;
        padding: 10px; box-shadow: 0 0 10px rgba(255,215,0,0.15); overflow-y: auto;
        border: 2px solid var(--machine-border); display: flex; flex-direction: column;
        max-height: calc(100vh - 40px);
    }
    #paytable-panel h2 {
        text-align: center; color: var(--machine-border); font-family: 'Uncial Antiqua', cursive;
        font-size: 1.6em; margin-top: 0; margin-bottom: 6px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    .paytable-table { width: 100%; border-collapse: collapse; margin-top: 6px; font-size: 0.7em;}
    .paytable-table th, .paytable-table td { border: 1px solid var(--machine-border); padding: 3px; text-align: center; vertical-align: middle; }
    .paytable-table th { background-color: var(--paytable-header-bg); color: #fff; font-weight: bold; }
    .paytable-table td { color: var(--paytable-text-color); }
    .paytable-symbol-emoji { font-size: 18px; vertical-align: middle; }
    .paytable-symbol-name { font-weight: bold; text-transform: capitalize; font-size: 0.85em; }
    .paytable-wild-info { margin-top: 10px; font-size: 0.75em; text-align: center; color: var(--money-color); line-height: 1.3; }
    @keyframes paytableWinFlashSpell {
        0%, 100% { background-color: transparent; transform: scale(1); }
        50% { background-color: var(--message-win-color); transform: scale(1.05); color: #fff !important; }
    }
    .paytable-table td.paytable-win-flash { animation: paytableWinFlashSpell 0.8s ease-in-out infinite; }

    #main-game-area {
        flex-grow: 1; display: flex; flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 0; overflow: hidden; min-width: 0;
        height: 100%;
    }
    #slot-machine {
      background: linear-gradient(145deg, #311B92, #4527A0);
      border: 4px solid var(--machine-border);
      border-radius: 8px; padding: 10px;
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.3), inset 0 0 6px rgba(0,0,0,0.2);
      text-align: center;
      width: 100%;
      height: auto;
      /* max-height: calc(100% - 50px); Keep this to prevent machine from getting too tall if content pushes it */
      max-height: calc(100vh - 20px - 20px); /* 100vh - body padding - slot machine's own potential vertical margins/padding */
      box-sizing: border-box; display: flex; flex-direction: column;
      justify-content: space-around; position: relative; z-index: 1;
      /* margin-top: 45px; REMOVED as game-title-header is gone, allow natural centering */
    }
    #title {
      font-size: clamp(1.4em, 2.5vw, 1.8em); font-weight: bold;
      text-shadow: 1px 1px 2px var(--title-shadow), 0 0 5px var(--machine-border);
      background: var(--title-bg); padding: 7px; margin: 0 auto 8px auto;
      border-radius: 5px 5px 0 0; border-bottom: 2px solid var(--machine-border);
      line-height: 1.1; letter-spacing: 1px; width: 95%; box-sizing: border-box;
      font-family: 'Metamorphous', cursive;
    }
     #title .main-title-ingame {
        background-image: linear-gradient(90deg, var(--g-color1), var(--g-color2), var(--g-color3), var(--g-color1));
     }
     /* MODIFIED: Subtitle style for combined text */
     #title .subtitle {
        font-size: clamp(0.4em, 1vw, 0.6em); /* Adjusted size for two lines */
        color: #F3E5F5; font-weight: normal; display: block;
        margin-top: 4px; /* Slightly more space for two lines */
        text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        line-height: 1.3; /* Ensure lines in subtitle are spaced okay */
      }
    #money-display {
      font-size: clamp(1.3em, 2.1vw, 1.6em); margin: 6px 0; color: var(--money-color);
      text-shadow: 0 0 5px #000; background-color: rgba(20,10,30,0.85);
      padding: 6px 10px; border-radius: 4px; display: inline-block; border: 1px solid var(--money-color);
      font-weight: bold;
    }

    #reels-container {
      display: grid; grid-template-columns: repeat(var(--num-reels), var(--reel-width));
      grid-gap: var(--reel-gap); justify-content: center; margin-bottom: 8px;
      background: var(--reels-bg); padding: 6px; border-radius: 4px;
      border: 1px solid var(--machine-border);
      height: calc(var(--num-rows) * var(--reel-height));
      position: relative; align-self: center;
    }
    .reel {
        width: var(--reel-width);
        height: calc(var(--num-rows) * var(--reel-height));
        overflow: hidden; background: var(--reel-bg); border-radius: 3px;
        position: relative; box-shadow: inset 0 0 3px rgba(0,0,0,0.2);
    }
    .symbols-container { position: absolute; top: 0; left: 0; width: 100%; }
    .reel.spinning .symbols-container { transition: transform 0.08s linear; filter: blur(1.2px) brightness(1.1); }
    .reel.stopping .symbols-container { transition: transform 0.7s cubic-bezier(0.1, 0.7, 0.3, 1); filter: blur(0px); }
    .symbol {
        width: var(--reel-width); height: var(--reel-height);
        display: flex; align-items: center; justify-content: center;
        font-size: var(--symbol-size); position: relative; box-sizing: border-box;
        line-height: 1; text-shadow: 0 0 2px rgba(255,255,255,0.3), 0 0 5px var(--machine-border);
        user-select: none; color: #F0E8FF;
    }
    @keyframes symbolWinFlashSpell {
        0%,100%{transform:scale(1); opacity: 1; filter: brightness(1);}
        50%{transform:scale(1.15) rotate(-2deg); opacity: 0.95; filter: brightness(1.4) drop-shadow(0 0 4px var(--message-win-color));}
    }
    .symbol.winning { animation: symbolWinFlashSpell 0.6s ease-in-out infinite; z-index: 10; outline: 1.5px solid var(--message-win-color); background-color: rgba(76, 175, 80, 0.1); outline-offset: -1.5px; }

    #controls {
      margin: 8px 0 6px 0; display: flex; flex-wrap: wrap; justify-content: center;
      gap: clamp(3px, 0.7vw, 6px);
    }
    #controls input, #controls button {
      font-family: 'MedievalSharp', cursive; font-size: clamp(0.75em, 1.2vw, 0.9em);
      padding: clamp(6px, 0.8vw, 8px) clamp(8px, 1.3vw, 12px); margin: clamp(2px, 0.4vw, 3px);
      border-radius: 3px; border: 1px solid var(--button-border); background: var(--button-bg);
      color: #fff; cursor: pointer; transition: all 0.15s ease-out;
      box-shadow: 0 1.5px 0px #4A148C, 0 2px 3px rgba(0,0,0,0.3);
      text-shadow: 1px 1px 1px rgba(0,0,0,0.4); font-weight: bold; text-transform: uppercase;
    }
    #controls input { width: clamp(50px, 7vw, 60px); text-align: center; background: #fff; color: #333; text-shadow: none; }
    #controls button:hover:not(:disabled) { background: var(--button-hover-bg); transform: translateY(-1px); box-shadow: 0 2.5px 0px #4A148C, 0 3px 5px rgba(0,0,0,0.4); }
    #spin {
        font-size: clamp(0.8em, 1.4vw, 0.95em); padding: clamp(7px, 1.1vw, 10px) clamp(15px, 2vw, 18px);
        background: var(--spin-button-bg); border-color: var(--spin-button-border); color: #4E342E; text-shadow: 1px 1px 0px rgba(255,255,255,0.3);
    }
    #spin:hover:not(:disabled) { background: linear-gradient(to bottom, #FFCA28, #FFB300); border-color: #FF8F00; }
    #maxBet { background: linear-gradient(to bottom, #7E57C2, #5E35B1); border-color: #4527A0; color: #fff;}

    #message {
      font-size: clamp(0.85em, 1.5vw, 0.95em); margin-top: 6px; min-height: clamp(28px, 5vh, 35px); padding: 6px;
      background-color: var(--message-bg); border-radius: 3px; color: var(--message-text-color); text-shadow: none;
      white-space: pre-line; line-height: 1.2; border: 1px solid var(--machine-border);
      box-shadow: inset 0 0 6px rgba(255,215,0,0.25); font-weight: bold;
      width: 90%; align-self: center; box-sizing: border-box;
    }
    #message.win { color: var(--message-win-color); font-weight: bold; text-shadow: 0 0 4px var(--message-win-color); }
    @keyframes bigWinMessagePulseSpell {0%{transform:scale(1);opacity:.9}100%{transform:scale(1.02);opacity:1}}
    #message.big-win { font-size: clamp(1em, 2vw, 1.2em); color: var(--message-bigwin-color); animation: bigWinMessagePulseSpell 0.6s infinite alternate; font-weight: bold; text-shadow: 0 0 6px var(--message-bigwin-color), 0 0 12px var(--machine-border); }

    /* --- Potion Bonus Screen Styles --- */
    #bonus-potion-screen {
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: var(--bonus-bg); color: var(--bonus-text);
        z-index: 200; flex-direction: column; align-items: center;
        justify-content: center;
        padding: clamp(15px, 4vh, 30px);
        box-sizing: border-box; text-align: center;
    }
    #bonus-potion-screen h2 {
        font-family: 'Metamorphous', cursive; font-size: clamp(1.5em, 3vw, 2em);
        color: var(--machine-border); text-shadow: 1px 1px 2px #000;
        margin-bottom: clamp(10px, 3vh, 20px);
    }
    #bonus-potion-screen p#bonus-instructions {
      font-size: clamp(0.85em, 2vw, 1.1em);
      margin-bottom: clamp(10px, 3vh, 20px);
    }
    #potion-items-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(clamp(75px, 16vw, 100px), 1fr));
        gap: clamp(10px, 2vw, 18px);
        width: 90%;
        max-width: clamp(450px, 85vw, 700px);
        margin-bottom: 12px;
    }
    .potion-item {
        background-color: var(--bonus-item-bg); padding: 10px;
        min-height: clamp(40px, 10vmin, 60px);
        border-radius: 5px;
        font-size: clamp(1.8em, 5vmin, 2.8em);
        color: #fff; cursor: pointer; transition: background-color 0.2s, transform 0.2s;
        border: 1.5px solid var(--button-border); box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        display: flex; align-items: center; justify-content: center; text-align: center;
    }
    .potion-item:hover:not(.picked) { background-color: var(--bonus-item-hover-bg); transform: scale(1.05); }
    .potion-item.picked { opacity: 0.5; cursor: default; background-color: #3E2723; transform: scale(0.95); }

    /* MODIFIED: Spacing for collected ingredients */
    #potion-ingredients-collected {
      margin-bottom: clamp(12px, 2.5vh, 20px); /* Increased bottom margin */
      font-size: clamp(0.85em, 2vw, 1em);
      line-height: 1.6; /* For better spacing if they wrap */
    }
    #potion-ingredients-collected span {
        display: inline-block; padding: 4px 8px; /* Increased padding */
        background-color: #311B92;
        border-radius: 3px;
        margin: 4px 6px; /* MODIFIED: Increased margin for spacing */
        border: 1px solid var(--machine-border); font-size: 0.9em;
    }
    #bonus-winnings-display {
        font-size: clamp(1em, 2.5vw, 1.4em); color: var(--money-color);
        font-weight: bold;
        margin-bottom: clamp(15px, 3vh, 25px);
    }
    #collect-bonus-button {
        padding: 8px 18px; font-size: clamp(0.85em, 2vw, 1.1em);
        font-family: 'MedievalSharp', cursive; text-transform: uppercase;
        background: var(--spin-button-bg); border-color: var(--spin-button-border); color: #4E342E; text-shadow: 1px 1px 0px rgba(255,255,255,0.3);
        cursor: pointer;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        #game-layout-container {
            flex-direction: column;
            overflow-y: auto;
        }
        #paytable-panel {
            flex: 0 0 auto;
            max-height: 250px;
            margin-bottom: 10px;
        }
        #slot-machine {
            /* margin-top: 50px; Potentially adjust if needed without top fixed header */
        }
        #main-game-area {
             justify-content: flex-start;
             padding-top: 10px;
        }
         #title { font-size: clamp(1.2em, 4vw, 1.6em); }
    }
     @media (max-height: 600px) and (min-width: 769px) {
        #slot-machine {
            padding: 5px;
            /* margin-top: 45px; */
        }
        #title {
            font-size: clamp(1.2em, 2vw, 1.5em);
            padding: 5px; margin-bottom: 5px;
        }
        #money-display { font-size: clamp(1.1em, 1.8vw, 1.4em); margin: 4px 0; }
        #reels-container { margin-bottom: 5px; }
    }
     @media (max-height: 500px) {
        #paytable-panel { max-height: 150px; }
        #title { display: none; }
        #slot-machine { /* margin-top: 40px; */ padding: 5px; }
        #controls button { padding: 5px 8px; font-size: clamp(0.7em, 1vw, 0.8em); }
        #spin { padding: 6px 10px; }
    }

  </style>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Uncial+Antiqua&family=Metamorphous&family=MedievalSharp&family=Nosifer&family=Fredoka+One&family=Bangers&family=Carter+One&family=Luckiest+Guy&family=Poppins:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="title-screen">
        <div class="main-title-ts animated-gradient-text">Emoji Sorcerer's Spellbook</div>
        <p class="sub-title-ts">Uncover ancient enchantments and brew potions of power! The ✨ Magic Sparkle is WILD and can complete any spell!</p>
        <button id="start-button">Open the Grimoire!</button>
    </div>

    <!-- #game-title-header DIV REMOVED -->

  <div id="app-wrapper" style="display:none;">
      <div id="game-layout-container">
          <aside id="paytable-panel">
              <h2>Spellbook Index</h2>
              <div id="paytable-content"></div>
          </aside>
          <main id="main-game-area">
              <div id="slot-machine">
                <div id="title"> <!-- MODIFIED: Subtitle content -->
                    <span class="main-title-ingame animated-gradient-text">Sorcerer's Spellbook</span>
                    <span class="subtitle">By Greg Seymour &amp; AI<br>Where Magic Meets Fortune!</span>
                </div>
                <div id="money-display">Mana Crystals: $100</div>
                <div id="reels-container"></div>
                <div id="controls">
                  <label for="bet">Bet:</label>
                  <input type="number" id="bet" value="5" min="1">
                  <button id="maxBet">Max Mana</button>
                  <button id="spin">Cast!</button>
                  <button id="auto">Auto-Enchant</button>
                  <button id="reset">New Chapter</button>
                </div>
                <div id="message">Choose your spell (bet) and cast the reels!</div>
              </div>
          </main>
      </div>
  </div>


  <div id="bonus-potion-screen">
      <h2>Brew a Powerful Potion!</h2>
      <p id="bonus-instructions">You have <span id="bonus-picks-left">5</span> picks. Find 3 Special Ingredients for a Grand Bonus!</p>
      <div id="potion-ingredients-collected">Collected: </div>
      <div id="potion-items-container"></div>
      <p id="bonus-winnings-display">Bonus Winnings: $0</p>
      <button id="collect-bonus-button" style="display:none;">Collect Your Spoils!</button>
  </div>

  <!--
    To enable sounds, uncomment these lines and ensure the .mp3 files are in a 'sounds' directory
    relative to your HTML file, or update the src paths accordingly.
  <audio id="spin-sound" src="sounds/magic_swirl_spin.mp3" preload="auto"></audio>
  <audio id="win-sound" src="sounds/short_magic_win.mp3" preload="auto"></audio>
  <audio id="big-win-sound" src="sounds/epic_magic_win_long.mp3" preload="auto"></audio>
  <audio id="reel-stop-sound" src="sounds/reel_stop_thud.mp3" preload="auto"></audio>
  <audio id="button-click-sound" src="sounds/button_click_soft.mp3" preload="auto"></audio>
  <audio id="scatter-trigger-sound" src="sounds/potion_bonus_trigger.mp3" preload="auto"></audio>
  <audio id="bonus-pick-sound" src="sounds/potion_item_pick.mp3" preload="auto"></audio>
  <audio id="bonus-grand-prize-sound" src="sounds/potion_grand_prize.mp3" preload="auto"></audio>
  -->

  <script>
    const config = {
        money: 100,
        reelCount: 5,
        rowCount: 5,
        symbolHeight: 70,
        spinDurationBase: 700,
        spinDurationVariance: 300,
        reelStopDelay: 80,
        autoSpinDelay: 1100,
        symbols: [
            { id: 'candle',      emoji: '🕯️', payouts: { '3': 2,  '4': 5,   '5': 10  } },
            { id: 'key',         emoji: '🔑', payouts: { '3': 3,  '4': 7,   '5': 15  } },
            { id: 'black_cat',   emoji: '🐈‍⬛', payouts: { '3': 4,  '4': 10,  '5': 20  } },
            { id: 'owl',         emoji: '🦉', payouts: { '3': 5,  '4': 12,  '5': 30  } },
            { id: 'scroll',      emoji: '📜', payouts: { '3': 8,  '4': 20,  '5': 50  } },
            { id: 'crystal_ball',emoji: '🔮', payouts: { '3': 15, '4': 40,  '5': 100 } },
            { id: 'wizard',      emoji: '🧙‍♂️', payouts: { '3': 20, '4': 60,  '5': 150 } },
            { id: 'potion_scatter', emoji: '🧪', scatter: true, payouts: { '3': 5, '4': 10, '5': 25} },
            { id: 'sparkle_wild',emoji: '✨', payouts: { '3': 30, '4': 100, '5': 300 }, wild: true },
        ],
        winningLines: [
            // MODIFIED: Added 'type' to distinguish line evaluation logic
            { id: 'arcane-path-1', name: 'Path 1 (Row 1)', type: 'horizontal', indices: [0, 1, 2, 3, 4] },
            { id: 'arcane-path-2', name: 'Path 2 (Row 2)', type: 'horizontal', indices: [5, 6, 7, 8, 9] },
            { id: 'arcane-path-3', name: 'Path 3 (Row 3)', type: 'horizontal', indices: [10, 11, 12, 13, 14] },
            { id: 'arcane-path-4', name: 'Path 4 (Row 4)', type: 'horizontal', indices: [15, 16, 17, 18, 19] },
            { id: 'arcane-path-5', name: 'Path 5 (Row 5)', type: 'horizontal', indices: [20, 21, 22, 23, 24] },
            { id: 'serpent-diagonal', name: 'Serpent Diag \\', type: 'fixedpath', indices: [0, 6, 12, 18, 24] },
            { id: 'dragon-diagonal', name: 'Dragon Diag /', type: 'fixedpath', indices: [20, 16, 12, 8, 4] },
        ],
        bigWinThresholdMultiplier: 25,
        potionBonus: {
            numItems: 12, numPicks: 5,
            specialIngredients: [
                { id: "dragon_tear", name: "Dragon's Tear", emoji: "💧" },
                { id: "moonpetal", name: "Moonpetal", emoji: "🌸" },
                { id: "phoenix_feather", name: "Phoenix Feather", emoji: "🔥" } ],
            grandPotionBonus: 200,
            itemPrizes: [
                { type: 'coin', value: 1 }, { type: 'coin', value: 2 }, { type: 'coin', value: 2 },
                { type: 'coin', value: 3 }, { type: 'coin', value: 5 }, { type: 'coin', value: 1 },
                { type: 'special', ingredientId: "dragon_tear" },
                { type: 'special', ingredientId: "moonpetal" },
                { type: 'special', ingredientId: "phoenix_feather" },
                { type: 'multiplier', value: 2 }, { type: 'multiplier', value: 3 },
                { type: 'coin', value: 4 }
            ]
        }
    };

    let money = config.money;
    let currentBet = 5;
    let autoMode = false;
    let spinning = false;
    let reels = [];
    let finalSymbols = [];
    let autoSpinTimeout = null;

    let bonusActive = false;
    let bonusPicksLeft = 0;
    let bonusCurrentWinnings = 0;
    let bonusWinningsMultiplier = 1;
    let collectedSpecialIngredients = new Set();

    const moneyDisplay = document.getElementById('money-display');
    const reelsContainer = document.getElementById('reels-container');
    const betInput = document.getElementById('bet');
    const maxBetButton = document.getElementById('maxBet');
    const spinButton = document.getElementById('spin');
    const autoButton = document.getElementById('auto');
    const resetButton = document.getElementById('reset');
    const messageDisplay = document.getElementById('message');
    const titleScreen = document.getElementById('title-screen');
    const appWrapper = document.getElementById('app-wrapper');
    // const gameTitleHeader = document.getElementById('game-title-header'); // REMOVED
    const gameLayoutContainer = document.getElementById('game-layout-container');
    const paytablePanelContent = document.getElementById('paytable-content');
    const bonusPotionScreen = document.getElementById('bonus-potion-screen');
    const bonusPicksLeftDisplay = document.getElementById('bonus-picks-left');
    const potionIngredientsCollectedDisplay = document.getElementById('potion-ingredients-collected');
    const potionItemsContainer = document.getElementById('potion-items-container');
    const bonusWinningsDisplay = document.getElementById('bonus-winnings-display');
    const collectBonusButton = document.getElementById('collect-bonus-button');

    const sounds = {
        spin: document.getElementById('spin-sound'), win: document.getElementById('win-sound'),
        bigWin: document.getElementById('big-win-sound'), reelStop: document.getElementById('reel-stop-sound'),
        click: document.getElementById('button-click-sound'), scatterTrigger: document.getElementById('scatter-trigger-sound'),
        bonusPick: document.getElementById('bonus-pick-sound'), grandPrize: document.getElementById('bonus-grand-prize-sound'),
    };

    function playSound(sound) {
        if (sound && typeof sound.play === 'function') {
            sound.currentTime = 0;
            sound.play().catch(e => console.warn("Sound play failed for " + sound.id + ":", e.message));
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function updateMoneyDisplay() {
      moneyDisplay.innerText = `Mana Crystals: $${money.toLocaleString()}`;
      const maxBetForNextSpin = money > 0 ? money : 1;
      betInput.max = maxBetForNextSpin;

      let betValInInput = parseInt(betInput.value);
      if (isNaN(betValInInput) || betValInInput < 1) betInput.value = 1;
      else if (betValInInput > maxBetForNextSpin && money > 0) betInput.value = maxBetForNextSpin;
      else if (money <= 0 && betValInInput > 1) betInput.value = 1;

       if (money <= 0 && !spinning && !bonusActive) {
            disableControls(true, false);
            displayMessage("Mana depleted! 'New Chapter' or a $1 cantrip for a last chance.", false, false);
            if (autoMode) stopAutoSpin();
       }
    }

    function disableControls(disable = true, disableReset = disable) {
        spinButton.disabled = disable;
        maxBetButton.disabled = disable;
        betInput.disabled = disable;

        if (!spinning && !bonusActive) {
            autoButton.disabled = disable;
        } else {
            autoButton.disabled = true;
            if (autoMode && !disable) {
                 autoButton.disabled = false;
            }
        }

        resetButton.disabled = disableReset;

        if (money <= 0 && parseInt(betInput.value) === 1 && !spinning && !bonusActive) {
            spinButton.disabled = false;
            betInput.disabled = true;
            maxBetButton.disabled = true;
        }
    }

    function displayMessage(msg, isWin = false, isBigWin = false) {
      messageDisplay.innerText = msg;
      messageDisplay.className = 'message';
      if (isBigWin) messageDisplay.classList.add('big-win');
      else if (isWin) messageDisplay.classList.add('win');
    }

    function createSymbolElement(symbolData) {
        const div = document.createElement('div');
        div.classList.add('symbol');
        div.dataset.symbolId = symbolData.id;
        div.textContent = symbolData.emoji;
        if (symbolData.wild) div.style.textShadow = '0 0 5px gold, 0 0 8px yellow, 0 0 2px #fff';
        if (symbolData.scatter) div.style.textShadow = '0 0 5px #4CAF50, 0 0 8px #81C784, 0 0 2px #fff';
        return div;
    }

    function buildReels() {
      reelsContainer.innerHTML = '';
      reels = [];
      for (let i = 0; i < config.reelCount; i++) {
        const reelElement = document.createElement('div');
        reelElement.classList.add('reel');
        const symbolsContainer = document.createElement('div');
        symbolsContainer.classList.add('symbols-container');

        const reelSymbolsData = [];
        const reelSymbolElements = [];

        for (let k = 0; k < 30; k++) {
            const shuffledPortion = [...config.symbols].sort(() => Math.random() - 0.5);
            shuffledPortion.forEach(symbolData => {
                 const symbolElement = createSymbolElement(symbolData);
                 symbolsContainer.appendChild(symbolElement);
                 reelSymbolsData.push(symbolData);
                 reelSymbolElements.push(symbolElement);
            });
        }
        reelElement.appendChild(symbolsContainer);
        reelsContainer.appendChild(reelElement);
        reels.push({
            element: reelElement,
            symbolsContainer: symbolsContainer,
            symbols: reelSymbolsData,
            symbolElements: reelSymbolElements,
            finalPosition: 0,
            failsafeTimeout: null
        });
      }
      reels.forEach(reel => {
         const initialOffset = -(Math.floor(Math.random() * reel.symbols.length) * config.symbolHeight);
         reel.symbolsContainer.style.transition = 'none';
         reel.symbolsContainer.style.transform = `translateY(${initialOffset}px)`;
         reel.finalPosition = initialOffset;
         void reel.symbolsContainer.offsetWidth;
         reel.symbolsContainer.style.transition = '';
      });
    }

    function clearReelHighlights() {
        document.querySelectorAll('.symbol.winning').forEach(el => el.classList.remove('winning'));
    }
    function clearPaytableHighlights() {
        document.querySelectorAll('.paytable-table td.paytable-win-flash').forEach(el => el.classList.remove('paytable-win-flash'));
    }

    function highlightWinsOnReels(winningLinesInfo) {
        winningLinesInfo.forEach(winInfo => {
            if (!winInfo.indices || winInfo.indices.length === 0) return;
            winInfo.indices.forEach(gridIndex => {
                 const reelIndex = gridIndex % config.reelCount;
                 const visibleRowIndex = Math.floor(gridIndex / config.reelCount);
                 const reel = reels[reelIndex];
                 if (!reel || !reel.symbolElements || reel.symbolElements.length === 0) {
                     console.warn("Cannot highlight: Reel or symbolElements missing for reelIndex", reelIndex);
                     return;
                 }
                 const topVisibleSymbolIndex = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                 const targetSymbolIndexInElementArray = (topVisibleSymbolIndex + visibleRowIndex + reel.symbolElements.length) % reel.symbolElements.length;

                 const symbolElement = reel.symbolElements[targetSymbolIndexInElementArray];
                 if (symbolElement) {
                    symbolElement.classList.add('winning');
                 } else {
                    console.warn("Cannot highlight: Symbol element not found at calculated index", targetSymbolIndexInElementArray, "for grid index", gridIndex);
                 }
            });
        });
    }

    function highlightPaytableEntry(symbolId, winCount) {
        if (!symbolId) return;
        const rowSelector = `.paytable-table tr[data-symbol-id="${symbolId}"]`;
        const row = paytablePanelContent.querySelector(rowSelector);
        if (row) {
            const cellSelector = `td[data-payout-count="${winCount.toString()}"]`;
            const cell = row.querySelector(cellSelector);
            if (cell) {
                cell.classList.add('paytable-win-flash');
            }
        }
    }

    function startSpin() {
        if (spinning || bonusActive) return;

        let betForThisSpin = parseInt(betInput.value);
        if (isNaN(betForThisSpin) || betForThisSpin < 1) betForThisSpin = 1;

        const maxAffordableBet = money > 0 ? money : 1;
        if (betForThisSpin > maxAffordableBet && money > 0) betForThisSpin = maxAffordableBet;
        else if (money <= 0 && betForThisSpin > 1) betForThisSpin = 1;

        betInput.value = betForThisSpin;
        currentBet = betForThisSpin;

        const isFreeSpin = (money <= 0 && currentBet === 1);
        if (!isFreeSpin && currentBet > money) {
            displayMessage("Not enough Mana Crystals for this spell!");
            if (autoMode) stopAutoSpin();
            disableControls(false, money <= 0 && parseInt(betInput.value) > 1);
            return;
        }

        clearTimeout(autoSpinTimeout);
        clearReelHighlights();
        clearPaytableHighlights();
        playSound(sounds.click);
        spinning = true;

        if (isFreeSpin) {
            displayMessage("A final incantation on the house!");
        } else {
            money -= currentBet;
            displayMessage("The runes are aligning...");
        }

        updateMoneyDisplay();
        disableControls(true);
        spinButton.innerText = "Casting...";
        playSound(sounds.spin);

        let reelsStoppedCount = 0;
        reels.forEach((reel, index) => {
            if (reel.failsafeTimeout) clearTimeout(reel.failsafeTimeout);

            const symbolsContainer = reel.symbolsContainer;
            const reelElement = reel.element;
            reelElement.classList.remove('stopping');
            reelElement.classList.add('spinning');

            const randomSymbolIndexOnStrip = Math.floor(Math.random() * reel.symbols.length);
            reel.finalPosition = -(randomSymbolIndexOnStrip * config.symbolHeight);

            const currentY = parseFloat(symbolsContainer.style.transform.replace(/[^0-9.-]/g, '')) || 0;
            const fullRotations = Math.floor(Math.random() * 2) + 2;
            const spinDistance = (reel.symbols.length * config.symbolHeight) * fullRotations;

            symbolsContainer.style.transform = `translateY(${currentY - spinDistance}px)`;

            const totalSpinDuration = config.spinDurationBase + (index * config.reelStopDelay) + (Math.random() * config.spinDurationVariance);
            const stopAnimationDuration = 700;

            setTimeout(() => {
                reelElement.classList.remove('spinning');
                reelElement.classList.add('stopping');
                symbolsContainer.style.transform = `translateY(${reel.finalPosition}px)`;
                playSound(sounds.reelStop);

                const transitionEndHandler = (event) => {
                    if (event.target === symbolsContainer && event.propertyName === 'transform') {
                        symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                        clearTimeout(reel.failsafeTimeout);
                        reelElement.classList.remove('stopping');
                        reelsStoppedCount++;
                        if (reelsStoppedCount === config.reelCount) {
                            setTimeout(evaluateResult, 100);
                        }
                    }
                };
                symbolsContainer.addEventListener('transitionend', transitionEndHandler);

                reel.failsafeTimeout = setTimeout(() => {
                     if (!reelElement.classList.contains('stopping') && !spinning) return;
                     console.warn(`Failsafe triggered for reel ${index}`);
                     symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                     reelElement.classList.remove('stopping');
                     reelsStoppedCount++;
                     if (reelsStoppedCount === config.reelCount) {
                        setTimeout(evaluateResult, 100);
                     }
                }, stopAnimationDuration + 200);
            }, totalSpinDuration - stopAnimationDuration);
        });
    }

    function evaluateResult() {
        let totalWinningsFromSpin = 0;
        let combinedWinningLinesInfo = [];
        let isBigWinOverall = false;
        const scatterSymbolData = config.symbols.find(s => s.scatter);
        let scatterBonusTriggered = false;
        let scatterBonusCountForMessage = 0;

        finalSymbols = [];
         for (let r = 0; r < config.rowCount; r++) {
            for (let c = 0; c < config.reelCount; c++) {
                const reel = reels[c];
                if (!reel || !reel.symbols) {
                    console.error(`Reel ${c} or its symbols are undefined during evaluation.`);
                    finalSymbols.push({id: "error_symbol", emoji: "❓"});
                    continue;
                }
                const topVisibleSymbolIndexOnStrip = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                const symbolIndexInDataArray = (topVisibleSymbolIndexOnStrip + r + reel.symbols.length) % reel.symbols.length;

                if (reel.symbols[symbolIndexInDataArray]) {
                    finalSymbols.push(reel.symbols[symbolIndexInDataArray]);
                } else {
                    console.warn(`Undefined symbol data at reel ${c}, visual row ${r}, calculated strip index ${symbolIndexInDataArray}`);
                    finalSymbols.push({id: "error_symbol", emoji: "❓"});
                }
            }
        }

        config.winningLines.forEach(line => {
            let bestWinOnThisLine = { amount: 0, count: 0, symbolId: null, indices: [], multiplier: 0, lineName: line.name || line.id };

            config.symbols.forEach(symbolToCheck => {
                if (!symbolToCheck.payouts) return; // All symbols with payouts are checked

                const checkSymbolId = symbolToCheck.id;
                const isWildTypeBeingChecked = symbolToCheck.wild;

                for (let len = config.reelCount; len >= 3; len--) {
                    let startPositions = [0]; // Default for fixed-path lines (like diagonals)

                    // MODIFIED: "Any Way Pays" for horizontal lines
                    if (line.type === 'horizontal') {
                        startPositions = [];
                        for (let s = 0; s <= config.reelCount - len; s++) {
                            startPositions.push(s);
                        }
                    }

                    for (const start of startPositions) {
                        const currentSegmentIndicesOnLine = line.indices.slice(start, start + len);
                        // Ensure the segment is valid for the line (especially for horizontal 'any way')
                        if (currentSegmentIndicesOnLine.length < len) continue;

                        const groupSymbolsData = currentSegmentIndicesOnLine.map(globalIndex => finalSymbols[globalIndex]).filter(s => s);
                        if (groupSymbolsData.length < len) continue;

                        if (checkAdjacentGroup(groupSymbolsData, checkSymbolId, len, isWildTypeBeingChecked)) {
                            const payoutKey = len.toString();
                            if (symbolToCheck.payouts[payoutKey]) {
                                const lineMultiplier = symbolToCheck.payouts[payoutKey];
                                const amount = currentBet * lineMultiplier;

                                if (amount > bestWinOnThisLine.amount) {
                                    bestWinOnThisLine = {
                                        amount, count: len, symbolId: checkSymbolId,
                                        indices: currentSegmentIndicesOnLine, // Store the actual winning indices
                                        multiplier: lineMultiplier, lineName: line.name || line.id
                                    };
                                }
                            }
                        }
                    }
                    // If, for the current symbolToCheck, we've found a win of this 'len',
                    // we don't need to check for shorter wins OF THE SAME SYMBOL on this line.
                    if (bestWinOnThisLine.symbolId === checkSymbolId && bestWinOnThisLine.count === len) {
                         break; // From 'len' loop for this symbol
                    }
                }
            });

            if (bestWinOnThisLine.amount > 0) {
                // Check if this exact win (symbol, count, specific indices) is already recorded to prevent duplicates from overlapping logic
                // This is a basic check; more complex scenarios might need more robust duplicate prevention.
                const isDuplicateWin = combinedWinningLinesInfo.some(existingWin =>
                    existingWin.symbolId === bestWinOnThisLine.symbolId &&
                    existingWin.count === bestWinOnThisLine.count &&
                    existingWin.indices.every((val, index) => val === bestWinOnThisLine.indices[index])
                );

                if (!isDuplicateWin) {
                    totalWinningsFromSpin += bestWinOnThisLine.amount;
                    combinedWinningLinesInfo.push(bestWinOnThisLine);
                    if (bestWinOnThisLine.multiplier >= config.bigWinThresholdMultiplier && !isBigWinOverall) {
                        isBigWinOverall = true;
                    }
                    if (scatterSymbolData && bestWinOnThisLine.symbolId === scatterSymbolData.id && bestWinOnThisLine.count >= 3) {
                        scatterBonusTriggered = true;
                        scatterBonusCountForMessage = Math.max(scatterBonusCountForMessage, bestWinOnThisLine.count);
                    }
                }
            }
        });

        spinning = false;

        if (scatterBonusTriggered && scatterSymbolData) {
            playSound(sounds.scatterTrigger);
            if (totalWinningsFromSpin > 0) { // Add line wins (including the scatter line win) before bonus
                money += totalWinningsFromSpin;
            }
            updateMoneyDisplay();
            displayMessage(`Potions Found! ${scatterBonusCountForMessage}x ${scatterSymbolData.emoji} on a line triggers the Bonus!`, true, false);

            if(combinedWinningLinesInfo.length > 0) {
                 highlightWinsOnReels(combinedWinningLinesInfo.filter(info => info.indices && info.indices.length > 0));
                 combinedWinningLinesInfo.forEach(winInfo => {
                    if (winInfo.symbolId) highlightPaytableEntry(winInfo.symbolId, winInfo.count);
                });
            }
            setTimeout(triggerPotionBonus, 2000);
            return;
        }

        processEndOfSpin(totalWinningsFromSpin, combinedWinningLinesInfo, isBigWinOverall);
    }

    function processEndOfSpin(currentSpinWinnings, linesInfo, isBigWin) {
        const isFreeSpinLosing = (money <= 0 && currentBet === 1 && currentSpinWinnings <= 0 && (money + currentBet) === 1);

        if (currentSpinWinnings > 0) {
            money += currentSpinWinnings;
            let winMessageText = "";
            const uniqueLineWins = linesInfo.filter(info => info.amount > 0);

            if (uniqueLineWins.length > 0) {
                winMessageText = isBigWin ? `!!! ARCANE MASTER JACKPOT !!!\n` : "Enchanting Wins!\n";
                uniqueLineWins.forEach(info => {
                    const displayName = info.symbolId ? info.symbolId.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : "Symbol";
                    winMessageText += `${info.count}x ${displayName} (${info.lineName}) = $${info.amount.toLocaleString()}\n`;
                });
                winMessageText += `Total This Spell: $${currentSpinWinnings.toLocaleString()}`;
            }

            if (winMessageText) {
                displayMessage(winMessageText, true, isBigWin);
                if (isBigWin) playSound(sounds.bigWin);
                else playSound(sounds.win);
            }

            if(linesInfo.length > 0) {
                highlightWinsOnReels(linesInfo.filter(info => info.indices && info.indices.length > 0));
                linesInfo.forEach(winInfo => {
                    if (winInfo.symbolId) highlightPaytableEntry(winInfo.symbolId, winInfo.count);
                });
            }
        } else if (!bonusActive && !isFreeSpinLosing) {
             displayMessage("The spell fizzled... Try another incantation!");
        }

        updateMoneyDisplay();
        if (!bonusActive) {
            disableControls(false, money <= 0 && parseInt(betInput.value) > 1);
        }
        spinButton.innerText = "Cast!";

        if (autoMode && !bonusActive) {
            let nextBetForAuto = parseInt(betInput.value);
            if(isNaN(nextBetForAuto) || nextBetForAuto < 1) nextBetForAuto = 1;

            const canAffordNextAutoSpin = (money >= nextBetForAuto && money > 0) || (money <= 0 && nextBetForAuto === 1);
            if (canAffordNextAutoSpin) {
                autoSpinTimeout = setTimeout(startSpin, config.autoSpinDelay);
            } else {
                stopAutoSpin();
                displayMessage(money <= 0 ? "Mana depleted! Auto-Enchant stopped." : "Not enough Mana for Auto-Enchant. Stopped.", false, money <= 0);
            }
         }
    }

    function checkAdjacentGroup(groupSymbolsData, checkSymbolId, requiredCount, isWildTypeBeingChecked) {
        if (groupSymbolsData.length !== requiredCount) return false;
        if (groupSymbolsData.some(s => !s)) return false;

        for (let i = 0; i < requiredCount; i++) {
            const symbol = groupSymbolsData[i];
            if (isWildTypeBeingChecked) {
                if (!symbol.wild) return false;
            } else {
                if (symbol.id !== checkSymbolId && !symbol.wild) return false;
            }
        }
        return true;
    }

    function stopAutoSpin() {
        autoMode = false;
        clearTimeout(autoSpinTimeout);
        autoButton.innerText = "Auto-Enchant";
        autoButton.style.background = '';
        if (!spinning && !bonusActive) {
            disableControls(false, money <= 0 && parseInt(betInput.value) > 1);
        }
    }

    function generateSidePayTable() {
        paytablePanelContent.innerHTML = '';
        const table = document.createElement('table');
        table.classList.add('paytable-table');
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const headers = ['Icon', 'Item/Spell', '3x', '4x', '5x'];
        headers.forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            headerRow.appendChild(th);
        });

        const tbody = table.createTBody();
        config.symbols.forEach(symbolData => {
            if (symbolData.payouts) {
                const row = tbody.insertRow();
                row.dataset.symbolId = symbolData.id;

                const emojiCell = row.insertCell();
                emojiCell.textContent = symbolData.emoji;
                emojiCell.classList.add('paytable-symbol-emoji');
                if (symbolData.wild) emojiCell.style.textShadow = '0 0 5px gold';
                if (symbolData.scatter) emojiCell.style.textShadow = '0 0 5px limegreen';

                const nameCell = row.insertCell();
                let symbolNameText = symbolData.id.replace(/_/g, ' ');
                if (symbolData.wild) symbolNameText += " (Wild)";
                if (symbolData.scatter) symbolNameText += " (Scatter)";
                nameCell.textContent = symbolNameText;
                nameCell.classList.add('paytable-symbol-name');

                const p3 = symbolData.payouts['3'] || 0, p4 = symbolData.payouts['4'] || 0, p5 = symbolData.payouts['5'] || 0;

                const p3Cell = row.insertCell();
                p3Cell.textContent = p3 > 0 ? `${p3}x` : '-';
                if (p3 > 0) p3Cell.dataset.payoutCount = "3";

                const p4Cell = row.insertCell();
                p4Cell.textContent = p4 > 0 ? `${p4}x` : '-';
                if (p4 > 0) p4Cell.dataset.payoutCount = "4";

                const p5Cell = row.insertCell();
                p5Cell.textContent = p5 > 0 ? `${p5}x` : '-';
                if (p5 > 0) p5Cell.dataset.payoutCount = "5";
            }
        });
        paytablePanelContent.appendChild(table);

        const wildSymbol = config.symbols.find(s => s.wild);
        const scatterSymbol = config.symbols.find(s => s.scatter);
        const wildInfoDiv = document.createElement('div');
        wildInfoDiv.classList.add('paytable-wild-info');
        let infoText = "";
        if (wildSymbol) infoText += `<b>${wildSymbol.emoji} ${wildSymbol.id.replace(/_/g, ' ').toUpperCase()}</b> is WILD, substitutes for all symbols.<br>`;
        if (scatterSymbol) {
             infoText += `<b>${scatterSymbol.emoji} ${scatterSymbol.id.replace(/_/g, ' ').toUpperCase()}</b> (Scatter) forming a line of 3+ triggers Potion Bonus and pays according to the table.`;
        }
        wildInfoDiv.innerHTML = infoText || "Ancient texts hold many secrets...";
        paytablePanelContent.appendChild(wildInfoDiv);
    }

    function requestFullScreenGame() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(err => console.warn("Fullscreen request failed:", err.message));
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen().catch(err => console.warn("Fullscreen request failed (Moz):", err.message));
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen().catch(err => console.warn("Fullscreen request failed (Webkit):", err.message));
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen().catch(err => console.warn("Fullscreen request failed (MS):", err.message));
        }
    }

    function triggerPotionBonus() {
        bonusActive = true;
        disableControls(true);

        gameLayoutContainer.style.transition = 'opacity 0.5s ease-out';
        gameLayoutContainer.style.opacity = '0.2';

        bonusPotionScreen.style.display = 'flex';

        bonusPicksLeft = config.potionBonus.numPicks;
        bonusCurrentWinnings = 0;
        bonusWinningsMultiplier = 1;
        collectedSpecialIngredients.clear();

        updateBonusUI();
        populatePotionItems();
        collectBonusButton.style.display = 'none';
    }

    function populatePotionItems() {
        potionItemsContainer.innerHTML = '';
        let itemsToPlace = [...config.potionBonus.itemPrizes];

        if (config.potionBonus.numItems > itemsToPlace.length) {
            for (let i = itemsToPlace.length; i < config.potionBonus.numItems; i++) {
                itemsToPlace.push({ type: 'coin', value: 1 });
            }
        } else if (config.potionBonus.numItems < itemsToPlace.length) {
            itemsToPlace = itemsToPlace.slice(0, config.potionBonus.numItems);
        }

        shuffleArray(itemsToPlace);

        itemsToPlace.forEach(outcomeData => {
            const item = document.createElement('div');
            item.classList.add('potion-item');
            item.textContent = '❓';
            item.dataset.outcome = JSON.stringify(outcomeData);
            item.addEventListener('click', handlePotionItemClick, { once: true });
            potionItemsContainer.appendChild(item);
        });
    }

    function handlePotionItemClick(event) {
        if (bonusPicksLeft <= 0 || !bonusActive) return;

        const itemElement = event.currentTarget;
        itemElement.classList.add('picked');

        playSound(sounds.bonusPick);
        const outcome = JSON.parse(itemElement.dataset.outcome);
        let revealedContent = "";
        let feedbackMessage = "";

        if (outcome.type === 'coin') {
            const prize = outcome.value * currentBet;
            bonusCurrentWinnings += prize;
            revealedContent = `$${prize.toLocaleString()}`;
            feedbackMessage = `You found $${prize.toLocaleString()}!`;
        } else if (outcome.type === 'special') {
            const specialIngredient = config.potionBonus.specialIngredients.find(si => si.id === outcome.ingredientId);
            if (specialIngredient) {
                 revealedContent = specialIngredient.emoji;
                if (!collectedSpecialIngredients.has(specialIngredient.id)) {
                    collectedSpecialIngredients.add(specialIngredient.id);
                    feedbackMessage = `Collected: ${specialIngredient.name}! (${specialIngredient.emoji})`;
                } else {
                    const fallbackPrize = currentBet;
                    bonusCurrentWinnings += fallbackPrize;
                    feedbackMessage = `Found ${specialIngredient.name} again! Consolation: $${fallbackPrize.toLocaleString()}.`;
                }
            } else {
                 revealedContent = '❓'; feedbackMessage = "A mysterious essence!";
            }
        } else if (outcome.type === 'multiplier') {
            bonusWinningsMultiplier = Math.max(bonusWinningsMultiplier, outcome.value);
            revealedContent = `${outcome.value}X`;
            feedbackMessage = `Potion Potency x${outcome.value}!`;
        } else {
            revealedContent = "❓";
            feedbackMessage = "A curious find!";
        }

        itemElement.textContent = revealedContent;
        bonusPicksLeft--;
        updateBonusUI();
        if(feedbackMessage) displayMessage(feedbackMessage, true, false);

        if (bonusPicksLeft <= 0 || collectedSpecialIngredients.size === config.potionBonus.specialIngredients.length) {
            potionItemsContainer.querySelectorAll('.potion-item:not(.picked)').forEach(item => {
                item.style.cursor = 'default';
            });
            setTimeout(finishPotionBonus, 1500);
        }
    }

    function updateBonusUI() {
        bonusPicksLeftDisplay.textContent = bonusPicksLeft;
        bonusWinningsDisplay.textContent = `Bonus Winnings: $${(bonusCurrentWinnings * bonusWinningsMultiplier).toLocaleString()}`;

        let ingredientsHTML = "Collected: ";
        if (collectedSpecialIngredients.size > 0) {
            config.potionBonus.specialIngredients.forEach(si => {
                if(collectedSpecialIngredients.has(si.id)) {
                    ingredientsHTML += `<span>${si.emoji} ${si.name}</span> `;
                }
            });
        } else {
            ingredientsHTML += "None yet";
        }
        potionIngredientsCollectedDisplay.innerHTML = ingredientsHTML;
    }

    function finishPotionBonus() {
        let finalBonusAmount = bonusCurrentWinnings * bonusWinningsMultiplier;
        let grandPotionAchieved = collectedSpecialIngredients.size === config.potionBonus.specialIngredients.length;

        if (grandPotionAchieved) {
            const grandPrize = config.potionBonus.grandPotionBonus * currentBet;
            finalBonusAmount += grandPrize;
            playSound(sounds.grandPrize);
            displayMessage(`GRAND POTION BREWED! +$${grandPrize.toLocaleString()}! Total Bonus: $${finalBonusAmount.toLocaleString()}`, true, true);
        } else {
            displayMessage(`Potion Complete! You won $${finalBonusAmount.toLocaleString()} in the bonus!`, true, finalBonusAmount > currentBet * 10);
        }

        money += finalBonusAmount;
        updateMoneyDisplay();

        collectBonusButton.style.display = 'inline-block';

        potionItemsContainer.querySelectorAll('.potion-item:not(.picked)').forEach(item => {
            try {
                const outcome = JSON.parse(item.dataset.outcome);
                if (outcome.type === 'coin') item.textContent = `$${(outcome.value * currentBet)}`;
                else if (outcome.type === 'special') item.textContent = config.potionBonus.specialIngredients.find(si => si.id === outcome.ingredientId)?.emoji || '❓';
                else if (outcome.type === 'multiplier') item.textContent = `${outcome.value}X`;
                else item.textContent = '❔';
            } catch (e) {
                item.textContent = '❔';
            }
            item.classList.add('picked');
        });
    }

    collectBonusButton.addEventListener('click', () => {
        bonusActive = false;
        bonusPotionScreen.style.display = 'none';

        gameLayoutContainer.style.opacity = '1';
        gameLayoutContainer.style.transition = '';

        collectBonusButton.style.display = 'none';

        disableControls(false, money <= 0 && parseInt(betInput.value) > 1);
        spinButton.innerText = "Cast!";
        displayMessage("The spirits are pleased! Cast another spell.", false, false);

        if (autoMode) {
            let nextBetForAuto = parseInt(betInput.value);
            if(isNaN(nextBetForAuto) || nextBetForAuto < 1) nextBetForAuto = 1;

            const canAffordNextAutoSpin = (money >= nextBetForAuto && money > 0) || (money <= 0 && nextBetForAuto === 1);
            if (canAffordNextAutoSpin) {
                autoSpinTimeout = setTimeout(startSpin, config.autoSpinDelay);
            } else {
                stopAutoSpin();
                displayMessage(money <= 0 ? "Mana depleted! Auto-Enchant stopped." : "Not enough Mana for Auto-Enchant. Stopped.", false, money <= 0);
            }
         }
    });

    const startButtonElement = document.getElementById('start-button');
    startButtonElement.addEventListener('click', () => {
        playSound(sounds.click);
        requestFullScreenGame();

        titleScreen.style.display = 'none';
        appWrapper.style.display = 'flex';
        gameLayoutContainer.style.display = 'flex';
        // gameTitleHeader.style.display = 'block'; // REMOVED
        initializeGame();
    });

    document.getElementById('spin').addEventListener('click', () => {
        if (!spinning && !bonusActive) startSpin();
    });

    document.getElementById('maxBet').addEventListener('click', () => {
        playSound(sounds.click);
        if (!spinning && !bonusActive) {
            const maxBetValue = money > 0 ? money : 1;
            betInput.value = maxBetValue;
            updateMoneyDisplay();
        }
    });

    document.getElementById('auto').addEventListener('click', () => {
        playSound(sounds.click);
        if (bonusActive) return;

        if (autoMode) {
            stopAutoSpin();
            if (!spinning) displayMessage("Auto-Enchant OFF.");
        } else {
            let betForAuto = parseInt(betInput.value);
            if (isNaN(betForAuto) || betForAuto < 1) betForAuto = 1;

            const maxAffordableAuto = money > 0 ? money : 1;
            if (betForAuto > maxAffordableAuto && money > 0) betForAuto = maxAffordableAuto;
            else if (money <= 0 && betForAuto > 1) betForAuto = 1;
            betInput.value = betForAuto;

            const canStartAuto = !spinning && ((money >= betForAuto && money > 0) || (money <= 0 && betForAuto === 1));

            if (canStartAuto) {
                autoMode = true;
                autoButton.innerText = "Stop Enchant";
                autoButton.style.background = 'linear-gradient(to bottom, #ef5350, #c62828)';
                displayMessage("Auto-Enchant ON!");
                startSpin();
            } else if (spinning) {
                 autoMode = true;
                 autoButton.innerText = "Stop Enchant";
                 autoButton.style.background = 'linear-gradient(to bottom, #ef5350, #c62828)';
                 displayMessage("Auto-Enchant will start after this spell.");
            }
            else {
                displayMessage(money <= 0 ? "Mana depleted! Cannot start Auto-Enchant." : "Not enough Mana for this bet in Auto-Enchant!");
            }
        }
    });

    document.getElementById('reset').addEventListener('click', () => {
        playSound(sounds.click);
        let confirmMessage = "Close spellbook and start a new chapter with 100 Mana Crystals? All current progress will be lost.";
        if (bonusActive || spinning) {
            confirmMessage = "A spell is in progress or a bonus is active! Are you sure you want to start a New Chapter? This will reset your progress.";
        }

        if (!confirm(confirmMessage)) {
            return;
        }

        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
            if (document.exitFullscreen) document.exitFullscreen();
            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
            else if (document.msExitFullscreen) document.msExitFullscreen();
        }
        location.reload();
    });

    betInput.addEventListener('blur', () => {
        if (bonusActive || spinning) return;

        let n = parseInt(betInput.value);
        const maxBetForNext = money > 0 ? money : 1;

        if (isNaN(n) || n < 1) n = 1;
        if (n > maxBetForNext && money > 0) n = maxBetForNext;
        else if (money <= 0 && n > 1) n = 1;

        betInput.value = n;
        updateMoneyDisplay();
        disableControls(false, money <= 0 && parseInt(betInput.value) > 1);
    });

    function initializeGame() {
        money = config.money;
        let initialBetVal = parseInt(betInput.value);
        if (isNaN(initialBetVal) || initialBetVal < 1) initialBetVal = 1;

        const maxInitialBet = money > 0 ? money : 1;
        if (initialBetVal > maxInitialBet && money > 0) initialBetVal = maxInitialBet;
        else if (money <=0 && initialBetVal > 1) initialBetVal = 1;

        betInput.value = initialBetVal;
        currentBet = initialBetVal;

        autoMode = false;
        spinning = false;
        bonusActive = false;
        clearTimeout(autoSpinTimeout);

        displayMessage("Choose your spell (bet) and cast the reels!");
        buildReels();
        generateSidePayTable();
        updateMoneyDisplay();
        clearReelHighlights();
        clearPaytableHighlights();
        disableControls(false, money <= 0 && currentBet > 1);

        autoButton.innerText = "Auto-Enchant";
        autoButton.style.background = '';

        Object.values(sounds).forEach(sound => {
            if(sound && typeof sound.load === 'function') {
                try { sound.load(); } catch(e) { console.warn("Error loading sound:", sound.id, e); }
            }
        });
    }
  </script>
</body>
</html>