<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Blossom Hearts 4x4 Slots!</title>
  <style>
    :root {
      /* Grid Dimensions */
      --num-reels: 4; /* <<< CHANGED */
      --num-rows: 4;  /* <<< CHANGED */
      --reel-width: 85px; /* Slightly larger for 4 reels */
      --reel-height: 85px;
      --reel-gap: 10px; /* Slightly wider gap */
      --symbol-size: 60px; /* Adjusted */

      /* Layout */
      --lever-width: 35px; /* Slightly wider lever */
      --lever-offset: 65px;
      --machine-padding: 30px; /* More padding */
      --reels-padding: 20px;
      /* Recalculated for 4x4 */
      --machine-width: calc(var(--num-reels) * var(--reel-width) + (var(--num-reels) - 1) * var(--reel-gap) + 2 * var(--machine-padding));
      --reels-container-height: calc(var(--num-rows) * var(--reel-height) + 2 * var(--reels-padding));
      --reels-container-width: calc(var(--num-reels) * var(--reel-width) + (var(--num-reels) - 1) * var(--reel-gap) + 2 * var(--reels-padding));


      /* Blossom Hearts Colors - NEW PALETTE */
      --color-bg-start: #fdecef; /* Light Pink */
      --color-bg-end: #f8c5d8; /* Deeper Pink */
      --color-machine-bg1: #ffffff; /* White */
      --color-machine-bg2: #ffe4f0; /* Very Light Pink */
      --color-border: #e83e8c; /* Hot Pink */
      --color-accent: #32cd32; /* Lime Green */
      --color-title-text: #d63384; /* Strong Pink */
      --color-title-bg1: #ffb3de; /* Medium Pink */
      --color-title-bg2: #f899ce; /* Darker Medium Pink */
      --color-money: #b30059; /* Dark Pink/Magenta */
      --color-reels-bg: #fff0f5; /* Lavender Blush */
      --color-reel-bg: #ffffff;
      --color-button-bg1: #f8a4c6; /* Light Pink */
      --color-button-bg2: #e87cac; /* Medium Pink */
      --color-button-border: #d63384;
      --color-button-hover-bg1: #faafd4;
      --color-button-hover-bg2: #eb6ca0;
      --color-button-hover-border: #b30059;
      --color-spin-bg1: #4caf50; /* Green */
      --color-spin-bg2: #388e3c; /* Darker Green */
      --color-spin-border: var(--color-accent);
      --color-lever-handle: linear-gradient(to right, #d2b48c, #a0522d); /* Tan/Brown Wood */
      --color-lever-ball: radial-gradient(circle at 12px 12px, #ff69b4, #c71585); /* Hot Pink/Medium Violet Red */
      --color-win-line: rgba(255, 105, 180, 0.8); /* Hot Pink Transparent */
      --color-win-shadow: rgba(255, 20, 147, 0.9); /* Deep Pink Shadow */
      --color-message-text: #601040; /* Dark Purple/Pink */
      --color-message-win: #28a745; /* Success Green */
      --color-message-bigwin: #fd7e14; /* Orange */
      --color-title-screen-text: #401030; /* Dark Purple/Pink */
    }

    body {
      margin: 0;
      /* Softer, rounded font */
      font-family: 'Pacifico', cursive; /* Include link or fallback */
      background: radial-gradient(circle, var(--color-bg-end), var(--color-bg-start));
      color: #333; /* Darker default text */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    /* Include Pacifico font */
    @import url('https://fonts.googleapis.com/css2?family=Pacifico&display=swap');
    /* Fallback font */
    body, button, input {
        font-family: 'Pacifico', cursive, 'Arial', sans-serif;
    }


    #game-container {
      position: relative;
      padding-right: calc(var(--lever-width) + var(--lever-offset) - 20px);
    }

    #slot-machine {
      background: linear-gradient(145deg, var(--color-machine-bg1), var(--color-machine-bg2));
      border: 12px solid var(--color-border); /* Thicker border */
      border-radius: 30px; /* More rounded */
      padding: var(--machine-padding);
      box-shadow: 0 0 30px rgba(232, 62, 140, 0.5), inset 0 0 15px rgba(0, 0, 0, 0.2); /* Pink glow */
      text-align: center;
      width: var(--machine-width);
      position: relative;
      z-index: 1;
    }

    #title {
      font-size: 36px; /* Adjusted */
      font-weight: normal; /* Pacifico is decorative */
      color: var(--color-title-text);
      text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.8); /* Lighter shadow */
      background: linear-gradient(to bottom, var(--color-title-bg1), var(--color-title-bg2));
      padding: 20px; /* More padding */
      margin: calc(-1 * var(--machine-padding)) calc(-1 * var(--machine-padding)) 25px calc(-1 * var(--machine-padding));
      border-radius: 18px 18px 0 0; /* Match outer radius */
      border-bottom: 6px solid var(--color-border);
      line-height: 1.2;
    }
     #title span { /* Subtitle styling */
        display: block;
        font-size: 18px;
        margin-top: 5px;
        color: #dc3545; /* Reddish */
        font-family: Arial, sans-serif; /* More readable subtitle font */
        font-weight: bold;
        text-shadow: none;
     }

    #money-display {
      font-size: 28px; /* Adjusted */
      margin: 20px 0;
      color: var(--color-money);
      text-shadow: 1px 1px 3px rgba(179, 0, 89, 0.3);
      background-color: rgba(255,255,255,0.8); /* Lighter background */
      padding: 10px 18px;
      border-radius: 10px;
      display: inline-block;
      border: 2px solid var(--color-money);
      font-weight: bold; /* Make money stand out */
      font-family: Arial, sans-serif; /* Use readable font */
    }

    #reels-container {
      display: grid;
      grid-template-columns: repeat(var(--num-reels), var(--reel-width)); /* Uses 4 */
      grid-gap: var(--reel-gap);
      justify-content: center;
      margin-bottom: 25px;
      background: var(--color-reels-bg);
      padding: var(--reels-padding);
      border-radius: 15px; /* More rounded */
      border: 4px inset rgba(0, 0, 0, 0.1); /* Softer inset */
      box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
      overflow: hidden;
      height: var(--reels-container-height); /* Uses 4 */
      /* width: var(--reels-container-width); */ /* Auto width from grid */
      position: relative;
    }

    .reel {
      width: var(--reel-width);
      height: calc(var(--num-rows) * var(--reel-height)); /* Uses 4 */
      overflow: hidden;
      background: var(--color-reel-bg);
      border-radius: 8px; /* Rounded reels */
      position: relative;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.15);
    }

    .symbols-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        transition: transform 0.1s linear; /* Spinning */
    }

    .reel.stopping .symbols-container {
      transition: transform 1s cubic-bezier(0.25, 1, 0.5, 1); /* Stopping */
    }

    .symbol {
      width: var(--reel-width);
      height: var(--reel-height);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--symbol-size);
      position: relative;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
      line-height: 1;
      color: #333; /* Symbols have color via emoji */
      user-select: none;
      /* Removed filter glow */
    }

    /* --- Win Animation (Subtler) --- */
    @keyframes winFlash {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.15); filter: brightness(1.2) drop-shadow(0 0 8px var(--color-accent)); } /* Greenish flash */
    }

    .symbol.winning {
      animation: winFlash 0.6s ease-in-out infinite;
      z-index: 10;
    }

    /* --- Win Lines (Pink) --- */
    .win-line {
        position: absolute;
        background-color: var(--color-win-line);
        box-shadow: 0 0 8px 3px var(--color-win-shadow); /* Adjusted shadow */
        z-index: 5;
        display: none;
        pointer-events: none;
        border-radius: 3px;
    }
    /* Adjusted for 4x4 */
    .win-line.horizontal {
        height: 6px;
        width: calc(var(--num-reels) * var(--reel-width) + (var(--num-reels) - 1) * var(--reel-gap)); /* Full width (4 reels) */
        left: var(--reels-padding);
    }
    .win-line.vertical {
        width: 6px;
        height: calc(var(--num-rows) * var(--reel-height)); /* Full height (4 rows) */
        top: var(--reels-padding);
    }
    .win-line.diagonal {
        width: 6px; /* Thickness */
    }


    #controls {
      margin: 25px 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px; /* Increased gap */
    }

    #controls label {
        font-family: Arial, sans-serif; /* Readable font for label */
        font-weight: bold;
        color: var(--color-title-text);
        font-size: 18px;
        align-self: center;
        margin-right: -5px;
        text-transform: uppercase;
    }

    #controls input, #controls button {
      font-size: 16px; /* Slightly smaller */
      padding: 10px 15px;
      margin: 5px;
      border-radius: 20px; /* Very rounded buttons */
      border: 2px solid var(--color-button-border);
      background: linear-gradient(to bottom, var(--color-button-bg1), var(--color-button-bg2));
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Arial', sans-serif; /* Readable font for controls */
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0,0,0,0.15);
      text-transform: uppercase; /* Added */
      text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
    }
     #controls input {
        width: 70px; /* Adjusted width */
        text-align: center;
        background: #fff; /* White background */
        color: #555; /* Dark text */
        text-transform: none;
        text-shadow: none;
        font-weight: bold;
        border: 2px solid #ccc;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
     }

    #controls button:hover:not(:disabled) {
      background: linear-gradient(to bottom, var(--color-button-hover-bg1), var(--color-button-hover-bg2));
      border-color: var(--color-button-hover-border);
      box-shadow: 0 5px 8px rgba(0,0,0,0.2);
      transform: translateY(-2px);
    }
    #controls button:active:not(:disabled) {
        transform: translateY(0px);
        box-shadow: 0 2px 3px rgba(0,0,0,0.15);
        filter: brightness(0.95);
    }
     #controls button:disabled {
         cursor: not-allowed;
         opacity: 0.6;
         filter: grayscale(50%);
         box-shadow: 0 2px 3px rgba(0,0,0,0.1);
     }

    #spin {
        background: linear-gradient(to bottom, var(--color-spin-bg1), var(--color-spin-bg2));
        border-color: var(--color-spin-border);
        color: #fff;
    }
    #spin:hover:not(:disabled) {
        background: linear-gradient(to bottom, #66bb6a, #43a047); /* Lighter green hover */
        border-color: #a5d6a7; /* Light green border hover */
    }


    #message {
      font-size: 24px; /* Adjusted */
      margin-top: 20px;
      min-height: 65px; /* Reserve space */
      padding: 15px; /* More padding */
      background-color: rgba(255,255,255,0.85); /* Lighter background */
      border-radius: 10px;
      color: var(--color-message-text);
      text-shadow: none; /* Remove shadow for better readability */
      white-space: pre-line;
      line-height: 1.4;
      border: 1px solid rgba(0,0,0,0.1);
      font-family: 'Arial', sans-serif; /* Readable font */
      font-weight: bold;
    }
    #message.win {
        color: var(--color-message-win); /* Green */
    }
    #message.big-win {
        font-size: 28px; /* Slightly larger */
        color: var(--color-message-bigwin); /* Orange */
        animation: bigWinPulse 0.7s infinite alternate;
    }

    @keyframes bigWinPulse { /* Subtler pulse */
        from { transform: scale(1); }
        to { transform: scale(1.02); }
    }

     /* --- Restyled Pull Lever --- */
    #lever-container {
        position: absolute;
        top: 130px; /* Adjusted */
        left: calc(100% - var(--lever-offset) + 30px);
        width: var(--lever-width);
        height: 280px; /* Adjusted height */
        z-index: 2;
    }

    #lever-handle {
        position: absolute;
        bottom: 10px;
        left: 0;
        width: var(--lever-width);
        height: 160px; /* Adjusted handle length */
        background: var(--color-lever-handle); /* Wood gradient */
        border: 4px solid #6f4e37; /* Darker brown border */
        border-radius: 8px 8px 0 0; /* Less rounded */
        cursor: pointer;
        transition: transform 0.3s ease-out, background 0.3s ease-out;
        transform-origin: bottom center;
        box-shadow: 3px 3px 6px rgba(0,0,0,0.3);
    }
    #lever-handle::after { /* Ball - Pink */
        content: '';
        position: absolute;
        top: -18px; /* Adjusted position */
        left: 50%;
        transform: translateX(-50%);
        width: 45px; /* Adjusted size */
        height: 45px;
        background: var(--color-lever-ball); /* Pink gradient */
        border-radius: 50%;
        border: 3px solid #a01060; /* Darker pink border */
        box-shadow: inset -3px -3px 5px rgba(0,0,0,0.3), 1px 1px 2px rgba(255,255,255,0.4);
    }

    #lever-handle.pulled {
        transform: translateY(-60px); /* Pull distance */
        background: linear-gradient(to right, #e0c4a1, #b8734a); /* Lighter wood when pulled */
    }

    #lever-handle.disabled {
        cursor: not-allowed;
        opacity: 0.5;
        filter: grayscale(40%);
    }


    /* --- Title Screen (Floral Theme) --- */
    #title-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 230, 240, 0.97); /* Light pink overlay */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
      color: var(--color-title-screen-text); /* Dark text */
    }
    #title-screen h1 {
      font-size: calc(2.8em + 3.8vw); /* Larger */
      color: var(--color-border); /* Hot Pink */
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 25px;
      letter-spacing: 1px;
    }
     #title-screen p {
         font-size: calc(1em + 0.7vw);
         margin-bottom: 45px;
         max-width: 85%;
         line-height: 1.7;
         color: #555; /* Darker grey text */
         font-family: Arial, sans-serif; /* Readable font */
     }
    #start-button {
      font-size: calc(1.3em + 1.9vw);
      padding: 16px 35px;
      border-radius: 25px; /* Rounded */
      background: linear-gradient(to bottom, var(--color-spin-bg1), var(--color-spin-bg2)); /* Green */
      border: 4px solid var(--color-accent); /* Lime Green Border */
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 6px 12px rgba(0,0,0,0.2);
      text-transform: uppercase;
      font-family: 'Arial', sans-serif; /* Readable Font */
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
    }
    #start-button:hover {
      background: linear-gradient(to bottom, #66bb6a, #43a047); /* Lighter green */
      box-shadow: 0 8px 16px rgba(0,0,0,0.25);
      transform: scale(1.03);
    }

  </style>
</head>
<body>

  <!-- Title Screen -->
  <div id="title-screen">
    <h1>Blossom Hearts</h1>
    <p>Spin the reels of love and luck! Match 3 or 4 beautiful hearts and flowers.<br>Use the SPIN button or pull the lovely LEVER!</p>
    <button id="start-button">Start Playing</button>
  </div>

  <!-- Main Game Area -->
  <div id="game-container" style="display: none;"> <!-- Hidden initially -->
      <div id="slot-machine">
        <div id="title">Blossom Hearts<span>4x4 Slots</span></div>
        <div id="money-display">$100</div>

        <div id="reels-container">
          <!-- Reels Generated by JS -->
           <!-- Win Line Overlays - Need 10 lines for 4x4 (4H, 4V, 2D) -->
         <div class="win-line horizontal" id="line-h0"></div>
         <div class="win-line horizontal" id="line-h1"></div>
         <div class="win-line horizontal" id="line-h2"></div>
         <div class="win-line horizontal" id="line-h3"></div>
         <div class="win-line vertical" id="line-v0"></div>
         <div class="win-line vertical" id="line-v1"></div>
         <div class="win-line vertical" id="line-v2"></div>
         <div class="win-line vertical" id="line-v3"></div>
         <div class="win-line diagonal" id="line-d0"></div> <!-- TL-BR -->
         <div class="win-line diagonal" id="line-d1"></div> <!-- TR-BL -->
        </div>

        <div id="controls">
          <label for="bet">Bet:</label>
          <input type="number" id="bet" value="5" min="1">
          <button id="maxBet">Max Bet</button>
          <button id="spin">Spin</button>
          <button id="auto">Auto</button>
          <button id="payTable">Pays</button>
          <button id="reset">Reset</button>
        </div>
        <div id="message">Place your bet and watch the flowers bloom!</div>
      </div>

       <!-- Lever -->
       <div id="lever-container">
           <div id="lever-handle"></div>
       </div>
  </div>

  <!-- Audio Elements (REPLACE PATHS!) -->
  <audio id="spin-sound" src="path/to/gentle_spin.mp3" preload="auto"></audio>
  <audio id="win-sound" src="path/to/chime_win.mp3" preload="auto"></audio>
  <audio id="big-win-sound" src="path/to/harp_flourish_win.mp3" preload="auto"></audio>
  <audio id="reel-stop-sound" src="path/to/soft_click.mp3" preload="auto"></audio>
  <audio id="button-click-sound" src="path/to/pop_click.mp3" preload="auto"></audio>
  <audio id="lever-pull-sound" src="path/to/creak_pull.mp3" preload="auto"></audio>


  <script>
    // --- Configuration ---
    const config = {
        money: 100,
        reelCount: 4, // <<< 4 Reels
        rowCount: 4,  // <<< 4 Rows
        symbolHeight: 85, // Match CSS --reel-height
        reelWidth: 85,    // Match CSS --reel-width
        reelGap: 10,      // Match CSS --reel-gap
        reelsPadding: 20, // Match CSS --reels-padding
        spinDurationBase: 1000, // Slightly faster base spin
        spinDurationVariance: 500,
        reelStopDelay: 180, // Adjusted delay
        autoSpinDelay: 1600, // Adjusted delay
        leverPullDuration: 400,
        bigWinMultiplierThreshold: 20, // Adjusted threshold for 4x4 payouts

        symbols: [ // Hearts & Flowers Emojis & Payouts for 3, 4 of a kind
            // Lower Value
            { id: 'pink-heart', emoji: 'ðŸ’–', payouts: { 3: 2, 4: 5 } },
            { id: 'orange-heart', emoji: 'ðŸ§¡', payouts: { 3: 2, 4: 6 } },
            { id: 'yellow-heart', emoji: 'ðŸ’›', payouts: { 3: 3, 4: 7 } },
            // Medium Value
            { id: 'hibiscus', emoji: 'ðŸŒº', payouts: { 3: 4, 4: 10 } },
            { id: 'tulip', emoji: 'ðŸŒ·', payouts: { 3: 5, 4: 12 } },
            { id: 'sunflower', emoji: 'ðŸŒ»', payouts: { 3: 6, 4: 15 } },
            // Higher Value
            { id: 'purple-heart', emoji: 'ðŸ’œ', payouts: { 3: 8, 4: 20 } },
            { id: 'rose', emoji: 'ðŸŒ¹', payouts: { 3: 10, 4: 30 } },
            { id: 'red-heart', emoji: 'â¤ï¸', payouts: { 3: 15, 4: 50 } },
            // Wild Symbol
            { id: 'sparkle', emoji: 'âœ¨', wild: true, payouts: { 3: 20, 4: 100 } } // Wilds pay well on their own too!
        ],
        winningLines: [
            // Indices 0-15 for 4x4 grid
            // Horizontals (4 lines)
            { id: 'line-h0', indices: [0, 1, 2, 3] },
            { id: 'line-h1', indices: [4, 5, 6, 7] },
            { id: 'line-h2', indices: [8, 9, 10, 11] },
            { id: 'line-h3', indices: [12, 13, 14, 15] },
            // Verticals (4 lines)
            { id: 'line-v0', indices: [0, 4, 8, 12] },
            { id: 'line-v1', indices: [1, 5, 9, 13] },
            { id: 'line-v2', indices: [2, 6, 10, 14] },
            { id: 'line-v3', indices: [3, 7, 11, 15] },
            // Diagonals (2 main lines)
            { id: 'line-d0', indices: [0, 5, 10, 15] }, // TL-BR
            { id: 'line-d1', indices: [3, 6, 9, 12] }  // TR-BL
        ]
    };

    // --- Game State ---
    let money = config.money;
    let currentBet = 5;
    let autoMode = false;
    let spinning = false;
    let reels = [];
    let finalSymbols = []; // Flat array [0-15] of final visible symbols
    let autoSpinTimeout = null;
    let stopPromises = [];

    // --- DOM Elements ---
    const moneyDisplay = document.getElementById('money-display');
    const reelsContainer = document.getElementById('reels-container');
    const betInput = document.getElementById('bet');
    const maxBetButton = document.getElementById('maxBet');
    const spinButton = document.getElementById('spin');
    const autoButton = document.getElementById('auto');
    const payTableButton = document.getElementById('payTable');
    const resetButton = document.getElementById('reset');
    const messageDisplay = document.getElementById('message');
    const titleScreen = document.getElementById('title-screen');
    const startButton = document.getElementById('start-button');
    const gameContainer = document.getElementById('game-container');
    const leverHandle = document.getElementById('lever-handle');
    const winLineElements = {};
    // Get the 10 win line elements
    config.winningLines.forEach(line => {
        winLineElements[line.id] = document.getElementById(line.id);
        if (!winLineElements[line.id]) console.error(`Win line element not found: ${line.id}`);
    });


    // --- Audio Elements ---
    const sounds = {
        spin: document.getElementById('spin-sound'),
        win: document.getElementById('win-sound'),
        bigWin: document.getElementById('big-win-sound'),
        reelStop: document.getElementById('reel-stop-sound'),
        click: document.getElementById('button-click-sound'),
        lever: document.getElementById('lever-pull-sound')
    };

    // --- Functions ---

    function playSound(sound) {
        if (sound && typeof sound.play === 'function') {
            sound.currentTime = 0;
            sound.play().catch(e => console.warn("Sound play failed:", e));
        }
    }

    function updateMoneyDisplay() {
      moneyDisplay.innerText = `$${money.toLocaleString()}`;
      betInput.max = money > 0 ? money : 1;
      if (parseInt(betInput.value) > money && money > 0) {
          betInput.value = money;
      } else if (money <= 0 && !spinning) { // Added !spinning check
            betInput.value = 1; // Allow setting bet even if broke, but can't spin
            betInput.disabled = true; // Disable input if broke
            maxBetButton.disabled = true;
      } else if (!spinning) { // Re-enable if not spinning and has money
          betInput.disabled = false;
          maxBetButton.disabled = false;
      }

       if (money <= 0 && !spinning) {
            disableControls(true, true); // Disable spin/lever/auto
            displayMessage("Out of credits! Reset game?", false, true); // Indicate broke status
       }
    }


    function disableControls(disable = true, disableLever = disable) {
        spinButton.disabled = disable;
        // Max bet and bet input handled by updateMoneyDisplay based on funds
        // autoButton disabling needs care based on autoMode state
        if (!spinning) { // Only disable auto fully if not already spinning
            autoButton.disabled = disable;
        } else if (!autoMode && disable) { // If spinning manually, disable auto toggle
            autoButton.disabled = true;
        } // If spinning in autoMode, keep autoButton enabled to allow stopping

        if (leverHandle) {
            leverHandle.classList.toggle('disabled', disableLever);
        }
     }

    function displayMessage(msg, isWin = false, isBigWin = false) {
      messageDisplay.innerText = msg;
      messageDisplay.className = 'message'; // Reset classes
      if (isWin) messageDisplay.classList.add('win');
      if (isBigWin) messageDisplay.classList.add('big-win');
    }

    // Create visual symbol element using EMOJI
    function createSymbolElement(symbolData) {
        const div = document.createElement('div');
        div.classList.add('symbol');
        div.style.height = `${config.symbolHeight}px`;
        div.dataset.symbolId = symbolData.id;
        div.textContent = symbolData.emoji;
        return div;
    }

    // Build the reels visually
    function buildReels() {
      reelsContainer.innerHTML = ''; // Clear previous reels if any
      // Clear existing win lines visually before rebuilding reels
      Object.values(winLineElements).forEach(lineEl => {
            if(lineEl) lineEl.style.display = 'none';
      });

      reels = [];

      for (let i = 0; i < config.reelCount; i++) { // Use config.reelCount (4)
        const reelElement = document.createElement('div');
        reelElement.classList.add('reel');
        reelElement.style.height = `${config.rowCount * config.symbolHeight}px`; // Use config.rowCount (4)

        const symbolsContainer = document.createElement('div');
        symbolsContainer.classList.add('symbols-container');

        const reelSymbolsData = [];
        const reelSymbolElements = [];
        // Add repetitions for visual spin pool (adjust count as needed for 4x4)
        for (let k=0; k < 12; k++) { // Reduced repetitions slightly
            // Create a weighted shuffle if needed, or simple shuffle
            const shuffledSymbols = [...config.symbols].sort(() => Math.random() - 0.5);
            shuffledSymbols.forEach(symbolData => {
                 const symbolElement = createSymbolElement(symbolData);
                 symbolsContainer.appendChild(symbolElement);
                 reelSymbolsData.push(symbolData);
                 reelSymbolElements.push(symbolElement);
            });
        }

        reelElement.appendChild(symbolsContainer);
        // Find the reels container again to append the new reel
        document.getElementById('reels-container').appendChild(reelElement);
        reels.push({
            element: reelElement,
            symbolsContainer: symbolsContainer,
            symbols: reelSymbolsData,
            symbolElements: reelSymbolElements,
            finalPosition: 0
        });
      }

      // Append win lines AFTER reels are added
      config.winningLines.forEach(line => {
            if (winLineElements[line.id]) {
                 document.getElementById('reels-container').appendChild(winLineElements[line.id]);
            }
      });

      // Set initial random positions
       reels.forEach(reel => {
          const randomIndex = Math.floor(Math.random() * reel.symbols.length);
          const initialY = -(randomIndex * config.symbolHeight);
          reel.symbolsContainer.style.transition = 'none';
          reel.symbolsContainer.style.transform = `translateY(${initialY}px)`;
          reel.finalPosition = initialY;
          // Force reflow
          reel.symbolsContainer.offsetHeight; // eslint-disable-line no-unused-expressions
          reel.symbolsContainer.style.transition = ''; // Re-enable transitions for spinning
      });
    }


    // Clear highlights
    function clearHighlights() {
        document.querySelectorAll('.symbol.winning').forEach(el => el.classList.remove('winning'));
        Object.values(winLineElements).forEach(lineEl => {
            if(lineEl) lineEl.style.display = 'none';
        });
        messageDisplay.className = 'message'; // Reset message style
    }

    // Highlight winning symbols and position lines for 4x4
    function highlightWins(winningLinesInfo) {
        const containerPadding = config.reelsPadding;
        const symbolCenterY = config.symbolHeight / 2;
        const symbolCenterX = config.reelWidth / 2;
        const lineThicknessHalf = 3; // Half of line height/width (6px)

        winningLinesInfo.forEach(winInfo => {
            // Highlight symbols involved
             const indicesToHighlight = winInfo.line.indices.slice(0, winInfo.count); // Only highlight the N matched symbols
             indicesToHighlight.forEach(flatIndex => {
                const reelIndex = flatIndex % config.reelCount; // 0-3
                const visibleRowIndex = Math.floor(flatIndex / config.reelCount); // 0-3
                if (reelIndex < reels.length) { // Check if reel exists
                    const reel = reels[reelIndex];
                     // Calculate the index of the symbol element corresponding to the visible slot
                    const topVisibleIndex = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                    // Wrap index correctly using modulo and adding length for safety
                    const targetElementIndex = (topVisibleIndex + visibleRowIndex + reel.symbolElements.length) % reel.symbolElements.length;

                    const targetElement = reel.symbolElements[targetElementIndex];
                    if(targetElement) {
                        targetElement.classList.add('winning');
                    } else {
                         console.warn(`Target element not found for highlight: flatIndex=${flatIndex}, reelIndex=${reelIndex}, visibleRowIndex=${visibleRowIndex}, targetElementIndex=${targetElementIndex}`);
                    }
                }
            });

            // Show and position win line
            const lineElement = winLineElements[winInfo.line.id];
            if (lineElement) {
                 // Calculations need to use 4x4 dimensions from config
                 const totalReelWidth = config.reelCount * config.reelWidth + (config.reelCount - 1) * config.reelGap;
                 const totalReelHeight = config.rowCount * config.symbolHeight; // Assuming no vertical gap

                 if (lineElement.classList.contains('horizontal')) {
                    const rowIndex = Math.floor(winInfo.line.indices[0] / config.reelCount);
                    lineElement.style.top = `${containerPadding + (rowIndex * config.symbolHeight) + symbolCenterY - lineThicknessHalf}px`;
                    // Optional: Adjust width for 3-of-a-kind
                    // lineElement.style.width = `${winInfo.count * config.reelWidth + (winInfo.count - 1) * config.reelGap}px`;
                } else if (lineElement.classList.contains('vertical')) {
                     const colIndex = winInfo.line.indices[0] % config.reelCount;
                     lineElement.style.left = `${containerPadding + (colIndex * (config.reelWidth + config.reelGap)) + symbolCenterX - lineThicknessHalf}px`;
                     // Optional: Adjust height for 3-of-a-kind
                     // lineElement.style.height = `${winInfo.count * config.symbolHeight}px`;
                } else if (lineElement.id === 'line-d0') { // TL-BR Diagonal
                     const angle = Math.atan2(totalReelHeight, totalReelWidth) * (180 / Math.PI);
                     const length = Math.sqrt(totalReelWidth * totalReelWidth + totalReelHeight * totalReelHeight);

                     lineElement.style.height = `${length}px`; // Use height for diagonal length
                     lineElement.style.top = `${containerPadding + symbolCenterY - lineThicknessHalf}px`;
                     lineElement.style.left = `${containerPadding + symbolCenterX - lineThicknessHalf}px`;
                     lineElement.style.transform = `rotate(${angle}deg)`;
                     lineElement.style.transformOrigin = `top left`;

                } else if (lineElement.id === 'line-d1') { // TR-BL Diagonal
                    const angle = Math.atan2(totalReelHeight, totalReelWidth) * (180 / Math.PI);
                    const length = Math.sqrt(totalReelWidth * totalReelWidth + totalReelHeight * totalReelHeight);

                    lineElement.style.height = `${length}px`;
                    lineElement.style.top = `${containerPadding + symbolCenterY - lineThicknessHalf}px`;
                    // Position from the right edge based on total width
                    lineElement.style.left = `calc(${containerPadding + totalReelWidth + symbolCenterX - lineThicknessHalf}px)`;
                    lineElement.style.transform = `rotate(-${angle}deg)`;
                    lineElement.style.transformOrigin = `top right`;
                }
                lineElement.style.display = 'block';
            } else {
                 console.warn(`Win line element DOM node not found for ID: ${winInfo.line.id}`);
            }
        });
    }


    // Evaluate the final 4x4 grid state for 3 or 4 of a kind, considering Wilds
    function evaluateResult() {
        let totalWinnings = 0;
        let winningLinesInfo = []; // Stores { line, amount, symbolId, count }
        let isBigWinOverall = false;
        let highestMultiplierAchieved = 0;

        // Get final VISIBLE symbols [0-15]
        finalSymbols = [];
        for (let r = 0; r < config.rowCount; r++) { // 0-3
            for (let c = 0; c < config.reelCount; c++) { // 0-3
                const reel = reels[c];
                const topVisibleIndex = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                const symbolIndexInReel = (topVisibleIndex + r + reel.symbols.length) % reel.symbols.length; // Safer modulo
                finalSymbols.push(reel.symbols[symbolIndexInReel]);
            }
        }
        // console.log("Final Symbols:", finalSymbols.map(s => s?.id ?? '?'));

        config.winningLines.forEach(line => {
            const symbolsOnLineData = line.indices.map(index => finalSymbols[index]);
            if (!symbolsOnLineData.length || !symbolsOnLineData[0]) return; // Skip empty lines

            let lineSymbolToMatch = null;
            let wildCountStart = 0;
            let firstNonWildIndex = -1;

            // Find the first non-wild symbol to determine the line's paying symbol
            for(let i = 0; i < symbolsOnLineData.length; i++) {
                if (symbolsOnLineData[i] && !symbolsOnLineData[i].wild) {
                    lineSymbolToMatch = symbolsOnLineData[i];
                    firstNonWildIndex = i;
                    break;
                } else if (symbolsOnLineData[i] && symbolsOnLineData[i].wild) {
                     wildCountStart++; // Count leading wilds
                } else {
                    break; // Stop if empty slot encountered early
                }
            }

            // If the line is ALL wilds, the first wild determines the 'symbol'
            if (!lineSymbolToMatch && wildCountStart > 0) {
                 lineSymbolToMatch = symbolsOnLineData[0]; // Treat the wild itself as the symbol to match
                 firstNonWildIndex = 0; // Start matching from the beginning
            }

            // If no symbol could be determined (e.g., line starts with empty slot), skip line
            if (!lineSymbolToMatch) return;

            // Count matches from the first non-wild (or first wild if all wilds)
            let matchCount = 0;
            for (let i = firstNonWildIndex; i < symbolsOnLineData.length; i++) {
                 const currentSymbol = symbolsOnLineData[i];
                 if (currentSymbol && (currentSymbol.id === lineSymbolToMatch.id || currentSymbol.wild)) {
                     matchCount++;
                 } else {
                     break; // Stop counting on mismatch
                 }
            }

            // Add the leading wilds back to the count
            matchCount += wildCountStart; // (Corrected logic: add leading wilds)
            // Adjust if the firstNonWild was actually the wild symbol itself (all wild line case)
            if(lineSymbolToMatch.wild && firstNonWildIndex === 0) {
                // In the pure wild line case, the loop counts the first wild.
                // 'matchCount' already includes all wilds. No adjustment needed here.
            } else if (lineSymbolToMatch.wild === false && firstNonWildIndex > 0) {
                 // If the line started like W W S ..., matchCount includes S count + W W count
                 // This seems correct.
            }


            // Check for 3 or 4 of a kind
            if (matchCount >= 3) {
                 const symbolData = config.symbols.find(s => s.id === lineSymbolToMatch.id);
                 if (symbolData && symbolData.payouts && symbolData.payouts[matchCount]) {
                    const multiplier = symbolData.payouts[matchCount];
                    const winAmount = currentBet * multiplier;
                    totalWinnings += winAmount;
                    winningLinesInfo.push({
                        line: line,
                        amount: winAmount,
                        symbolId: lineSymbolToMatch.id, // ID of the symbol that formed the win (could be wild)
                        count: matchCount
                    });

                    if (multiplier > highestMultiplierAchieved) {
                        highestMultiplierAchieved = multiplier;
                    }
                }
             }
        });

        // --- Process Results ---
        spinning = false; // Mark spinning as finished BEFORE updating money/controls

        if (totalWinnings > 0) {
            money += totalWinnings;
            if (highestMultiplierAchieved >= config.bigWinMultiplierThreshold) {
                 isBigWinOverall = true;
                 playSound(sounds.bigWin);
                 displayMessage(`!!! HUGE BLOOM !!!\n$${totalWinnings.toLocaleString()}`, true, true);
             } else {
                 playSound(sounds.win);
                 displayMessage(`WIN! $${totalWinnings.toLocaleString()}`, true, false);
             }
            highlightWins(winningLinesInfo);
        } else {
            displayMessage("No matching blossoms... Spin again!");
        }

        updateMoneyDisplay(); // Update money display AFTER wins/losses applied

        // Re-enable controls AFTER evaluating results and updating money
        disableControls(false, false);
        spinButton.innerText = "Spin";


        // Handle Auto Spin
         if (autoMode) {
             if (money >= currentBet && money > 0) {
                autoSpinTimeout = setTimeout(startSpin, config.autoSpinDelay);
             } else {
                 autoMode = false;
                 autoButton.innerText = "Auto";
                 autoButton.style.background = ''; // Reset style
                 autoButton.classList.remove('active');
                 displayMessage(money <= 0 ? "Out of credits! Auto stopped." : "Can't afford bet. Auto stopped.", false, money <= 0);
                 updateMoneyDisplay(); // Ensure controls are disabled if broke
                 disableControls(money <= 0, money <= 0); // Update control state after auto stops
             }
         }
    }

    // Start the spinning process
    function startSpin() {
        if (spinning) return;

        clearTimeout(autoSpinTimeout); // Clear any pending auto spin
        clearHighlights(); // Clear previous win visuals

        currentBet = parseInt(betInput.value);
        if (isNaN(currentBet) || currentBet <= 0) {
            displayMessage("Please enter a valid bet > 0.");
            if(autoMode) { // Stop auto if bet is invalid
                 autoMode = false;
                 autoButton.innerText = "Auto";
                 autoButton.style.background = '';
                 autoButton.classList.remove('active');
            }
            return;
        }
        if (currentBet > money) {
            displayMessage("Not enough credits for this bet!");
             if(autoMode) { // Stop auto if broke
                 autoMode = false;
                 autoButton.innerText = "Auto";
                 autoButton.style.background = '';
                 autoButton.classList.remove('active');
            }
            return;
        }

        spinning = true;
        money -= currentBet;
        updateMoneyDisplay(); // Update display immediately after taking bet
        disableControls(true, true); // Disable controls while spinning
        spinButton.innerText = "Spinning...";
        displayMessage("Reels are blossoming...");
        playSound(sounds.spin);

        stopPromises = [];

        // --- Animate Reels ---
        reels.forEach((reel, index) => {
            const symbolsContainer = reel.symbolsContainer;
            const currentY = reel.finalPosition || 0; // Use 0 if undefined
            const extraRevolutions = 4 + Math.floor(Math.random() * 4); // Fewer revs maybe
            const totalSymbolsHeight = reel.symbols.length * config.symbolHeight;

            // Ensure previous stopping class is removed
            reel.element.classList.remove('stopping');
            symbolsContainer.classList.remove('stopping'); // Also remove from symbols container

            // Apply linear spin animation
            // Calculate dynamic duration based on config and index
            const dynamicSpinDuration = (config.spinDurationBase + index * (config.reelStopDelay / 2)) / 1000; // Adjust multiplier if needed
            symbolsContainer.style.transition = `transform ${dynamicSpinDuration}s linear`;

            // Calculate target Y for the initial linear spin
            // Ensure it spins downwards (negative Y)
            const spinTargetY = currentY - (extraRevolutions * totalSymbolsHeight) - (Math.random() * totalSymbolsHeight) ;
            // Need to trigger reflow before applying transform sometimes
            symbolsContainer.offsetHeight; // eslint-disable-line no-unused-expressions
            symbolsContainer.style.transform = `translateY(${spinTargetY}px)`;


            // --- Schedule Stop ---
             const stopDelay = config.spinDurationBase + (index * config.reelStopDelay) + (Math.random() * config.spinDurationVariance);

             const stopPromise = new Promise(resolve => {
                 setTimeout(() => {
                    // Choose a random symbol index to land on
                    const randomSymbolIndex = Math.floor(Math.random() * reel.symbols.length);
                     // Calculate final Y to snap to the symbol grid.
                     // Aim to center the middle rows (row 1 and 2 for 4 rows)
                     // Land on randomSymbolIndex. To center, top visible row is randomSymbolIndex - floor(rowCount/2) + 1 ??
                     // Let's target randomSymbolIndex to be the *second* row from the top (index 1).
                     // finalY = - ( (targetIndex - desiredVisibleRowIndex + totalSymbols) % totalSymbols ) * symbolHeight
                     // Target index is randomSymbolIndex. Desired visible row is 1.
                    const finalY = -((randomSymbolIndex - 1 + reel.symbols.length) % reel.symbols.length) * config.symbolHeight;

                    reel.finalPosition = finalY; // Store the final position

                    // Apply the stopping transition
                    reel.element.classList.add('stopping'); // Add class to reel element
                    symbolsContainer.classList.add('stopping'); // Add to symbols container for transition override
                    symbolsContainer.style.transition = ''; // Remove linear transition potentially? Or rely on .stopping override? Let's rely on override.
                    symbolsContainer.style.transform = `translateY(${finalY}px)`; // Snap to final position

                    playSound(sounds.reelStop); // Play stop sound

                    // Resolve promise when the stopping transition ends
                    const transitionEndHandler = (event) => {
                         // Ensure we're reacting to the transform transition ending on the correct element
                        if (event.target === symbolsContainer && event.propertyName === 'transform') {
                            symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                            reel.element.classList.remove('stopping'); // Clean up class
                            symbolsContainer.classList.remove('stopping');
                            resolve(); // Signal this reel has stopped
                        }
                    };
                    symbolsContainer.addEventListener('transitionend', transitionEndHandler);

                    // Failsafe: If transitionend doesn't fire (e.g., interrupted, no actual change)
                    // resolve after a timeout slightly longer than the transition.
                    setTimeout(() => {
                        // Check if it hasn't resolved yet
                        // This requires a more complex state check, risky.
                        // For now, rely on transitionend. If issues arise, add failsafe.
                        // console.log(`Failsafe timeout for reel ${index}`);
                        // resolve(); // Careful with duplicate resolves
                    }, 1100); // Slightly longer than 1s stopping transition


                 }, stopDelay);
             });
             stopPromises.push(stopPromise);
        });

        // --- Wait for all reels to stop ---
        Promise.all(stopPromises).then(() => {
            // console.log("All reels stopped visually.");
             // Short delay before evaluation allows final symbols to settle visually
             setTimeout(evaluateResult, 200);
        }).catch(error => {
            console.error("Error during reel stopping:", error);
            // Handle potential errors, maybe reset state
            spinning = false;
            updateMoneyDisplay();
            disableControls(false, false);
            displayMessage("Spin cycle error. Please try again.", false);
        });
    }


    // --- Event Listeners ---
    startButton.addEventListener('click', () => {
        playSound(sounds.click);
        titleScreen.style.display = 'none';
        gameContainer.style.display = 'block';
        initializeGame();
    });

    spinButton.addEventListener('click', () => {
         if (!spinning && money >= (parseInt(betInput.value) || 1) ) { // Check funds before playing sound
             playSound(sounds.click);
             startSpin();
         } else if (!spinning && money < (parseInt(betInput.value) || 1)) {
             playSound(sounds.click); // Play click even if broke
             displayMessage("Not enough credits for this bet!");
         }
    });

    leverHandle.addEventListener('click', () => {
        if (!spinning && !leverHandle.classList.contains('disabled') && money >= (parseInt(betInput.value) || 1)) {
             playSound(sounds.lever);
             leverHandle.classList.add('pulled');
             startSpin();
             setTimeout(() => { leverHandle.classList.remove('pulled'); }, config.leverPullDuration);
        } else if (!spinning && money < (parseInt(betInput.value) || 1)) {
            playSound(sounds.click); // Play click sound even if broke
             displayMessage("Not enough credits to pull the lever!");
        }
    });


    maxBetButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (!spinning) {
             const maxPossibleBet = money > 0 ? money : 1;
             betInput.value = maxPossibleBet;
             currentBet = maxPossibleBet;
        }
    });

    autoButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (spinning && autoMode) {
             // --- STOP AUTO ---
             autoMode = false;
             clearTimeout(autoSpinTimeout); // Stop the next scheduled spin
             autoButton.innerText = "Auto";
             autoButton.style.background = ''; // Reset style
             autoButton.classList.remove('active');
             // Don't display message here, wait for current spin to finish
             // Controls will be re-enabled by evaluateResult
             // We only need to ensure the autoButton itself is not disabled if we stop it mid-spin
             autoButton.disabled = false; // Ensure it can be clicked again later
             displayMessage("Auto-spin stopping after this round...");

        } else if (!spinning) {
            // --- TOGGLE AUTO ON/OFF ---
             if (money <= 0) {
                 displayMessage("Out of credits! Cannot start auto-spin.");
                 return;
             }
             if (money < (parseInt(betInput.value) || 1)) {
                  displayMessage("Not enough credits for current bet! Cannot start auto-spin.");
                 return;
             }

            autoMode = !autoMode;
             if (autoMode) {
                 // --- START AUTO ---
                 autoButton.innerText = "Stop Auto";
                 autoButton.style.background = 'linear-gradient(to bottom, #ff6b6b, #ee3838)'; // Active Red color
                 autoButton.classList.add('active');
                 displayMessage("Auto-spin engaged!");
                 startSpin(); // Start the first auto spin immediately
             } else {
                 // --- STOP AUTO (when not spinning) ---
                 // This case happens if clicked OFF when idle
                 autoButton.innerText = "Auto";
                 autoButton.style.background = ''; // Reset style
                 autoButton.classList.remove('active');
                 displayMessage("Auto-spin disengaged.");
                 // No need to clear timeout as none is pending
             }
        }
        // If clicked while spinning but NOT in auto mode, do nothing.
    });


    payTableButton.addEventListener('click', () => {
        playSound(sounds.click);
        let table = "BLOSSOM PAYOUTS (Bet x Multiplier):\n\n";
        table += "Symbol | x3 | x4 \n";
        table += "--------------------\n";
        config.symbols.forEach(s => {
            if (s.payouts) {
                 // Add padding for alignment
                 const idPad = (s.id + (s.wild ? ' (WILD)' : '')).padEnd(13, ' ');
                 const p3 = (s.payouts[3] ? s.payouts[3] + 'x' : '-').padStart(3, ' ');
                 const p4 = (s.payouts[4] ? s.payouts[4] + 'x' : '-').padStart(3, ' ');
                 table += `${s.emoji} ${idPad}| ${p3} | ${p4}\n`;
            }
        });
         table += "\nâœ¨ Wild substitutes for all symbols.";
         table += "\nLines: 4 Horizontal, 4 Vertical, 2 Diagonal.";
        alert(table);
    });

    resetButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (confirm("Reset game and start fresh with $100?")) {
            // Instead of reload, call initializeGame for a smoother reset
             autoMode = false; // Ensure auto mode is off
             clearTimeout(autoSpinTimeout); // Clear any pending auto spin
             initializeGame();
            // location.reload(); // Less smooth
        }
    });

    // Bet Input Listeners
    betInput.addEventListener('input', () => {
        let value = parseInt(betInput.value.replace(/[^0-9]/g, '')) || 1;
        value = Math.max(1, value); // Ensure bet is at least 1
        // Allow setting bet higher than current money, but cap at max bet button press or spin attempt
        // if (money > 0) { value = Math.min(value, money); } // Don't cap input here
        betInput.value = value;
        currentBet = value; // Update currentBet based on input
    });
     betInput.addEventListener('change', () => { // Validate on losing focus
         let value = parseInt(betInput.value) || 1;
         value = Math.max(1, value);
         // Optionally cap bet to money here if desired, or let spin handle it
         // if (money > 0) { value = Math.min(value, money); }
         betInput.value = value;
         currentBet = value;
     });


     // --- Initialization ---
     function initializeGame() {
        money = config.money;
        currentBet = parseInt(betInput.value) || 5;
        currentBet = Math.max(1, currentBet); // Ensure initial bet >= 1
        betInput.value = currentBet; // Sync input field
        spinning = false;
        autoMode = false; // Ensure auto is off on init/reset
        clearTimeout(autoSpinTimeout);
        displayMessage("Place your bet and watch the flowers bloom!");
        buildReels(); // Build fresh reels
        updateMoneyDisplay(); // Update money and check control states
        clearHighlights(); // Clear any lingering highlights/lines
        disableControls(false, false); // Enable controls initially (unless broke)
        if (money <=0) disableControls(true, true); // Disable if starting broke (unlikely but safe)

        // Reset Auto Button State
         autoButton.innerText = "Auto";
         autoButton.style.background = '';
         autoButton.classList.remove('active');
         autoButton.disabled = (money <= 0); // Disable auto if broke

        // Reset Lever State
        if(leverHandle) {
            leverHandle.classList.remove('disabled', 'pulled');
            leverHandle.classList.toggle('disabled', money <= 0); // Disable lever if broke
        }
     }

     // Initial setup when the script runs (after DOM loaded)
     // Don't run initializeGame here, wait for Start button
     // window.addEventListener('DOMContentLoaded', initializeGame); // No, wait for start button

  </script>
</body>
</html>
