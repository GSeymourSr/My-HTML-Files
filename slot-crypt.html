<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Creepy Crypt 5x5 Slots!</title>
  <style>
    :root {
      /* Grid Dimensions */
      --num-reels: 5; /* <<< CHANGED */
      --num-rows: 5;  /* <<< CHANGED */
      /* Adjusted sizes for 5x5 grid */
      --reel-width: 70px;
      --reel-height: 70px;
      --reel-gap: 8px;
      --symbol-size: 48px; /* Smaller symbols */

      /* Layout */
      --lever-width: 40px; /* Slightly wider lever */
      --lever-offset: 70px;
      --machine-padding: 25px; /* Slightly less padding */
      --reels-padding: 15px;
      /* Recalculated for 5x5 */
      --machine-width: calc(var(--num-reels) * var(--reel-width) + (var(--num-reels) - 1) * var(--reel-gap) + 2 * var(--machine-padding));
      --reels-container-height: calc(var(--num-rows) * var(--reel-height) + 2 * var(--reels-padding));
      /* Width calculated by grid template columns + gap + padding now */


      /* --- Creepy Crypt Colors - NEW PALETTE --- */
      --color-bg-start: #1a0d1a; /* Very Dark Purple */
      --color-bg-end: #3d2a3d; /* Dark Purple/Grey */
      --color-machine-bg1: #4a4a4a; /* Dark Grey */
      --color-machine-bg2: #303030; /* Very Dark Grey */
      --color-border: #9a009a; /* Dark Magenta/Purple */
      --color-accent: #00ff00; /* Eerie Green */
      --color-title-text: #e0e0e0; /* Light Grey Text */
      --color-title-bg1: #5e005e; /* Dark Purple */
      --color-title-bg2: #4b004b; /* Darker Purple */
      --color-money: #ffcc00; /* Gold/Yellow for contrast */
      --color-reels-bg: #2a2a2a; /* Very Dark Grey */
      --color-reel-bg: #1c1c1c; /* Almost Black */
      --color-button-bg1: #6a0dad; /* Purple */
      --color-button-bg2: #500a7f; /* Darker Purple */
      --color-button-border: #9a009a;
      --color-button-hover-bg1: #7a1dbd;
      --color-button-hover-bg2: #601a8f;
      --color-button-hover-border: #c000c0;
      --color-spin-bg1: #008000; /* Dark Green */
      --color-spin-bg2: #006400; /* Darker Green */
      --color-spin-border: var(--color-accent);
      --color-lever-handle: linear-gradient(to right, #666, #333); /* Dark Grey/Metal */
      --color-lever-ball: radial-gradient(circle at 12px 12px, #ff0000, #8b0000); /* Red/Dark Red */
      --color-win-line: rgba(0, 255, 0, 0.7); /* Eerie Green Transparent */
      --color-win-shadow: rgba(0, 128, 0, 0.9); /* Dark Green Shadow */
      --color-message-text: #cccccc; /* Light Grey */
      --color-message-win: var(--color-accent); /* Eerie Green */
      --color-message-bigwin: #ff8c00; /* Dark Orange */
      --color-title-screen-text: #b0b0b0; /* Medium Grey */
    }

    body {
      margin: 0;
      /* Spooky Font */
      font-family: 'Creepster', cursive; /* Include link or fallback */
      background: radial-gradient(circle, var(--color-bg-end), var(--color-bg-start));
      color: #eee; /* Light default text */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    /* Include Creepster font */
    @import url('https://fonts.googleapis.com/css2?family=Creepster&display=swap');
    /* Fallback font */
    body, button, input {
        font-family: 'Creepster', cursive, 'Arial', sans-serif;
    }
    /* More readable font for specific elements */
    #money-display, #controls label, #controls input, #message, #title-screen p, #start-button, #controls button {
        font-family: 'Arial', sans-serif; /* Use Arial for better readability here */
        font-weight: bold; /* Make them stand out */
    }
     #title {
        font-family: 'Creepster', cursive; /* Keep title spooky */
        font-weight: normal;
     }


    #game-container {
      position: relative;
      padding-right: calc(var(--lever-width) + var(--lever-offset) - 20px);
    }

    #slot-machine {
      background: linear-gradient(145deg, var(--color-machine-bg1), var(--color-machine-bg2));
      border: 12px solid var(--color-border); /* Thicker border */
      border-radius: 25px; /* Slightly less rounded */
      padding: var(--machine-padding);
      box-shadow: 0 0 40px rgba(154, 0, 154, 0.6), inset 0 0 20px rgba(0, 0, 0, 0.4); /* Purple glow */
      text-align: center;
      width: var(--machine-width);
      position: relative;
      z-index: 1;
    }

    #title {
      font-size: 40px; /* Adjusted for new font */
      color: var(--color-title-text);
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7); /* Darker shadow */
      background: linear-gradient(to bottom, var(--color-title-bg1), var(--color-title-bg2));
      padding: 18px;
      margin: calc(-1 * var(--machine-padding)) calc(-1 * var(--machine-padding)) 20px calc(-1 * var(--machine-padding));
      border-radius: 13px 13px 0 0; /* Match outer radius */
      border-bottom: 6px solid var(--color-border);
      line-height: 1.1;
      letter-spacing: 2px; /* Add spacing for Creepster */
    }
     #title span { /* Subtitle styling */
        display: block;
        font-size: 20px;
        margin-top: 5px;
        color: var(--color-accent); /* Eerie Green */
        font-family: 'Arial', sans-serif; /* Readable subtitle font */
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        letter-spacing: 1px;
     }

    #money-display {
      font-size: 26px;
      margin: 18px 0;
      color: var(--color-money);
      text-shadow: 1px 1px 3px rgba(0,0,0, 0.5);
      background-color: rgba(0,0,0,0.6); /* Darker background */
      padding: 10px 18px;
      border-radius: 10px;
      display: inline-block;
      border: 2px solid var(--color-money);
    }

    #reels-container {
      display: grid;
      grid-template-columns: repeat(var(--num-reels), var(--reel-width)); /* Uses 5 */
      grid-gap: var(--reel-gap);
      justify-content: center;
      margin-bottom: 20px;
      background: var(--color-reels-bg);
      padding: var(--reels-padding);
      border-radius: 12px;
      border: 4px inset rgba(0, 0, 0, 0.3); /* Darker inset */
      box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
      overflow: hidden;
      height: var(--reels-container-height); /* Uses 5 */
      position: relative;
    }

    .reel {
      width: var(--reel-width);
      height: calc(var(--num-rows) * var(--reel-height)); /* Uses 5 */
      overflow: hidden;
      background: var(--color-reel-bg);
      border-radius: 5px; /* Sharper edges */
      position: relative;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.4);
    }

    .symbols-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        transition: transform 0.1s linear; /* Spinning */
    }

    .reel.stopping .symbols-container {
      transition: transform 1s cubic-bezier(0.25, 1, 0.5, 1); /* Stopping */
    }

    .symbol {
      width: var(--reel-width);
      height: var(--reel-height);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--symbol-size);
      position: relative;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
      line-height: 1;
      color: #ccc; /* Symbols have color via emoji */
      user-select: none;
      filter: grayscale(20%); /* Slightly desaturate symbols */
    }

    /* --- Win Animation (Eerie Green Flash) --- */
    @keyframes winFlash {
      0%, 100% { transform: scale(1); filter: grayscale(20%) brightness(1); }
      50% { transform: scale(1.15); filter: grayscale(0%) brightness(1.3) drop-shadow(0 0 10px var(--color-accent)); } /* Green flash */
    }

    .symbol.winning {
      animation: winFlash 0.6s ease-in-out infinite;
      z-index: 10;
    }

    /* --- Win Lines (Eerie Green) --- */
    .win-line {
        position: absolute;
        background-color: var(--color-win-line);
        box-shadow: 0 0 10px 4px var(--color-win-shadow); /* Adjusted shadow */
        z-index: 5;
        display: none;
        pointer-events: none;
        border-radius: 3px;
    }
    /* Adjusted for 5x5 */
    .win-line.horizontal {
        height: 5px; /* Slightly thinner */
        width: calc(var(--num-reels) * var(--reel-width) + (var(--num-reels) - 1) * var(--reel-gap)); /* Full width (5 reels) */
        left: var(--reels-padding);
    }
    .win-line.vertical {
        width: 5px;
        height: calc(var(--num-rows) * var(--reel-height)); /* Full height (5 rows) */
        top: var(--reels-padding);
    }
    .win-line.diagonal {
        width: 5px; /* Thickness */
    }


    #controls {
      margin: 20px 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px; /* Slightly smaller gap */
    }

    #controls label {
        /* Font set globally */
        font-weight: bold;
        color: var(--color-title-text);
        font-size: 16px;
        align-self: center;
        margin-right: -3px;
        text-transform: uppercase;
    }

    #controls input, #controls button {
      font-size: 14px; /* Smaller text on controls */
      padding: 9px 14px;
      margin: 4px;
      border-radius: 18px; /* Rounded buttons */
      border: 2px solid var(--color-button-border);
      background: linear-gradient(to bottom, var(--color-button-bg1), var(--color-button-bg2));
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      /* Font set globally */
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0,0,0,0.25);
      text-transform: uppercase;
      text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
    }
     #controls input {
        width: 65px; /* Adjusted width */
        text-align: center;
        background: #ddd; /* Light grey background */
        color: #222; /* Dark text */
        text-transform: none;
        text-shadow: none;
        font-weight: bold;
        border: 2px solid #777;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
     }

    #controls button:hover:not(:disabled) {
      background: linear-gradient(to bottom, var(--color-button-hover-bg1), var(--color-button-hover-bg2));
      border-color: var(--color-button-hover-border);
      box-shadow: 0 5px 8px rgba(0,0,0,0.3);
      transform: translateY(-1px);
    }
    #controls button:active:not(:disabled) {
        transform: translateY(0px);
        box-shadow: 0 2px 3px rgba(0,0,0,0.2);
        filter: brightness(0.95);
    }
     #controls button:disabled {
         cursor: not-allowed;
         opacity: 0.5;
         filter: grayscale(60%);
         box-shadow: 0 2px 3px rgba(0,0,0,0.15);
     }

    #spin {
        background: linear-gradient(to bottom, var(--color-spin-bg1), var(--color-spin-bg2));
        border-color: var(--color-spin-border);
        color: #fff;
    }
    #spin:hover:not(:disabled) {
        background: linear-gradient(to bottom, #009a00, #007a00); /* Lighter green hover */
        border-color: #50ff50; /* Light green border hover */
    }


    #message {
      font-size: 20px; /* Adjusted */
      margin-top: 18px;
      min-height: 60px; /* Reserve space */
      padding: 12px;
      background-color: rgba(0,0,0,0.7); /* Darker background */
      border-radius: 8px;
      color: var(--color-message-text);
      text-shadow: none; /* Remove shadow for better readability */
      white-space: pre-line;
      line-height: 1.4;
      border: 1px solid rgba(255,255,255,0.2);
      /* Font set globally */
      font-weight: bold;
    }
    #message.win {
        color: var(--color-message-win); /* Green */
        text-shadow: 0 0 5px var(--color-message-win);
    }
    #message.big-win {
        font-size: 24px; /* Slightly larger */
        color: var(--color-message-bigwin); /* Orange */
        animation: bigWinPulse 0.7s infinite alternate;
        text-shadow: 0 0 8px var(--color-message-bigwin);
    }

    @keyframes bigWinPulse { /* Subtler pulse */
        from { transform: scale(1); }
        to { transform: scale(1.02); }
    }

     /* --- Restyled Pull Lever (Rusty Metal / Red Orb) --- */
    #lever-container {
        position: absolute;
        top: 140px; /* Adjusted */
        left: calc(100% - var(--lever-offset) + 35px); /* Adjusted */
        width: var(--lever-width);
        height: 290px; /* Adjusted height */
        z-index: 2;
    }

    #lever-handle {
        position: absolute;
        bottom: 15px;
        left: 0;
        width: var(--lever-width);
        height: 170px; /* Adjusted handle length */
        background: var(--color-lever-handle); /* Metal gradient */
        border: 4px solid #222; /* Darker border */
        border-radius: 6px 6px 0 0; /* Less rounded */
        cursor: pointer;
        transition: transform 0.3s ease-out, background 0.3s ease-out;
        transform-origin: bottom center;
        box-shadow: 3px 3px 6px rgba(0,0,0,0.4);
    }
    #lever-handle::after { /* Ball - Red Orb */
        content: '';
        position: absolute;
        top: -20px; /* Adjusted position */
        left: 50%;
        transform: translateX(-50%);
        width: 50px; /* Adjusted size */
        height: 50px;
        background: var(--color-lever-ball); /* Red gradient */
        border-radius: 50%;
        border: 3px solid #500000; /* Dark red border */
        box-shadow: inset -3px -3px 5px rgba(0,0,0,0.4), 1px 1px 2px rgba(255,100,100,0.4);
    }

    #lever-handle.pulled {
        transform: translateY(-65px); /* Pull distance */
        background: linear-gradient(to right, #888, #555); /* Lighter metal when pulled */
    }

    #lever-handle.disabled {
        cursor: not-allowed;
        opacity: 0.5;
        filter: grayscale(50%);
    }


    /* --- Title Screen (Spooky Theme) --- */
    #title-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(20, 0, 20, 0.98); /* Dark purple overlay */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
      color: var(--color-title-screen-text); /* Grey text */
    }
    #title-screen h1 {
      font-size: calc(3em + 4vw); /* Larger */
      color: var(--color-border); /* Purple */
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
      margin-bottom: 30px;
      letter-spacing: 3px;
      font-family: 'Creepster', cursive; /* Keep title font */
    }
     #title-screen p {
         font-size: calc(1em + 0.6vw);
         margin-bottom: 50px;
         max-width: 90%;
         line-height: 1.8;
         color: #aaa; /* Lighter grey text */
         font-family: 'Arial', sans-serif; /* Readable font */
         font-weight: normal;
     }
    #start-button {
      font-size: calc(1.2em + 1.8vw);
      padding: 15px 32px;
      border-radius: 25px; /* Rounded */
      background: linear-gradient(to bottom, var(--color-spin-bg1), var(--color-spin-bg2)); /* Green */
      border: 4px solid var(--color-accent); /* Eerie Green Border */
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
      text-transform: uppercase;
      font-family: 'Arial', sans-serif; /* Readable Font */
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    #start-button:hover {
      background: linear-gradient(to bottom, #009a00, #007a00); /* Lighter green */
      box-shadow: 0 8px 16px rgba(0,0,0,0.4);
      transform: scale(1.03);
    }

  </style>
</head>
<body>

  <!-- Title Screen -->
  <div id="title-screen">
    <h1>Creepy Crypt</h1>
    <p>Dare you spin the reels of terror? Match 3, 4, or 5 ghastly ghouls and spooky symbols!<br>Use the SPIN button or summon your courage and pull the LEVER!</p>
    <button id="start-button">Enter the Crypt</button>
  </div>

  <!-- Main Game Area -->
  <div id="game-container" style="display: none;"> <!-- Hidden initially -->
      <div id="slot-machine">
        <div id="title">Creepy Crypt<span>5x5 Slots of Doom!</span></div>
        <div id="money-display">$100</div>

        <div id="reels-container">
          <!-- Reels Generated by JS -->
           <!-- Win Line Overlays - Need 12 lines for 5x5 (5H, 5V, 2D) -->
         <div class="win-line horizontal" id="line-h0"></div>
         <div class="win-line horizontal" id="line-h1"></div>
         <div class="win-line horizontal" id="line-h2"></div>
         <div class="win-line horizontal" id="line-h3"></div>
         <div class="win-line horizontal" id="line-h4"></div> <!-- Added H4 -->
         <div class="win-line vertical" id="line-v0"></div>
         <div class="win-line vertical" id="line-v1"></div>
         <div class="win-line vertical" id="line-v2"></div>
         <div class="win-line vertical" id="line-v3"></div>
         <div class="win-line vertical" id="line-v4"></div> <!-- Added V4 -->
         <div class="win-line diagonal" id="line-d0"></div> <!-- TL-BR -->
         <div class="win-line diagonal" id="line-d1"></div> <!-- TR-BL -->
        </div>

        <div id="controls">
          <label for="bet">Bet:</label>
          <input type="number" id="bet" value="5" min="1">
          <button id="maxBet">Max Bet</button>
          <button id="spin">Spin</button>
          <button id="auto">Auto</button>
          <button id="payTable">Pays</button>
          <button id="reset">Reset</button>
        </div>
        <div id="message">Disturb the crypt... if you dare...</div>
      </div>

       <!-- Lever -->
       <div id="lever-container">
           <div id="lever-handle"></div>
       </div>
  </div>

  <!-- Audio Elements (REPLACE PATHS!) -->
  <audio id="spin-sound" src="path/to/creepy_spin.mp3" preload="auto"></audio>
  <audio id="win-sound" src="path/to/spooky_chime.mp3" preload="auto"></audio>
  <audio id="big-win-sound" src="path/to/evil_laugh_win.mp3" preload="auto"></audio>
  <audio id="reel-stop-sound" src="path/to/thud_stop.mp3" preload="auto"></audio>
  <audio id="button-click-sound" src="path/to/bone_click.mp3" preload="auto"></audio>
  <audio id="lever-pull-sound" src="path/to/rusty_lever.mp3" preload="auto"></audio>


  <script>
    // --- Configuration ---
    const config = {
        money: 100,
        reelCount: 5, // <<< 5 Reels
        rowCount: 5,  // <<< 5 Rows
        symbolHeight: 70, // Match CSS --reel-height
        reelWidth: 70,    // Match CSS --reel-width
        reelGap: 8,       // Match CSS --reel-gap
        reelsPadding: 15, // Match CSS --reels-padding
        spinDurationBase: 1100, // Slightly longer base spin
        spinDurationVariance: 600,
        reelStopDelay: 150, // Slightly faster stops between reels
        autoSpinDelay: 1800, // Adjusted delay
        leverPullDuration: 450,
        bigWinMultiplierThreshold: 25, // Adjusted threshold for 5x5 payouts

        // --- SCARY SYMBOLS --- Payouts for 3, 4, 5 of a kind
        symbols: [
            // Lower Value
            { id: 'spider', emoji: 'ðŸ•·ï¸', payouts: { 3: 2, 4: 4, 5: 10 } },
            { id: 'bat', emoji: 'ðŸ¦‡', payouts: { 3: 2, 4: 5, 5: 12 } },
            { id: 'bones', emoji: 'ðŸ¦´', payouts: { 3: 3, 4: 6, 5: 15 } },
            // Medium Value
            { id: 'ghost', emoji: 'ðŸ‘»', payouts: { 3: 4, 4: 8, 5: 20 } },
            { id: 'witch', emoji: 'ðŸ§™â€â™€ï¸', payouts: { 3: 5, 4: 10, 5: 25 } },
            { id: 'zombie', emoji: 'ðŸ§Ÿâ€â™‚ï¸', payouts: { 3: 6, 4: 12, 5: 30 } },
            // Higher Value
            { id: 'vampire', emoji: 'ðŸ§›â€â™‚ï¸', payouts: { 3: 8, 4: 18, 5: 40 } },
            { id: 'frankenstein', emoji: 'ðŸ§Ÿ', payouts: { 3: 10, 4: 20, 5: 50 } }, // Note: Zombie emoji often used for Frankenstein
            { id: 'skull', emoji: 'ðŸ’€', payouts: { 3: 15, 4: 30, 5: 75 } },
            // Wild Symbol
            { id: 'pumpkin', emoji: 'ðŸŽƒ', wild: true, payouts: { 3: 25, 4: 50, 5: 150 } } // Wilds pay well
        ],
        // --- 5x5 WINNING LINES --- (12 lines total: 5H, 5V, 2D)
        winningLines: [
            // Indices 0-24 for 5x5 grid
            // Horizontals (5 lines)
            { id: 'line-h0', indices: [0, 1, 2, 3, 4] },
            { id: 'line-h1', indices: [5, 6, 7, 8, 9] },
            { id: 'line-h2', indices: [10, 11, 12, 13, 14] },
            { id: 'line-h3', indices: [15, 16, 17, 18, 19] },
            { id: 'line-h4', indices: [20, 21, 22, 23, 24] }, // New H4
            // Verticals (5 lines)
            { id: 'line-v0', indices: [0, 5, 10, 15, 20] },
            { id: 'line-v1', indices: [1, 6, 11, 16, 21] },
            { id: 'line-v2', indices: [2, 7, 12, 17, 22] },
            { id: 'line-v3', indices: [3, 8, 13, 18, 23] },
            { id: 'line-v4', indices: [4, 9, 14, 19, 24] }, // New V4
            // Diagonals (2 main lines)
            { id: 'line-d0', indices: [0, 6, 12, 18, 24] }, // TL-BR
            { id: 'line-d1', indices: [4, 8, 12, 16, 20] }  // TR-BL
        ]
    };

    // --- Game State ---
    let money = config.money;
    let currentBet = 5;
    let autoMode = false;
    let spinning = false;
    let reels = [];
    let finalSymbols = []; // Flat array [0-24] of final visible symbols
    let autoSpinTimeout = null;
    let stopPromises = [];

    // --- DOM Elements ---
    const moneyDisplay = document.getElementById('money-display');
    const reelsContainer = document.getElementById('reels-container');
    const betInput = document.getElementById('bet');
    const maxBetButton = document.getElementById('maxBet');
    const spinButton = document.getElementById('spin');
    const autoButton = document.getElementById('auto');
    const payTableButton = document.getElementById('payTable');
    const resetButton = document.getElementById('reset');
    const messageDisplay = document.getElementById('message');
    const titleScreen = document.getElementById('title-screen');
    const startButton = document.getElementById('start-button');
    const gameContainer = document.getElementById('game-container');
    const leverHandle = document.getElementById('lever-handle');
    const winLineElements = {};
    // Get the 12 win line elements
    config.winningLines.forEach(line => {
        winLineElements[line.id] = document.getElementById(line.id);
        if (!winLineElements[line.id]) console.error(`Win line element not found: ${line.id}`);
    });


    // --- Audio Elements ---
    const sounds = {
        spin: document.getElementById('spin-sound'),
        win: document.getElementById('win-sound'),
        bigWin: document.getElementById('big-win-sound'),
        reelStop: document.getElementById('reel-stop-sound'),
        click: document.getElementById('button-click-sound'),
        lever: document.getElementById('lever-pull-sound')
    };

    // --- Functions ---

    function playSound(sound) {
        if (sound && typeof sound.play === 'function') {
            sound.currentTime = 0;
            sound.play().catch(e => console.warn("Sound play failed:", e));
        }
    }

    function updateMoneyDisplay() {
      moneyDisplay.innerText = `$${money.toLocaleString()}`;
      betInput.max = money > 0 ? money : 1;
      if (parseInt(betInput.value) > money && money > 0) {
          betInput.value = money;
      } else if (money <= 0 && !spinning) {
            betInput.value = 1;
            betInput.disabled = true;
            maxBetButton.disabled = true;
      } else if (!spinning) {
          betInput.disabled = false;
          maxBetButton.disabled = false;
      }

       if (money <= 0 && !spinning) {
            disableControls(true, true);
            displayMessage("The Crypt claimed your coins! Reset?", false, true);
       }
    }


    function disableControls(disable = true, disableLever = disable) {
        spinButton.disabled = disable;
        // Max bet and bet input handled by updateMoneyDisplay
        if (!spinning) {
            autoButton.disabled = disable;
        } else if (!autoMode && disable) {
            autoButton.disabled = true;
        }

        if (leverHandle) {
            leverHandle.classList.toggle('disabled', disableLever);
        }
     }

    function displayMessage(msg, isWin = false, isBigWin = false) {
      messageDisplay.innerText = msg;
      messageDisplay.className = 'message'; // Reset classes
      if (isWin) messageDisplay.classList.add('win');
      if (isBigWin) messageDisplay.classList.add('big-win');
    }

    // Create visual symbol element using EMOJI
    function createSymbolElement(symbolData) {
        const div = document.createElement('div');
        div.classList.add('symbol');
        div.style.height = `${config.symbolHeight}px`;
        div.dataset.symbolId = symbolData.id;
        div.textContent = symbolData.emoji;
        return div;
    }

    // Build the reels visually
    function buildReels() {
      reelsContainer.innerHTML = ''; // Clear previous reels
      Object.values(winLineElements).forEach(lineEl => {
            if(lineEl) lineEl.style.display = 'none';
      });

      reels = [];

      for (let i = 0; i < config.reelCount; i++) { // Use config.reelCount (5)
        const reelElement = document.createElement('div');
        reelElement.classList.add('reel');
        reelElement.style.height = `${config.rowCount * config.symbolHeight}px`; // Use config.rowCount (5)

        const symbolsContainer = document.createElement('div');
        symbolsContainer.classList.add('symbols-container');

        const reelSymbolsData = [];
        const reelSymbolElements = [];
        // Add repetitions for visual spin pool (adjust count for 5x5)
        for (let k=0; k < 15; k++) { // Increased repetitions for taller reels
            const shuffledSymbols = [...config.symbols].sort(() => Math.random() - 0.5);
            shuffledSymbols.forEach(symbolData => {
                 const symbolElement = createSymbolElement(symbolData);
                 symbolsContainer.appendChild(symbolElement);
                 reelSymbolsData.push(symbolData);
                 reelSymbolElements.push(symbolElement);
            });
        }

        reelElement.appendChild(symbolsContainer);
        document.getElementById('reels-container').appendChild(reelElement);
        reels.push({
            element: reelElement,
            symbolsContainer: symbolsContainer,
            symbols: reelSymbolsData,
            symbolElements: reelSymbolElements,
            finalPosition: 0
        });
      }

      // Append win lines AFTER reels
      config.winningLines.forEach(line => {
            if (winLineElements[line.id]) {
                 document.getElementById('reels-container').appendChild(winLineElements[line.id]);
            }
      });

      // Set initial random positions
       reels.forEach(reel => {
          const randomIndex = Math.floor(Math.random() * reel.symbols.length);
          // Aim to center the view slightly better on load for 5 rows
          const initialY = -((randomIndex - 2 + reel.symbols.length) % reel.symbols.length) * config.symbolHeight;
          reel.symbolsContainer.style.transition = 'none';
          reel.symbolsContainer.style.transform = `translateY(${initialY}px)`;
          reel.finalPosition = initialY;
          reel.symbolsContainer.offsetHeight;
          reel.symbolsContainer.style.transition = '';
      });
    }


    // Clear highlights
    function clearHighlights() {
        document.querySelectorAll('.symbol.winning').forEach(el => el.classList.remove('winning'));
        Object.values(winLineElements).forEach(lineEl => {
            if(lineEl) lineEl.style.display = 'none';
        });
        messageDisplay.className = 'message'; // Reset message style
    }

    // Highlight winning symbols and position lines for 5x5
    function highlightWins(winningLinesInfo) {
        const containerPadding = config.reelsPadding;
        const symbolCenterY = config.symbolHeight / 2;
        const symbolCenterX = config.reelWidth / 2;
        const lineThicknessHalf = 2.5; // Half of line height/width (5px)

        winningLinesInfo.forEach(winInfo => {
            // Highlight symbols involved (up to 5)
             const indicesToHighlight = winInfo.line.indices.slice(0, winInfo.count);
             indicesToHighlight.forEach(flatIndex => {
                const reelIndex = flatIndex % config.reelCount; // 0-4
                const visibleRowIndex = Math.floor(flatIndex / config.reelCount); // 0-4
                if (reelIndex < reels.length) {
                    const reel = reels[reelIndex];
                    const topVisibleIndex = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                    const targetElementIndex = (topVisibleIndex + visibleRowIndex + reel.symbolElements.length) % reel.symbolElements.length;
                    const targetElement = reel.symbolElements[targetElementIndex];
                    if(targetElement) {
                        targetElement.classList.add('winning');
                    } else {
                         console.warn(`Target element not found for highlight: flatIndex=${flatIndex}, reelIndex=${reelIndex}, visibleRowIndex=${visibleRowIndex}, targetElementIndex=${targetElementIndex}`);
                    }
                }
            });

            // Show and position win line
            const lineElement = winLineElements[winInfo.line.id];
            if (lineElement) {
                 const totalReelWidth = config.reelCount * config.reelWidth + (config.reelCount - 1) * config.reelGap;
                 const totalReelHeight = config.rowCount * config.symbolHeight; // Assuming no vertical gap

                 if (lineElement.classList.contains('horizontal')) {
                    const rowIndex = Math.floor(winInfo.line.indices[0] / config.reelCount); // Row index 0-4
                    lineElement.style.top = `${containerPadding + (rowIndex * config.symbolHeight) + symbolCenterY - lineThicknessHalf}px`;
                    // Optional: Adjust width based on win count (3, 4, or 5)
                    // lineElement.style.width = `${winInfo.count * config.reelWidth + (winInfo.count - 1) * config.reelGap}px`;
                } else if (lineElement.classList.contains('vertical')) {
                     const colIndex = winInfo.line.indices[0] % config.reelCount; // Col index 0-4
                     lineElement.style.left = `${containerPadding + (colIndex * (config.reelWidth + config.reelGap)) + symbolCenterX - lineThicknessHalf}px`;
                     // Optional: Adjust height based on win count
                     // lineElement.style.height = `${winInfo.count * config.symbolHeight}px`;
                } else if (lineElement.id === 'line-d0') { // TL-BR Diagonal
                     const angle = Math.atan2(totalReelHeight, totalReelWidth) * (180 / Math.PI);
                     const length = Math.sqrt(totalReelWidth * totalReelWidth + totalReelHeight * totalReelHeight);
                     lineElement.style.height = `${length}px`;
                     lineElement.style.top = `${containerPadding + symbolCenterY - lineThicknessHalf}px`;
                     lineElement.style.left = `${containerPadding + symbolCenterX - lineThicknessHalf}px`;
                     lineElement.style.transform = `rotate(${angle}deg)`;
                     lineElement.style.transformOrigin = `top left`;
                } else if (lineElement.id === 'line-d1') { // TR-BL Diagonal
                    const angle = Math.atan2(totalReelHeight, totalReelWidth) * (180 / Math.PI);
                    const length = Math.sqrt(totalReelWidth * totalReelWidth + totalReelHeight * totalReelHeight);
                    lineElement.style.height = `${length}px`;
                    lineElement.style.top = `${containerPadding + symbolCenterY - lineThicknessHalf}px`;
                    lineElement.style.left = `calc(${containerPadding + totalReelWidth + symbolCenterX - lineThicknessHalf}px)`;
                    lineElement.style.transform = `rotate(-${angle}deg)`;
                    lineElement.style.transformOrigin = `top right`;
                }
                lineElement.style.display = 'block';
            } else {
                 console.warn(`Win line element DOM node not found for ID: ${winInfo.line.id}`);
            }
        });
    }


    // Evaluate the final 5x5 grid state for 3, 4, or 5 of a kind
    function evaluateResult() {
        let totalWinnings = 0;
        let winningLinesInfo = [];
        let isBigWinOverall = false;
        let highestMultiplierAchieved = 0;

        // Get final VISIBLE symbols [0-24]
        finalSymbols = [];
        for (let r = 0; r < config.rowCount; r++) { // 0-4
            for (let c = 0; c < config.reelCount; c++) { // 0-4
                const reel = reels[c];
                const topVisibleIndex = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                const symbolIndexInReel = (topVisibleIndex + r + reel.symbols.length) % reel.symbols.length;
                finalSymbols.push(reel.symbols[symbolIndexInReel]);
            }
        }
        // console.log("Final Symbols:", finalSymbols.map(s => s?.id ?? '?'));

        config.winningLines.forEach(line => {
            const symbolsOnLineData = line.indices.map(index => finalSymbols[index]);
            if (!symbolsOnLineData.length || !symbolsOnLineData[0]) return;

            let lineSymbolToMatch = null;
            let wildCountStart = 0;
            let firstNonWildIndex = -1;

            // Find first non-wild symbol
            for(let i = 0; i < symbolsOnLineData.length; i++) {
                if (symbolsOnLineData[i] && !symbolsOnLineData[i].wild) {
                    lineSymbolToMatch = symbolsOnLineData[i];
                    firstNonWildIndex = i;
                    break;
                } else if (symbolsOnLineData[i] && symbolsOnLineData[i].wild) {
                     wildCountStart++;
                } else {
                    break;
                }
            }

            // Handle all-wild line
            if (!lineSymbolToMatch && wildCountStart > 0) {
                 lineSymbolToMatch = symbolsOnLineData[0];
                 firstNonWildIndex = 0;
            }

            if (!lineSymbolToMatch) return; // Cannot form a win

            // Count matches including wilds
            let matchCount = 0;
            for (let i = firstNonWildIndex; i < symbolsOnLineData.length; i++) {
                 const currentSymbol = symbolsOnLineData[i];
                 if (currentSymbol && (currentSymbol.id === lineSymbolToMatch.id || currentSymbol.wild)) {
                     matchCount++;
                 } else {
                     break;
                 }
            }
            matchCount += wildCountStart; // Add leading wilds

            // Check for 3, 4, OR 5 of a kind <<< CHANGED
            if (matchCount >= 3) {
                 const symbolData = config.symbols.find(s => s.id === lineSymbolToMatch.id);
                 // Check payout exists for the exact match count (3, 4, or 5) <<< CHANGED
                 if (symbolData && symbolData.payouts && symbolData.payouts[matchCount]) {
                    const multiplier = symbolData.payouts[matchCount];
                    const winAmount = currentBet * multiplier;
                    totalWinnings += winAmount;
                    winningLinesInfo.push({
                        line: line,
                        amount: winAmount,
                        symbolId: lineSymbolToMatch.id,
                        count: matchCount // Store the number matched (3, 4, or 5)
                    });
                    if (multiplier > highestMultiplierAchieved) {
                        highestMultiplierAchieved = multiplier;
                    }
                }
             }
        });

        // --- Process Results ---
        spinning = false;

        if (totalWinnings > 0) {
            money += totalWinnings;
            if (highestMultiplierAchieved >= config.bigWinMultiplierThreshold) {
                 isBigWinOverall = true;
                 playSound(sounds.bigWin);
                 displayMessage(`!!! CRYPT CRACKED !!!\n$${totalWinnings.toLocaleString()}`, true, true);
             } else {
                 playSound(sounds.win);
                 displayMessage(`WIN! $${totalWinnings.toLocaleString()}`, true, false);
             }
            highlightWins(winningLinesInfo);
        } else {
            displayMessage("The Crypt remains sealed... Spin again?");
        }

        updateMoneyDisplay();
        disableControls(false, false);
        spinButton.innerText = "Spin";


        // Handle Auto Spin
         if (autoMode) {
             if (money >= currentBet && money > 0) {
                autoSpinTimeout = setTimeout(startSpin, config.autoSpinDelay);
             } else {
                 autoMode = false;
                 autoButton.innerText = "Auto";
                 autoButton.style.background = '';
                 autoButton.classList.remove('active');
                 displayMessage(money <= 0 ? "Out of coins! Auto stopped." : "Can't afford bet. Auto stopped.", false, money <= 0);
                 updateMoneyDisplay();
                 disableControls(money <= 0, money <= 0);
             }
         }
    }

    // Start the spinning process
    function startSpin() {
        if (spinning) return;

        clearTimeout(autoSpinTimeout);
        clearHighlights();

        currentBet = parseInt(betInput.value);
        if (isNaN(currentBet) || currentBet <= 0) {
            displayMessage("Enter a valid bet > 0, mortal!");
            if(autoMode) {
                 autoMode = false;
                 autoButton.innerText = "Auto";
                 autoButton.style.background = '';
                 autoButton.classList.remove('active');
            }
            return;
        }
        if (currentBet > money) {
            displayMessage("Not enough coins for this wager!");
             if(autoMode) {
                 autoMode = false;
                 autoButton.innerText = "Auto";
                 autoButton.style.background = '';
                 autoButton.classList.remove('active');
            }
            return;
        }

        spinning = true;
        money -= currentBet;
        updateMoneyDisplay();
        disableControls(true, true);
        spinButton.innerText = "Spinning...";
        displayMessage("The ghouls are stirring...");
        playSound(sounds.spin);

        stopPromises = [];

        // --- Animate Reels ---
        reels.forEach((reel, index) => {
            const symbolsContainer = reel.symbolsContainer;
            const currentY = reel.finalPosition || 0;
            const extraRevolutions = 5 + Math.floor(Math.random() * 5); // More revs for taller reels
            const totalSymbolsHeight = reel.symbols.length * config.symbolHeight;

            reel.element.classList.remove('stopping');
            symbolsContainer.classList.remove('stopping');

            const dynamicSpinDuration = (config.spinDurationBase + index * (config.reelStopDelay / 2)) / 1000;
            symbolsContainer.style.transition = `transform ${dynamicSpinDuration}s linear`;
            const spinTargetY = currentY - (extraRevolutions * totalSymbolsHeight) - (Math.random() * totalSymbolsHeight);
            symbolsContainer.offsetHeight;
            symbolsContainer.style.transform = `translateY(${spinTargetY}px)`;


            // --- Schedule Stop ---
             const stopDelay = config.spinDurationBase + (index * config.reelStopDelay) + (Math.random() * config.spinDurationVariance);
             const stopPromise = new Promise(resolve => {
                 setTimeout(() => {
                    const randomSymbolIndex = Math.floor(Math.random() * reel.symbols.length);
                     // Calculate final Y. Aim to center the middle row (row index 2 for 5 rows).
                     // finalY = - ( (targetIndex - desiredVisibleRowIndex + totalSymbols) % totalSymbols ) * symbolHeight
                     // Target index is randomSymbolIndex. Desired visible row is 2.
                    const finalY = -((randomSymbolIndex - 2 + reel.symbols.length) % reel.symbols.length) * config.symbolHeight;

                    reel.finalPosition = finalY;

                    reel.element.classList.add('stopping');
                    symbolsContainer.classList.add('stopping');
                    symbolsContainer.style.transform = `translateY(${finalY}px)`;
                    playSound(sounds.reelStop);

                    const transitionEndHandler = (event) => {
                        if (event.target === symbolsContainer && event.propertyName === 'transform') {
                            symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                            reel.element.classList.remove('stopping');
                            symbolsContainer.classList.remove('stopping');
                            resolve();
                        }
                    };
                    symbolsContainer.addEventListener('transitionend', transitionEndHandler);

                    // Failsafe timeout (optional but recommended)
                    setTimeout(() => {
                        // Minimal check: remove listener and resolve if not already done
                        // A proper check would need a state variable per reel.
                        symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                        resolve(); // Potentially resolves twice, Promise.all handles this ok
                    }, 1200); // Longer than stopping transition

                 }, stopDelay);
             });
             stopPromises.push(stopPromise);
        });

        // --- Wait for all reels to stop ---
        Promise.all(stopPromises).then(() => {
            // console.log("All reels stopped.");
             setTimeout(evaluateResult, 250); // Slightly longer delay before eval
        }).catch(error => {
            console.error("Error during reel stopping:", error);
            spinning = false;
            updateMoneyDisplay();
            disableControls(false, false);
            displayMessage("Spin cycle cursed! Try again.", false);
        });
    }


    // --- Event Listeners ---
    startButton.addEventListener('click', () => {
        playSound(sounds.click);
        titleScreen.style.display = 'none';
        gameContainer.style.display = 'block';
        initializeGame();
    });

    spinButton.addEventListener('click', () => {
         if (!spinning && money >= (parseInt(betInput.value) || 1) ) {
             playSound(sounds.click);
             startSpin();
         } else if (!spinning && money < (parseInt(betInput.value) || 1)) {
             playSound(sounds.click);
             displayMessage("Not enough coins for this wager!");
         }
    });

    leverHandle.addEventListener('click', () => {
        if (!spinning && !leverHandle.classList.contains('disabled') && money >= (parseInt(betInput.value) || 1)) {
             playSound(sounds.lever);
             leverHandle.classList.add('pulled');
             startSpin();
             setTimeout(() => { leverHandle.classList.remove('pulled'); }, config.leverPullDuration);
        } else if (!spinning && money < (parseInt(betInput.value) || 1)) {
            playSound(sounds.click);
             displayMessage("Not enough coins to tempt fate!");
        }
    });


    maxBetButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (!spinning) {
             const maxPossibleBet = money > 0 ? money : 1;
             betInput.value = maxPossibleBet;
             currentBet = maxPossibleBet;
        }
    });

    autoButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (spinning && autoMode) {
             // STOP AUTO
             autoMode = false;
             clearTimeout(autoSpinTimeout);
             autoButton.innerText = "Auto";
             autoButton.style.background = '';
             autoButton.classList.remove('active');
             autoButton.disabled = false;
             displayMessage("Auto-spin ending its haunting...");

        } else if (!spinning) {
            // TOGGLE AUTO ON/OFF
             if (money <= 0) {
                 displayMessage("No coins left for auto-haunting!");
                 return;
             }
             if (money < (parseInt(betInput.value) || 1)) {
                  displayMessage("Not enough coins for current bet! Auto cancelled.");
                 return;
             }

            autoMode = !autoMode;
             if (autoMode) {
                 // START AUTO
                 autoButton.innerText = "Stop Auto";
                 autoButton.style.background = 'linear-gradient(to bottom, #ff4444, #cc0000)'; // Active Red
                 autoButton.classList.add('active');
                 displayMessage("Auto-spin possesses the reels!");
                 startSpin();
             } else {
                 // STOP AUTO (when not spinning)
                 autoButton.innerText = "Auto";
                 autoButton.style.background = '';
                 autoButton.classList.remove('active');
                 displayMessage("Auto-spin exorcised.");
             }
        }
    });


    payTableButton.addEventListener('click', () => {
        playSound(sounds.click);
        let table = "CRYPT PAYOUTS (Bet x Multiplier):\n\n";
        // Add padding for 5-of-a-kind column <<< CHANGED
        table += "Symbol        | x3  | x4  | x5  \n";
        table += "----------------------------------\n";
        config.symbols.forEach(s => {
            if (s.payouts) {
                 // Adjust padding <<< CHANGED
                 const idPad = (s.id + (s.wild ? ' (WILD)' : '')).padEnd(13, ' ');
                 const p3 = (s.payouts[3] ? s.payouts[3] + 'x' : '-').padStart(3, ' ');
                 const p4 = (s.payouts[4] ? s.payouts[4] + 'x' : '-').padStart(3, ' ');
                 const p5 = (s.payouts[5] ? s.payouts[5] + 'x' : '-').padStart(3, ' '); // <<< ADDED x5
                 table += `${s.emoji} ${idPad}| ${p3} | ${p4} | ${p5}\n`; // <<< ADDED p5
            }
        });
         table += "\nðŸŽƒ Wild substitutes for all symbols.";
         table += "\nLines: 5 Horizontal, 5 Vertical, 2 Diagonal.";
        alert(table); // Use alert for simplicity, could use a modal
    });

    resetButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (confirm("Reset the crypt? Lose all progress and start with $100?")) {
             autoMode = false;
             clearTimeout(autoSpinTimeout);
             initializeGame();
        }
    });

    // Bet Input Listeners
    betInput.addEventListener('input', () => {
        let value = parseInt(betInput.value.replace(/[^0-9]/g, '')) || 1;
        value = Math.max(1, value);
        betInput.value = value;
        currentBet = value;
    });
     betInput.addEventListener('change', () => {
         let value = parseInt(betInput.value) || 1;
         value = Math.max(1, value);
         betInput.value = value;
         currentBet = value;
     });


     // --- Initialization ---
     function initializeGame() {
        money = config.money;
        currentBet = parseInt(betInput.value) || 5;
        currentBet = Math.max(1, currentBet);
        betInput.value = currentBet;
        spinning = false;
        autoMode = false;
        clearTimeout(autoSpinTimeout);
        displayMessage("Disturb the crypt... if you dare...");
        buildReels();
        updateMoneyDisplay();
        clearHighlights();
        disableControls(false, false);
        if (money <=0) disableControls(true, true);

        // Reset Auto Button State
         autoButton.innerText = "Auto";
         autoButton.style.background = '';
         autoButton.classList.remove('active');
         autoButton.disabled = (money <= 0);

        // Reset Lever State
        if(leverHandle) {
            leverHandle.classList.remove('disabled', 'pulled');
            leverHandle.classList.toggle('disabled', money <= 0);
        }
     }

     // Don't initialize until start button pressed

  </script>
</body>
</html>