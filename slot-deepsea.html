<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Abyssal Riches - Underwater Slots</title>
  <style>
    :root {
      /* --- Abyssal Riches Theme --- */
      --bg-color-main: #003366;
      --bg-color-accent: #00508e;
      --machine-border: #FFD700;
      --title-bg: linear-gradient(to bottom, #0077be, #00508e);
      --title-text-color: #f0f8ff;
      --title-shadow: rgba(255, 215, 0, 0.4);
      --money-color: #fffacd;
      --reels-bg: #004080;
      --reel-bg: #0060a0;
      --button-bg: linear-gradient(to bottom, #0096c7, #0077be);
      --button-border: #48cae4;
      --button-hover-bg: linear-gradient(to bottom, #48cae4, #0096c7);
      --spin-button-bg: linear-gradient(to bottom, #ffd700, #f0c000);
      --spin-button-border: #e0b000;
      --message-bg: rgba(0, 20, 40, 0.95);
      --message-text-color: #ade8f4;
      --message-win-color: #fffacd;
      --message-bigwin-color: #FFD700;
      --paytable-bg: rgba(0, 51, 102, 0.97);
      --paytable-text-color: #caf0f8;
      --paytable-header-bg: rgba(0, 119, 190, 0.9);

      --bonus-bg: rgba(0, 10, 25, 0.98); /* Very Dark Blue for Bonus */
      --bonus-text: #e0fbfc;
      --bonus-item-bg: #8c5221;
      --bonus-item-hover-bg: #a46831;

      --reel-width: 70px; --reel-height: 70px; --symbol-size: 45px;
      --num-reels: 5; --num-rows: 5; --reel-gap: 6px;

      --g-color1: #48cae4; --g-color2: #90e0ef; --g-color3: #caf0f8;
      --g-color4: #FFD700; --g-color5: #fffacd;
    }

    /* ... (All other keyframes and general styles from previous correct version) ... */
    @keyframes gradientTextFlowOcean{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}.animated-gradient-text-ocean{background-size:250% 250%;-webkit-background-clip:text;background-clip:text;color:transparent!important;animation:gradientTextFlowOcean 7s linear infinite;display:inline-block}@keyframes tridentWildShimmer{0%,100%{filter:drop-shadow(0 0 3px #fffacd) brightness(1.1);transform:translateY(0) rotate(-5deg)}50%{filter:drop-shadow(0 0 8px #ffd700) brightness(1.4);transform:translateY(-2px) rotate(5deg)}}.wild-symbol-animate-ocean{animation:tridentWildShimmer 2s ease-in-out infinite}@keyframes oysterScatterOpen{0%,40%,100%{transform:scale(1) rotate(0)}50%{transform:scaleX(1.1) scaleY(.95) rotate(3deg)}90%{transform:scaleX(1.05) scaleY(.98) rotate(-2deg)}}.scatter-symbol-animate-ocean{animation:oysterScatterOpen 3s cubic-bezier(.68,-.55,.27,1.55) infinite}body{margin:0;font-family:'Quicksand','Nunito',sans-serif;background:radial-gradient(circle at 50% 0%,var(--bg-color-accent) 0%,var(--bg-color-main) 100%);color:var(--paytable-text-color);display:flex;align-items:center;justify-content:center;min-height:100vh;width:100vw;overflow:hidden;box-sizing:border-box;position:relative}body::before{content:'';position:fixed;top:0;left:0;width:100%;height:100%;background-image:radial-gradient(circle at 10% 80%,rgba(144,224,239,.1) 1px,transparent 1px),radial-gradient(circle at 80% 20%,rgba(173,232,244,.1) 1px,transparent 1px),radial-gradient(circle at 50% 50%,rgba(72,202,228,.05) 2px,transparent 2px);background-size:50px 50px,70px 70px,100px 100px;animation:flowBubbles 20s linear infinite;z-index:-1}@keyframes flowBubbles{0%{background-position:0 0,0 0,0 0}100%{background-position:100px 200px,-140px 280px,200px -200px}}#app-wrapper{display:flex;width:100%;height:100%;padding:10px;box-sizing:border-box}#title-screen{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;height:100%;width:100%;background:linear-gradient(135deg,#0077be,#003366 60%,#001f3f);position:fixed;top:0;left:0;z-index:100;padding:20px;box-sizing:border-box}#title-screen .main-title-ts{font-size:clamp(2.5rem,7vw,4.5rem);font-weight:700;margin-bottom:15px;font-family:'Pacifico','Lobster',cursive;background-image:linear-gradient(90deg,var(--g-color4),var(--g-color5),#f0f8ff,var(--g-color4));text-shadow:2px 2px 5px rgba(0,0,0,.4)}#title-screen .sub-title-ts{font-size:clamp(1rem,2.2vw,1.5rem);color:#caf0f8;margin-bottom:30px;max-width:70%;line-height:1.5;font-family:'Quicksand',sans-serif;text-shadow:1px 1px 2px rgba(0,0,0,.7)}#title-screen #start-button{font-family:'Fredoka One',cursive;font-size:clamp(1.4rem,4vw,2rem);padding:12px 30px;border-radius:50px;background:linear-gradient(145deg,#ffd700,#f0c000);border:3px solid #fffacd;color:#003366;cursor:pointer;transition:all .3s ease;box-shadow:0 0 15px #ffd700,0 5px 10px rgba(0,0,0,.3);text-shadow:1px 1px 1px rgba(0,0,0,.2);text-transform:uppercase;font-weight:700}#title-screen #start-button:hover{transform:scale(1.05) rotate(-2deg);box-shadow:0 0 25px #ffd700,0 7px 15px rgba(0,0,0,.4);background:linear-gradient(145deg,#ffeb3b,#f4d03f)}#game-layout-container{display:none;flex-direction:row;width:100%;height:100%;gap:10px;align-items:stretch;box-sizing:border-box}#paytable-panel{flex:0 0 280px;background:var(--paytable-bg);border-radius:10px;padding:10px;box-shadow:0 0 10px rgba(255,215,0,.2);overflow-y:auto;border:2px solid var(--machine-border);display:flex;flex-direction:column;max-height:calc(100vh - 40px)}#paytable-panel h2{text-align:center;color:var(--machine-border);font-family:'Pacifico',cursive;font-size:1.7em;margin-top:0;margin-bottom:6px;text-shadow:1px 1px 2px var(--title-shadow)}.paytable-table{width:100%;border-collapse:collapse;margin-top:6px;font-size:.7em}.paytable-table td,.paytable-table th{border:1px solid var(--machine-border);padding:3px;text-align:center;vertical-align:middle}.paytable-table th{background-color:var(--paytable-header-bg);color:#fff;font-weight:700;font-family:'Quicksand',sans-serif}.paytable-table td{color:var(--paytable-text-color)}.paytable-symbol-emoji{font-size:18px;vertical-align:middle}.paytable-symbol-name{font-weight:700;text-transform:capitalize;font-size:.85em}.paytable-wild-info{margin-top:10px;font-size:.75em;text-align:center;color:var(--money-color);line-height:1.3}@keyframes paytableWinFlashOcean{0%,100%{background-color:transparent;transform:scale(1)}50%{background-color:var(--message-win-color);transform:scale(1.05);color:#003366!important}}.paytable-table td.paytable-win-flash{animation:paytableWinFlashOcean .8s ease-in-out infinite}#main-game-area{flex-grow:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:0;overflow:hidden;min-width:0;height:100%}#slot-machine{background:linear-gradient(145deg,#00508e,#0077be);border:4px solid var(--machine-border);border-radius:15px;padding:10px;box-shadow:0 0 20px rgba(255,215,0,.5),inset 0 0 10px rgba(0,0,0,.3);text-align:center;width:100%;height:auto;max-height:calc(100vh - 40px);box-sizing:border-box;display:flex;flex-direction:column;justify-content:space-around;position:relative;z-index:1}#title{font-size:clamp(1.5em,2.8vw,2em);font-weight:700;text-shadow:1px 1px 3px var(--title-shadow),0 0 8px var(--machine-border);background:var(--title-bg);padding:8px;margin:0 auto 10px;border-radius:10px 10px 0 0;border-bottom:3px solid var(--machine-border);line-height:1.1;letter-spacing:1px;width:95%;box-sizing:border-box;font-family:'Pacifico','Lobster',cursive}#title .main-title-ingame{background-image:linear-gradient(90deg,var(--g-color4),var(--g-color5),#f0f8ff,var(--g-color4))}#title .subtitle{font-size:clamp(.45em,1.1vw,.65em);color:#e0fbfc;font-weight:400;display:block;margin-top:5px;text-shadow:1px 1px 1px rgba(0,0,0,.5);line-height:1.3;font-family:'Quicksand',sans-serif}#money-display{font-size:clamp(1.3em,2.1vw,1.6em);margin:8px 0;color:var(--money-color);text-shadow:0 0 5px #000,0 0 3px var(--money-color);background-color:rgba(0,30,60,.9);padding:7px 12px;border-radius:8px;display:inline-block;border:1px solid var(--money-color);font-weight:700;font-family:'Fredoka One',sans-serif}#reels-container{display:grid;grid-template-columns:repeat(var(--num-reels),var(--reel-width));grid-gap:var(--reel-gap);justify-content:center;margin-bottom:10px;background:var(--reels-bg);padding:8px;border-radius:8px;border:1px solid var(--machine-border);height:calc(var(--num-rows) * var(--reel-height));position:relative;align-self:center;box-shadow:inset 0 0 10px rgba(0,0,0,.5),0 0 5px rgba(255,215,0,.3)}.reel{width:var(--reel-width);height:calc(var(--num-rows) * var(--reel-height));overflow:hidden;background:var(--reel-bg);border-radius:5px;position:relative;box-shadow:inset 0 0 5px rgba(0,0,0,.4)}.symbols-container{position:absolute;top:0;left:0;width:100%}.reel.spinning .symbols-container{transition:transform .08s linear;filter:blur(1.2px) brightness(1.15) contrast(.9)}.reel.stopping .symbols-container{transition:transform .65s cubic-bezier(.1,.75,.2,1);filter:blur(0)}.symbol{width:var(--reel-width);height:var(--reel-height);display:flex;align-items:center;justify-content:center;font-size:var(--symbol-size);position:relative;box-sizing:border-box;line-height:1;text-shadow:0 0 2px rgba(0,100,150,.5),0 0 4px var(--machine-border);user-select:none;color:#f0f8ff}@keyframes symbolWinFlashOcean{0%,100%{transform:scale(1);opacity:1;filter:brightness(1) drop-shadow(0 0 2px var(--machine-border))}30%{transform:scale(1.1);opacity:.95;filter:brightness(1.3) drop-shadow(0 0 5px var(--message-win-color)) drop-shadow(0 0 8px #fff)}60%{transform:scale(.95);opacity:.9;filter:brightness(1.1) drop-shadow(0 0 3px var(--message-win-color))}}.symbol.winning{animation:symbolWinFlashOcean .7s ease-in-out infinite;z-index:10;outline:1.5px solid var(--message-win-color);background-color:rgba(173,232,244,.15);outline-offset:-1.5px}#controls{margin:10px 0 8px;display:flex;flex-wrap:wrap;justify-content:center;gap:clamp(4px,.8vw,8px)}#controls button,#controls input{font-family:'Fredoka One','Quicksand',cursive;font-size:clamp(.75em,1.2vw,.9em);padding:clamp(7px,.9vw,9px) clamp(10px,1.5vw,14px);margin:clamp(2px,.4vw,3px);border-radius:20px;border:1px solid var(--button-border);background:var(--button-bg);color:#f0f8ff;cursor:pointer;transition:all .15s ease-out;box-shadow:0 2px 0 #00508e,0 3px 4px rgba(0,0,0,.4);text-shadow:1px 1px 1px rgba(0,0,0,.6);font-weight:700;text-transform:uppercase}#controls input{width:clamp(55px,8vw,65px);text-align:center;background:#002b5c;color:#e0f8ff;text-shadow:none;border-color:var(--machine-border)}#controls button:hover:not(:disabled){background:var(--button-hover-bg);transform:translateY(-2px) scale(1.02);box-shadow:0 3px 0 #00508e,0 4px 6px rgba(0,0,0,.5),0 0 5px var(--button-border)}#spin{font-size:clamp(.85em,1.5vw,1em);padding:clamp(8px,1.2vw,11px) clamp(18px,2.2vw,20px);background:var(--spin-button-bg);border-color:var(--spin-button-border);color:#4d2c00;text-shadow:1px 1px 0 rgba(255,255,255,.5)}#spin:hover:not(:disabled){background:linear-gradient(to bottom,#ffeb3b,#f4d03f);border-color:#e0b000;box-shadow:0 0 10px #ffd700}#maxBet{background:linear-gradient(to bottom,#ff8c00,#f4500);border-color:#c50;color:#fff}#message{font-size:clamp(.85em,1.5vw,.95em);margin-top:8px;min-height:clamp(30px,5.5vh,38px);padding:7px;background-color:var(--message-bg);border-radius:5px;color:var(--message-text-color);text-shadow:none;white-space:pre-line;line-height:1.2;border:1px solid var(--machine-border);box-shadow:inset 0 0 8px rgba(255,215,0,.3);font-weight:700;width:90%;align-self:center;box-sizing:border-box;font-family:'Quicksand',sans-serif}#message.win{color:var(--message-win-color);font-weight:700;text-shadow:0 0 4px var(--message-win-color),0 0 2px #003366}@keyframes bigWinMessagePulseOcean{0%{transform:scale(1);opacity:.9;text-shadow:0 0 6px var(--message-bigwin-color),0 0 12px #fffacd}100%{transform:scale(1.03);opacity:1;text-shadow:0 0 10px var(--message-bigwin-color),0 0 20px #fffacd,0 0 5px var(--message-bigwin-color)}}#message.big-win{font-size:clamp(1em,2vw,1.2em);color:var(--message-bigwin-color);animation:bigWinMessagePulseOcean .5s infinite alternate;font-weight:700}

    /* --- Sunken Treasure Chest Bonus Screen Styles (Ensure position: fixed) --- */
    #bonus-treasure-chest-screen {
        display: none; /* Initially hidden */
        position: fixed; /* CRITICAL for full screen overlay */
        top: 0;
        left: 0;
        width: 100vw; /* Cover full viewport width */
        height: 100vh; /* Cover full viewport height */
        background-color: var(--bonus-bg);
        color: var(--bonus-text);
        z-index: 2000; /* High z-index to be on top of everything */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: clamp(15px, 4vh, 30px);
        box-sizing: border-box;
        text-align: center;
        font-family: 'Quicksand', sans-serif;
        /* Background pattern can be kept or removed if it causes issues */
        background-image: linear-gradient(to bottom, rgba(0,20,40,0.85), rgba(0,50,80,0.92)), url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%230077be' fill-opacity='0.08'%3E%3Cpath opacity='.5' d='M96 95h4v1h-4v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9zm-1 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-9-10h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm9-10v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-9-10h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm9-10v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-9-10h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm9-10v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-9-10h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9z'/%3E%3Cpath d='M6 5V0H5v5H0v1h5v94h1V6h94V5H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        background-blend-mode: multiply;
    }
    #bonus-treasure-chest-screen h2 { font-family: 'Pacifico', cursive; font-size: clamp(1.7em, 3.8vw, 2.4em); color: var(--machine-border); text-shadow: 1px 1px 3px var(--title-shadow); margin-bottom: clamp(15px, 3vh, 25px); }
    #bonus-treasure-chest-screen p#bonus-instructions { font-size: clamp(0.9em, 2.2vw, 1.2em); margin-bottom: clamp(15px, 3vh, 25px); line-height: 1.4; }
    #treasure-chest-items-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(clamp(90px, 20vw, 130px), 1fr)); gap: clamp(15px, 3vw, 25px); width: 90%; max-width: clamp(550px, 90vw, 800px); margin-bottom: clamp(18px, 2.5vh, 22px); }
    .treasure-chest-item { background-color: var(--bonus-item-bg); background-image: linear-gradient(135deg, #a46831 25%, #8c5221 25%, #8c5221 50%, #a46831 50%, #a46831 75%, #8c5221 75%, #8c5221 100%); background-size: 40px 40px; padding: 15px; min-height: clamp(50px, 13vmin, 80px); border-radius: 8px; font-size: clamp(2.2em, 7vmin, 3.3em); color: #FFD700; cursor: pointer; transition: all 0.3s ease; border: 3px solid #654321; box-shadow: 0 0 12px #502d0f, inset 2px 2px 5px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; text-align: center; position: relative; }
    .treasure-chest-item::before { content:''; position: absolute; top:15%; left:0; width:100%; height:10%; background: #c0c0c0; opacity:0.7; }
    .treasure-chest-item::after { content:''; position: absolute; bottom:15%; left:0; width:100%; height:10%; background: #c0c0c0; opacity:0.7; }
    .treasure-chest-item:hover:not(.picked) { background-color: var(--bonus-item-hover-bg); transform: scale(1.08) translateY(-3px); box-shadow: 0 0 18px #703d1f, 0 0 8px #FFD700; }
    .treasure-chest-item.picked { opacity: 0.7; cursor: default; background-image: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3)), linear-gradient(135deg, #a46831 25%, #8c5221 25%, #8c5221 50%, #a46831 50%, #a46831 75%, #8c5221 75%, #8c5221 100%); transform: scale(0.95); box-shadow: inset 0 0 10px rgba(0,0,0,0.6); }
    .treasure-chest-item.picked::before, .treasure-chest-item.picked::after { opacity: 0.4; }
    #treasure-special-items-collected { margin-bottom: clamp(12px, 3vh, 20px); font-size: clamp(0.9em, 2vw, 1.1em); line-height: 1.5; }
    #treasure-special-items-collected span { display: inline-block; padding: 6px 12px; background-color: #00508e; border-radius: 5px; margin: 6px 10px; border: 1px solid var(--machine-border); font-size: 1em; box-shadow: 0 0 5px var(--machine-border); color: #fffacd; }
    #bonus-treasure-winnings-display { font-size: clamp(1.1em, 2.8vw, 1.6em); color: var(--money-color); font-weight: bold; margin-bottom: clamp(20px, 4vh, 35px); text-shadow: 0 0 6px var(--money-color); }
    #collect-treasure-bonus-button { padding: 10px 22px; font-size: clamp(0.9em, 2.2vw, 1.2em); font-family: 'Fredoka One', cursive; text-transform: uppercase; background: var(--spin-button-bg); border-color: var(--spin-button-border); color: #4d2c00; text-shadow: 1px 1px 0px rgba(255,255,255,0.5); cursor: pointer; border-radius: 20px; }
    @keyframes lostCityReveal { 0% { box-shadow: 0 0 10px #FFD700; transform: scale(1); } 50% { box-shadow: 0 0 50px #FFD700, 0 0 80px #fffacd, 0 0 30px #FFD700 inset; transform: scale(1.05); } 100% { box-shadow: 0 0 10px #FFD700; transform: scale(1); } }
    #bonus-treasure-chest-screen.lost-city-active { animation: lostCityReveal 1s ease-in-out 2; }

    /* Responsive adjustments */
    @media (max-width:768px){#game-layout-container{flex-direction:column;overflow-y:auto}#paytable-panel{flex:0 0 auto;max-height:250px;margin-bottom:10px}#main-game-area{justify-content:flex-start;padding-top:10px}#title{font-size:clamp(1.3em,4.5vw,1.7em)}#bonus-treasure-chest-screen h2{font-size:clamp(1.5em,5.5vw,2em)}.treasure-chest-item{font-size:clamp(2em,9vmin,2.8em)}}@media (max-height:600px) and (min-width:769px){#slot-machine{padding:5px}#title{font-size:clamp(1.3em,2.2vw,1.6em);padding:6px;margin-bottom:6px}#money-display{font-size:clamp(1.2em,1.9vw,1.5em);margin:5px 0}#reels-container{margin-bottom:6px}}@media (max-height:500px){#paytable-panel{max-height:140px}#title{display:none}#slot-machine{padding:5px}#controls button{padding:6px 9px;font-size:clamp(.7em,1.1vw,.85em)}#spin{padding:7px 12px}#bonus-treasure-chest-screen h2{font-size:clamp(1.3em,4.5vw,1.6em);margin-bottom:12px}#bonus-treasure-chest-screen p#bonus-instructions{font-size:clamp(.8em,3.3vw,1em);margin-bottom:12px}#treasure-chest-items-container{gap:10px}.treasure-chest-item{min-height:clamp(40px,11vmin,60px);font-size:clamp(1.8em,8vmin,2.5em)}}

  </style>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@400;700&family=Fredoka+One&family=Lobster&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="title-screen">
        <div class="main-title-ts animated-gradient-text-ocean">Abyssal Riches</div>
        <p class="sub-title-ts">Dive into the mysterious depths, discover ancient relics, and claim the ocean's hidden treasures! The mighty 🔱 Trident is WILD, guiding you to legendary wins!</p>
        <button id="start-button">Start Expedition!</button>
    </div>

  <div id="app-wrapper" style="display:none;">
      <div id="game-layout-container">
          <aside id="paytable-panel">
              <h2>Captain's Log</h2>
              <div id="paytable-content"></div>
          </aside>
          <main id="main-game-area">
              <div id="slot-machine">
                <div id="title">
                    <span class="main-title-ingame animated-gradient-text-ocean">Abyssal Riches</span>
                    <span class="subtitle">By Greg Seymour & AI<br>Fortune Favors the Bold Diver!</span>
                </div>
                <div id="money-display">Gold Doubloons: $100</div>
                <div id="reels-container"></div>
                <div id="controls">
                  <label for="bet">Bet:</label>
                  <input type="number" id="bet" value="5" min="1">
                  <button id="maxBet">Max Depth</button>
                  <button id="spin">Dive!</button>
                  <button id="auto">Autosub</button>
                  <button id="reset">Surface!</button>
                </div>
                <div id="message">Set your dive depth (bet) and explore the abyss!</div>
              </div>
          </main>
      </div>
  </div>

  <div id="bonus-treasure-chest-screen">
      <h2>Sunken Treasure Chests</h2>
      <p id="bonus-instructions">You have <span id="bonus-keys-left">3</span> keys 🔑 remaining. Find 3 Ancient Relics 🏺 to uncover the Lost City's Hoard!</p>
      <div id="treasure-special-items-collected">Relics: </div>
      <div id="treasure-chest-items-container"></div>
      <p id="bonus-treasure-winnings-display">Treasure Found: $0</p>
      <button id="collect-treasure-bonus-button" style="display:none;">Claim Your Booty!</button>
  </div>

  <script>
    const config = {
        money: 100,
        reelCount: 5,
        rowCount: 5,
        symbolHeight: 70,
        spinDurationBase: 650,
        spinDurationVariance: 280,
        reelStopDelay: 75,
        autoSpinDelay: 1050,
        symbols: [
            { id: 'tropical_fish', emoji: '🐠', payouts: { '3': 2,  '4': 5,   '5': 10  } },
            { id: 'pufferfish',    emoji: '🐡', payouts: { '3': 3,  '4': 7,   '5': 15  } },
            { id: 'crab',          emoji: '🦀', payouts: { '3': 4,  '4': 10,  '5': 20  } },
            { id: 'starfish',      emoji: '⭐', payouts: { '3': 5,  '4': 12,  '5': 30  } },
            { id: 'octopus',       emoji: '🐙', payouts: { '3': 8,  '4': 20,  '5': 50  } },
            { id: 'turtle',        emoji: '🐢', payouts: { '3': 15, '4': 40,  '5': 100 } },
            { id: 'dolphin',       emoji: '🐬', payouts: { '3': 20, '4': 60,  '5': 150 } },
            { id: 'oyster_scatter',emoji: '🦪', scatter: true, payouts: { '3': 5, '4': 10, '5': 25} },
            { id: 'trident_wild',  emoji: '🔱', payouts: { '3': 30, '4': 100, '5': 300 }, wild: true },
        ],
        winningLines: [
            { id: 'current-flow-1', name: 'Flow 1 (Row 1)', type: 'horizontal', indices: [0, 1, 2, 3, 4] },
            { id: 'current-flow-2', name: 'Flow 2 (Row 2)', type: 'horizontal', indices: [5, 6, 7, 8, 9] },
            { id: 'current-flow-3', name: 'Flow 3 (Row 3)', type: 'horizontal', indices: [10, 11, 12, 13, 14] },
            { id: 'current-flow-4', name: 'Flow 4 (Row 4)', type: 'horizontal', indices: [15, 16, 17, 18, 19] },
            { id: 'current-flow-5', name: 'Flow 5 (Row 5)', type: 'horizontal', indices: [20, 21, 22, 23, 24] },
            { id: 'whirlpool-diag', name: 'Whirlpool \\', type: 'fixedpath', indices: [0, 6, 12, 18, 24] },
            { id: 'riptide-diag',   name: 'Riptide /',   type: 'fixedpath', indices: [20, 16, 12, 8, 4] },
        ],
        bigWinThresholdMultiplier: 25,
        treasureChestBonus: {
            numChests: 5,
            keysPerScatterCount: { '3': 3, '4': 4, '5': 5 },
            specialItem: { id: "ancient_relic", name: "Ancient Relic", emoji: "🏺" },
            numSpecialToCollect: 3,
            lostCityHoardBonus: 300,
            chestPrizes: [
                { type: 'gold_coins', value: 5 }, { type: 'gold_coins', value: 10 }, { type: 'gold_coins', value: 15 },
                { type: 'gem', value: 25 }, { type: 'gem', value: 30 },
                { type: 'special_item' }, { type: 'special_item' }, { type: 'special_item' },
                { type: 'seaweed', value: 1 },
                { type: 'gold_coins', value: 8 },
                { type: 'gem', value: 20 },
            ],
            chestEmojis: ['❔']
        }
    };

    let money = config.money;
    let currentBet = 5;
    let autoMode = false;
    let spinning = false;
    let reels = [];
    let finalSymbols = [];
    let autoSpinTimeout = null;

    let bonusActive = false;
    let bonusKeysLeft = 0;
    let bonusTreasureCurrentWinnings = 0;
    let collectedTreasureSpecialItems = new Set();

    const moneyDisplay = document.getElementById('money-display');
    const reelsContainer = document.getElementById('reels-container');
    const betInput = document.getElementById('bet');
    const maxBetButton = document.getElementById('maxBet');
    const spinButton = document.getElementById('spin');
    const autoButton = document.getElementById('auto');
    const resetButton = document.getElementById('reset');
    const messageDisplay = document.getElementById('message');
    const titleScreen = document.getElementById('title-screen');
    const appWrapper = document.getElementById('app-wrapper');
    const gameLayoutContainer = document.getElementById('game-layout-container');
    const paytablePanelContent = document.getElementById('paytable-content');

    const bonusTreasureChestScreen = document.getElementById('bonus-treasure-chest-screen');
    const bonusKeysLeftDisplay = document.getElementById('bonus-keys-left');
    const treasureSpecialItemsCollectedDisplay = document.getElementById('treasure-special-items-collected');
    const treasureChestItemsContainer = document.getElementById('treasure-chest-items-container');
    const bonusTreasureWinningsDisplay = document.getElementById('bonus-treasure-winnings-display');
    const collectTreasureBonusButton = document.getElementById('collect-treasure-bonus-button');

    const sounds = {};

    function playSound(sound) {
        if (sound && typeof sound.play === 'function') {
            sound.currentTime = 0;
            sound.play().catch(e => console.warn("Sound play failed for " + sound.id + ":", e.message));
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function updateMoneyDisplay() {
      moneyDisplay.innerText = `Gold Doubloons: $${money.toLocaleString()}`;
      const maxBetForNextSpin = money > 0 ? money : 1;
      betInput.max = maxBetForNextSpin;
      let betValInInput = parseInt(betInput.value);
      if (isNaN(betValInInput) || betValInInput < 1) betInput.value = 1;
      else if (betValInInput > maxBetForNextSpin && money > 0) betInput.value = maxBetForNextSpin;
      else if (money <= 0 && betValInInput > 1) betInput.value = 1;
       if (money <= 0 && !spinning && !bonusActive) {
            disableControls(true, false);
            displayMessage("Treasure hold empty! 'Surface!' or $1 for a last dive.", false, false);
            if (autoMode) stopAutoSpin();
       }
    }

    function disableControls(disable = true, disableReset = disable) {
        spinButton.disabled = disable; maxBetButton.disabled = disable; betInput.disabled = disable;
        if (!spinning && !bonusActive) { autoButton.disabled = disable; }
        else {
            autoButton.disabled = true;
            if (autoMode && !disable) { autoButton.disabled = false; }
        }
        resetButton.disabled = disableReset;
        if (money <= 0 && parseInt(betInput.value) === 1 && !spinning && !bonusActive) {
            spinButton.disabled = false; betInput.disabled = true; maxBetButton.disabled = true;
        }
    }

    function displayMessage(msg, isWin = false, isBigWin = false) {
      messageDisplay.innerText = msg; messageDisplay.className = 'message';
      if (isBigWin) messageDisplay.classList.add('big-win');
      else if (isWin) messageDisplay.classList.add('win');
    }

    function createSymbolElement(symbolData) {
        const div = document.createElement('div');
        div.classList.add('symbol');
        div.dataset.symbolId = symbolData.id;
        div.textContent = symbolData.emoji;
        if (symbolData.wild) {
            div.classList.add('wild-symbol-animate-ocean');
        }
        if (symbolData.scatter) {
            div.classList.add('scatter-symbol-animate-ocean');
        }
        return div;
    }

    function buildReels() {
      reelsContainer.innerHTML = ''; reels = [];
      for (let i = 0; i < config.reelCount; i++) {
        const reelElement = document.createElement('div'); reelElement.classList.add('reel');
        const symbolsContainer = document.createElement('div'); symbolsContainer.classList.add('symbols-container');
        const reelSymbolsData = []; const reelSymbolElements = [];
        for (let k = 0; k < 30; k++) {
            const shuffledPortion = [...config.symbols].sort(() => Math.random() - 0.5);
            shuffledPortion.forEach(symbolData => {
                 const symbolElement = createSymbolElement(symbolData);
                 symbolsContainer.appendChild(symbolElement);
                 reelSymbolsData.push(symbolData); reelSymbolElements.push(symbolElement);
            });
        }
        reelElement.appendChild(symbolsContainer); reelsContainer.appendChild(reelElement);
        reels.push({ element: reelElement, symbolsContainer, symbols: reelSymbolsData, symbolElements: reelSymbolElements, finalPosition: 0, failsafeTimeout: null });
      }
      reels.forEach(reel => {
         const initialOffset = -(Math.floor(Math.random() * reel.symbols.length) * config.symbolHeight);
         reel.symbolsContainer.style.transition = 'none';
         reel.symbolsContainer.style.transform = `translateY(${initialOffset}px)`;
         reel.finalPosition = initialOffset; void reel.symbolsContainer.offsetWidth;
         reel.symbolsContainer.style.transition = '';
      });
    }

    function clearReelHighlights() { document.querySelectorAll('.symbol.winning').forEach(el => el.classList.remove('winning')); }
    function clearPaytableHighlights() { document.querySelectorAll('.paytable-table td.paytable-win-flash').forEach(el => el.classList.remove('paytable-win-flash')); }

    function highlightWinsOnReels(winningLinesInfo) {
        winningLinesInfo.forEach(winInfo => {
            if (!winInfo.indices || winInfo.indices.length === 0) return;
            winInfo.indices.forEach(gridIndex => {
                 const reelIndex = gridIndex % config.reelCount;
                 const visibleRowIndex = Math.floor(gridIndex / config.reelCount);
                 const reel = reels[reelIndex];
                 if (!reel || !reel.symbolElements || reel.symbolElements.length === 0) return;
                 const topVisibleSymbolIndex = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                 const targetSymbolIndexInElementArray = (topVisibleSymbolIndex + visibleRowIndex + reel.symbolElements.length) % reel.symbolElements.length;
                 const symbolElement = reel.symbolElements[targetSymbolIndexInElementArray];
                 if (symbolElement) symbolElement.classList.add('winning');
            });
        });
    }

    function highlightPaytableEntry(symbolId, winCount) {
        if (!symbolId) return;
        const row = paytablePanelContent.querySelector(`.paytable-table tr[data-symbol-id="${symbolId}"]`);
        if (row) {
            const cell = row.querySelector(`td[data-payout-count="${winCount.toString()}"]`);
            if (cell) cell.classList.add('paytable-win-flash');
        }
    }

    function startSpin() {
        if (spinning || bonusActive) return;
        let betForThisSpin = parseInt(betInput.value);
        if (isNaN(betForThisSpin) || betForThisSpin < 1) betForThisSpin = 1;
        const maxAffordableBet = money > 0 ? money : 1;
        if (betForThisSpin > maxAffordableBet && money > 0) betForThisSpin = maxAffordableBet;
        else if (money <= 0 && betForThisSpin > 1) betForThisSpin = 1;
        betInput.value = betForThisSpin; currentBet = betForThisSpin;
        const isFreeSpin = (money <= 0 && currentBet === 1);
        if (!isFreeSpin && currentBet > money) {
            displayMessage("Not enough doubloons for this dive!");
            if (autoMode) stopAutoSpin();
            disableControls(false, money <= 0 && parseInt(betInput.value) > 1); return;
        }
        clearTimeout(autoSpinTimeout); clearReelHighlights(); clearPaytableHighlights();
        playSound(sounds.click); spinning = true;
        if (isFreeSpin) displayMessage("Captain's last doubloon for one more dive!");
        else { money -= currentBet; displayMessage("Descending into the abyss..."); }
        updateMoneyDisplay(); disableControls(true); spinButton.innerText = "Diving...";
        playSound(sounds.spin);
        let reelsStoppedCount = 0;
        reels.forEach((reel, index) => {
            if (reel.failsafeTimeout) clearTimeout(reel.failsafeTimeout);
            const symbolsContainer = reel.symbolsContainer; const reelElement = reel.element;
            reelElement.classList.remove('stopping'); reelElement.classList.add('spinning');
            const randomSymbolIndexOnStrip = Math.floor(Math.random() * reel.symbols.length);
            reel.finalPosition = -(randomSymbolIndexOnStrip * config.symbolHeight);
            const currentY = parseFloat(symbolsContainer.style.transform.replace(/[^0-9.-]/g, '')) || 0;
            const fullRotations = Math.floor(Math.random() * 2) + 3;
            const spinDistance = (reel.symbols.length * config.symbolHeight) * fullRotations;
            symbolsContainer.style.transform = `translateY(${currentY - spinDistance}px)`;
            const totalSpinDuration = config.spinDurationBase + (index * config.reelStopDelay) + (Math.random() * config.spinDurationVariance);
            const stopAnimationDuration = 650;
            setTimeout(() => {
                reelElement.classList.remove('spinning'); reelElement.classList.add('stopping');
                symbolsContainer.style.transform = `translateY(${reel.finalPosition}px)`;
                playSound(sounds.reelStop);
                const transitionEndHandler = (event) => {
                    if (event.target === symbolsContainer && event.propertyName === 'transform') {
                        symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                        clearTimeout(reel.failsafeTimeout); reelElement.classList.remove('stopping');
                        reelsStoppedCount++;
                        if (reelsStoppedCount === config.reelCount) setTimeout(evaluateResult, 100);
                    }
                };
                symbolsContainer.addEventListener('transitionend', transitionEndHandler);
                reel.failsafeTimeout = setTimeout(() => {
                     if (!reelElement.classList.contains('stopping') && !spinning) return;
                     symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                     reelElement.classList.remove('stopping'); reelsStoppedCount++;
                     if (reelsStoppedCount === config.reelCount) setTimeout(evaluateResult, 100);
                }, stopAnimationDuration + 200);
            }, totalSpinDuration - stopAnimationDuration);
        });
    }

    function evaluateResult() {
        let totalWinningsFromSpin = 0; let combinedWinningLinesInfo = []; let isBigWinOverall = false;
        const scatterSymbolData = config.symbols.find(s => s.scatter);
        let bonusTriggeredThisSpin = false; let bonusTriggerCount = 0;
        finalSymbols = [];
         for (let r = 0; r < config.rowCount; r++) {
            for (let c = 0; c < config.reelCount; c++) {
                const reel = reels[c];
                if (!reel || !reel.symbols) { finalSymbols.push({id: "error", emoji: "❓"}); continue; }
                const topVisibleSymbolIndexOnStrip = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                const symbolIndexInDataArray = (topVisibleSymbolIndexOnStrip + r + reel.symbols.length) % reel.symbols.length;
                if (reel.symbols[symbolIndexInDataArray]) finalSymbols.push(reel.symbols[symbolIndexInDataArray]);
                else finalSymbols.push({id: "error", emoji: "❓"});
            }
        }
        config.winningLines.forEach(line => {
            let bestWinOnThisLine = { amount: 0, count: 0, symbolId: null, indices: [], multiplier: 0, lineName: line.name || line.id };
            config.symbols.forEach(symbolToCheck => {
                if (!symbolToCheck.payouts) return;
                const checkSymbolId = symbolToCheck.id; const isWildTypeBeingChecked = symbolToCheck.wild;
                for (let len = config.reelCount; len >= 3; len--) {
                    let startPositions = [0];
                    if (line.type === 'horizontal') {
                        startPositions = [];
                        for (let s = 0; s <= config.reelCount - len; s++) startPositions.push(s);
                    }
                    for (const start of startPositions) {
                        const currentSegmentIndicesOnLine = line.indices.slice(start, start + len);
                        if (currentSegmentIndicesOnLine.length < len) continue;
                        const groupSymbolsData = currentSegmentIndicesOnLine.map(globalIndex => finalSymbols[globalIndex]).filter(s => s);
                        if (groupSymbolsData.length < len) continue;
                        if (checkAdjacentGroup(groupSymbolsData, checkSymbolId, len, isWildTypeBeingChecked)) {
                            const payoutKey = len.toString();
                            if (symbolToCheck.payouts[payoutKey]) {
                                const lineMultiplier = symbolToCheck.payouts[payoutKey];
                                const amount = currentBet * lineMultiplier;
                                if (amount > bestWinOnThisLine.amount) {
                                    bestWinOnThisLine = { amount, count: len, symbolId: checkSymbolId, indices: currentSegmentIndicesOnLine, multiplier: lineMultiplier, lineName: line.name || line.id };
                                }
                            }
                        }
                    }
                    if (bestWinOnThisLine.symbolId === checkSymbolId && bestWinOnThisLine.count === len) break;
                }
            });
            if (bestWinOnThisLine.amount > 0) {
                const isDuplicate = combinedWinningLinesInfo.some(ex => ex.symbolId === bestWinOnThisLine.symbolId && ex.count === bestWinOnThisLine.count && ex.indices.every((v,i) => v === bestWinOnThisLine.indices[i]));
                if (!isDuplicate) {
                    totalWinningsFromSpin += bestWinOnThisLine.amount;
                    combinedWinningLinesInfo.push(bestWinOnThisLine);
                    if (bestWinOnThisLine.multiplier >= config.bigWinThresholdMultiplier) isBigWinOverall = true;
                    if (scatterSymbolData && bestWinOnThisLine.symbolId === scatterSymbolData.id && bestWinOnThisLine.count >= 3) {
                        bonusTriggeredThisSpin = true;
                        bonusTriggerCount = Math.max(bonusTriggerCount, bestWinOnThisLine.count);
                    }
                }
            }
        });
        spinning = false;
        if (bonusTriggeredThisSpin && scatterSymbolData) {
            playSound(sounds.scatterTrigger);
            if (totalWinningsFromSpin > 0) money += totalWinningsFromSpin;
            updateMoneyDisplay();
            displayMessage(`Shimmering Oysters! ${bonusTriggerCount}x ${scatterSymbolData.emoji} reveals the path to Sunken Treasure!`, true, false);
            if(combinedWinningLinesInfo.length > 0) {
                 highlightWinsOnReels(combinedWinningLinesInfo.filter(info => info.indices && info.indices.length > 0));
                 combinedWinningLinesInfo.forEach(winInfo => { if (winInfo.symbolId) highlightPaytableEntry(winInfo.symbolId, winInfo.count); });
            }
            setTimeout(() => triggerTreasureChestBonus(bonusTriggerCount), 2200);
            return;
        }
        processEndOfSpin(totalWinningsFromSpin, combinedWinningLinesInfo, isBigWinOverall);
    }

    function processEndOfSpin(currentSpinWinnings, linesInfo, isBigWin) {
        const isFreeSpinLosing = (money <= 0 && currentBet === 1 && currentSpinWinnings <= 0 && (money + currentBet) === 1);
        if (currentSpinWinnings > 0) {
            money += currentSpinWinnings; let winMessageText = "";
            const uniqueLineWins = linesInfo.filter(info => info.amount > 0);
            if (uniqueLineWins.length > 0) {
                winMessageText = isBigWin ? `!!! LEGENDARY HAUL !!!\n` : "Rich Discovery!\n";
                uniqueLineWins.forEach(info => {
                    const displayName = info.symbolId ? info.symbolId.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : "Discovery";
                    winMessageText += `${info.count}x ${displayName} (${info.lineName}) = $${info.amount.toLocaleString()}\n`;
                });
                winMessageText += `Total This Dive: $${currentSpinWinnings.toLocaleString()}`;
            }
            if (winMessageText) {
                displayMessage(winMessageText, true, isBigWin);
                if (isBigWin) playSound(sounds.bigWin); else playSound(sounds.win);
            }
            if(linesInfo.length > 0) {
                highlightWinsOnReels(linesInfo.filter(info => info.indices && info.indices.length > 0));
                linesInfo.forEach(winInfo => { if (winInfo.symbolId) highlightPaytableEntry(winInfo.symbolId, winInfo.count); });
            }
        } else if (!bonusActive && !isFreeSpinLosing) { displayMessage("Empty nets... The ocean keeps its secrets."); }
        updateMoneyDisplay();
        if (!bonusActive) disableControls(false, money <= 0 && parseInt(betInput.value) > 1);
        spinButton.innerText = "Dive!";
        if (autoMode && !bonusActive) {
            let nextBetForAuto = parseInt(betInput.value); if(isNaN(nextBetForAuto)||nextBetForAuto<1) nextBetForAuto=1;
            const canAffordNext = (money >= nextBetForAuto && money > 0) || (money <= 0 && nextBetForAuto === 1);
            if (canAffordNext) autoSpinTimeout = setTimeout(startSpin, config.autoSpinDelay);
            else { stopAutoSpin(); displayMessage(money <= 0 ? "Treasure hold empty! Autosub disengaged." : "Not enough doubloons for Autosub. Stopped.", false, money <= 0); }
         }
    }
    function checkAdjacentGroup(groupSymbolsData, checkSymbolId, requiredCount, isWildTypeBeingChecked) {
        if (groupSymbolsData.length !== requiredCount || groupSymbolsData.some(s => !s)) return false;
        for (let i = 0; i < requiredCount; i++) {
            const symbol = groupSymbolsData[i];
            if (isWildTypeBeingChecked) { if (!symbol.wild) return false; }
            else { if (symbol.id !== checkSymbolId && !symbol.wild) return false; }
        } return true;
    }
    function stopAutoSpin() {
        autoMode = false; clearTimeout(autoSpinTimeout); autoButton.innerText = "Autosub"; autoButton.style.background = '';
        if (!spinning && !bonusActive) disableControls(false, money <= 0 && parseInt(betInput.value) > 1);
    }
    function generateSidePayTable() {
        paytablePanelContent.innerHTML = ''; const table = document.createElement('table'); table.classList.add('paytable-table');
        const thead = table.createTHead(); const headerRow = thead.insertRow();
        const headers = ['Echo', 'Creature/Find', '3x', '4x', '5x'];
        headers.forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });
        const tbody = table.createTBody();
        config.symbols.forEach(symbolData => {
            if (symbolData.payouts) {
                const row = tbody.insertRow(); row.dataset.symbolId = symbolData.id;
                const emojiCell = row.insertCell(); emojiCell.textContent = symbolData.emoji; emojiCell.classList.add('paytable-symbol-emoji');
                if (symbolData.wild) emojiCell.classList.add('wild-symbol-animate-ocean');
                if (symbolData.scatter) emojiCell.classList.add('scatter-symbol-animate-ocean');
                const nameCell = row.insertCell(); let symbolNameText = symbolData.id.replace(/_/g, ' ');
                if (symbolData.wild) symbolNameText += " (Wild)"; if (symbolData.scatter) symbolNameText += " (Scatter)";
                nameCell.textContent = symbolNameText; nameCell.classList.add('paytable-symbol-name');
                const p3=symbolData.payouts['3']||0, p4=symbolData.payouts['4']||0, p5=symbolData.payouts['5']||0;
                const p3Cell = row.insertCell(); p3Cell.textContent = p3>0?`${p3}x`:'-'; if(p3>0)p3Cell.dataset.payoutCount="3";
                const p4Cell = row.insertCell(); p4Cell.textContent = p4>0?`${p4}x`:'-'; if(p4>0)p4Cell.dataset.payoutCount="4";
                const p5Cell = row.insertCell(); p5Cell.textContent = p5>0?`${p5}x`:'-'; if(p5>0)p5Cell.dataset.payoutCount="5";
            }
        }); paytablePanelContent.appendChild(table);
        const wildSymbol = config.symbols.find(s => s.wild); const scatterSymbol = config.symbols.find(s => s.scatter);
        const wildInfoDiv = document.createElement('div'); wildInfoDiv.classList.add('paytable-wild-info'); let infoText = "";
        if (wildSymbol) infoText += `<b>${wildSymbol.emoji} ${wildSymbol.id.replace(/_/g, ' ').toUpperCase()}</b> is WILD, substitutes for all symbols.<br>`;
        if (scatterSymbol) infoText += `<b>${scatterSymbol.emoji} ${scatterSymbol.id.replace(/_/g, ' ').toUpperCase()}</b> (Scatter) 3+ on a line triggers Sunken Treasure Bonus and pays.`;
        wildInfoDiv.innerHTML = infoText || "Secrets of the Deep..."; paytablePanelContent.appendChild(wildInfoDiv);
    }
    function requestFullScreenGame() { const e=document.documentElement; if(e.requestFullscreen)e.requestFullscreen().catch(err=>console.warn(err.message)); else if(e.mozRequestFullScreen)e.mozRequestFullScreen().catch(err=>console.warn(err.message)); else if(e.webkitRequestFullscreen)e.webkitRequestFullscreen().catch(err=>console.warn(err.message)); else if(e.msRequestFullscreen)e.msRequestFullscreen().catch(err=>console.warn(err.message));}

    function triggerTreasureChestBonus(scatterCount) {
        bonusActive = true; disableControls(true);
        gameLayoutContainer.style.transition = 'opacity 0.5s ease-out'; gameLayoutContainer.style.opacity = '0.1';
        bonusTreasureChestScreen.style.display = 'flex'; bonusTreasureChestScreen.classList.remove('lost-city-active');
        bonusKeysLeft = config.treasureChestBonus.keysPerScatterCount[scatterCount.toString()] || 3;
        bonusTreasureCurrentWinnings = 0; collectedTreasureSpecialItems.clear();
        document.getElementById('bonus-keys-left').textContent = bonusKeysLeft;
        updateTreasureChestUI(); populateTreasureChestItems(); collectTreasureBonusButton.style.display = 'none';
    }
    function populateTreasureChestItems() {
        treasureChestItemsContainer.innerHTML = '';
        let chestPrizesAvailable = [...config.treasureChestBonus.chestPrizes]; shuffleArray(chestPrizesAvailable);
        let prizePool = [];
        for(let i = 0; i < config.treasureChestBonus.numChests; i++) { prizePool.push(chestPrizesAvailable[i % chestPrizesAvailable.length]); }
        let currentSpecialCount = prizePool.filter(p => p.type === 'special_item').length;
        for(let i=0; i<prizePool.length && currentSpecialCount < config.treasureChestBonus.numSpecialToCollect; i++){
            if(prizePool[i].type !== 'special_item'){ prizePool[i] = { type: 'special_item' }; currentSpecialCount++; }
        } shuffleArray(prizePool);
        for (let i = 0; i < config.treasureChestBonus.numChests; i++) {
            const chestItem = document.createElement('div'); chestItem.classList.add('treasure-chest-item');
            chestItem.textContent = config.treasureChestBonus.chestEmojis[0] || '❔';
            chestItem.dataset.outcome = JSON.stringify(prizePool[i]);
            chestItem.addEventListener('click', handleTreasureChestItemClick, { once: true });
            treasureChestItemsContainer.appendChild(chestItem);
        }
    }
    function handleTreasureChestItemClick(event) {
        if (bonusKeysLeft <= 0 || !bonusActive) return;
        const chestElement = event.currentTarget; chestElement.classList.add('picked');
        playSound(sounds.bonusPick);
        const outcome = JSON.parse(chestElement.dataset.outcome); let revealedContent = ""; let feedbackMessage = "Inside the chest: ";
        if (outcome.type === 'gold_coins') {
            const prize = outcome.value * currentBet; bonusTreasureCurrentWinnings += prize;
            revealedContent = `💰 $${prize.toLocaleString()}`; feedbackMessage += `Gold Coins worth $${prize.toLocaleString()}!`;
        } else if (outcome.type === 'gem') {
            const prize = outcome.value * currentBet; bonusTreasureCurrentWinnings += prize;
            revealedContent = `💎 $${prize.toLocaleString()}`; feedbackMessage += `A Precious Gem valued at $${prize.toLocaleString()}!`;
        } else if (outcome.type === 'special_item') {
            const special = config.treasureChestBonus.specialItem; revealedContent = special.emoji;
            if (!collectedTreasureSpecialItems.has(special.id)) {
                collectedTreasureSpecialItems.add(special.id); feedbackMessage += `An ${special.name} ${special.emoji}!`;
            } else {
                const consolationPrize = currentBet; bonusTreasureCurrentWinnings += consolationPrize;
                feedbackMessage += `Another ${special.name}. The currents shift! +$${consolationPrize.toLocaleString()}`;
            }
        } else if (outcome.type === 'seaweed') {
            const prize = outcome.value * currentBet; bonusTreasureCurrentWinnings += prize;
            revealedContent = `🌿 $${prize.toLocaleString()}`; feedbackMessage += `Just some seaweed... and $${prize.toLocaleString()}.`;
        }
        chestElement.textContent = revealedContent; chestElement.style.fontSize = "clamp(1em, 4vmin, 1.5em)";
        bonusKeysLeft--; document.getElementById('bonus-keys-left').textContent = bonusKeysLeft;
        updateTreasureChestUI(); displayMessage(feedbackMessage, true, false);
        if (collectedTreasureSpecialItems.size === config.treasureChestBonus.numSpecialToCollect || bonusKeysLeft <= 0) {
            treasureChestItemsContainer.querySelectorAll('.treasure-chest-item:not(.picked)').forEach(item => item.style.cursor = 'default');
            setTimeout(finishTreasureChestBonus, 1800);
        }
    }
    function updateTreasureChestUI() {
        bonusTreasureWinningsDisplay.textContent = `Treasure Found: $${bonusTreasureCurrentWinnings.toLocaleString()}`;
        let specialItemsHTML = `Relics: `; const specialItemConf = config.treasureChestBonus.specialItem;
        for (let i = 0; i < config.treasureChestBonus.numSpecialToCollect; i++) {
            if (i < collectedTreasureSpecialItems.size) specialItemsHTML += `<span>${specialItemConf.emoji}</span> `;
            else specialItemsHTML += `<span style="opacity:0.3;">${specialItemConf.emoji}</span> `;
        } treasureSpecialItemsCollectedDisplay.innerHTML = specialItemsHTML;
    }
    function finishTreasureChestBonus() {
        let finalBonusAmount = bonusTreasureCurrentWinnings;
        let lostCityFound = collectedTreasureSpecialItems.size === config.treasureChestBonus.numSpecialToCollect;
        if (lostCityFound) {
            const hoardPrize = config.treasureChestBonus.lostCityHoardBonus * currentBet; finalBonusAmount += hoardPrize;
            playSound(sounds.grandPrize);
            displayMessage(`LOST CITY'S HOARD UNCOVERED! +$${hoardPrize.toLocaleString()}! Total Booty: $${finalBonusAmount.toLocaleString()}`, true, true);
            bonusTreasureChestScreen.classList.add('lost-city-active');
        } else {
            displayMessage(`The depths yield their treasure! Booty: $${finalBonusAmount.toLocaleString()}`, true, finalBonusAmount > currentBet * 20);
            bonusTreasureChestScreen.classList.remove('lost-city-active');
        } money += finalBonusAmount; updateMoneyDisplay(); collectTreasureBonusButton.style.display = 'inline-block';
        treasureChestItemsContainer.querySelectorAll('.treasure-chest-item:not(.picked)').forEach(item => {
            try {
                const outcome = JSON.parse(item.dataset.outcome); let unpickedContent = "🕸️";
                if (outcome.type === 'gold_coins') unpickedContent = `💰 $${(outcome.value * currentBet)}`;
                else if (outcome.type === 'gem') unpickedContent = `💎 $${(outcome.value * currentBet)}`;
                else if (outcome.type === 'special_item') unpickedContent = config.treasureChestBonus.specialItem.emoji;
                else if (outcome.type === 'seaweed') unpickedContent = `🌿 $${(outcome.value * currentBet)}`;
                item.textContent = unpickedContent; item.style.fontSize = "clamp(1em, 4vmin, 1.5em)";
            } catch (e) { item.textContent = '🕸️'; } item.classList.add('picked');
        });
    }
    collectTreasureBonusButton.addEventListener('click', () => {
        bonusActive = false; bonusTreasureChestScreen.style.display = 'none'; bonusTreasureChestScreen.classList.remove('lost-city-active');
        gameLayoutContainer.style.opacity = '1'; gameLayoutContainer.style.transition = ''; collectTreasureBonusButton.style.display = 'none';
        disableControls(false, money <= 0 && parseInt(betInput.value) > 1); spinButton.innerText = "Dive!";
        displayMessage("The ocean's call is strong! Dive again.", false, false);
        if (autoMode) { let nextBet = parseInt(betInput.value); if(isNaN(nextBet)||nextBet<1) nextBet=1; const canAfford = (money >= nextBet && money > 0) || (money <= 0 && nextBet === 1); if (canAfford) autoSpinTimeout = setTimeout(startSpin, config.autoSpinDelay); else { stopAutoSpin(); displayMessage(money <= 0 ? "Treasure hold empty!" : "Not enough doubloons.", false, money <= 0); }}
    });
    const startButtonElement = document.getElementById('start-button');
    startButtonElement.addEventListener('click', () => { playSound(sounds.click); requestFullScreenGame(); titleScreen.style.display = 'none'; appWrapper.style.display = 'flex'; gameLayoutContainer.style.display = 'flex'; initializeGame(); });
    spinButton.addEventListener('click', () => { if (!spinning && !bonusActive) startSpin(); });
    maxBetButton.addEventListener('click', () => { playSound(sounds.click); if (!spinning && !bonusActive) { const max = money>0?money:1; betInput.value = max; updateMoneyDisplay();} });
    autoButton.addEventListener('click', () => {
        playSound(sounds.click); if (bonusActive) return;
        if (autoMode) { stopAutoSpin(); if (!spinning) displayMessage("Autosub disengaged."); }
        else {
            let betVal = parseInt(betInput.value); if(isNaN(betVal)||betVal<1) betVal=1;
            const maxAff = money>0?money:1; if(betVal>maxAff && money>0) betVal=maxAff; else if(money<=0 && betVal>1) betVal=1;
            betInput.value = betVal; const canStart = !spinning && ((money>=betVal && money>0)||(money<=0 && betVal===1));
            if(canStart){ autoMode=true; autoButton.innerText="Stop Sub"; autoButton.style.background='linear-gradient(to bottom, #ff5252, #c62828)'; displayMessage("Autosub engaged!"); startSpin();
            } else if (spinning) { autoMode=true; autoButton.innerText="Stop Sub"; autoButton.style.background='linear-gradient(to bottom, #ff5252, #c62828)'; displayMessage("Autosub will engage after current dive.");
            } else displayMessage(money<=0 ? "Treasure hold empty!" : "Not enough doubloons!");
        }
    });
    resetButton.addEventListener('click', () => {
        playSound(sounds.click); let msg = "Surface and end expedition (100 Doubloons)? All findings lost.";
        if(bonusActive || spinning) msg = "Mid-dive or exploring treasure! Sure you want to surface? This resets your expedition.";
        if (!confirm(msg)) return; if (document.fullscreenElement) document.exitFullscreen(); location.reload();
    });
    betInput.addEventListener('blur', () => { if (bonusActive || spinning) return; let n = parseInt(betInput.value); const max = money>0?money:1; if (isNaN(n)||n<1) n=1; if(n>max && money>0) n=max; else if(money<=0 && n>1) n=1; betInput.value = n; updateMoneyDisplay(); disableControls(false, money <= 0 && parseInt(betInput.value) > 1); });
    function initializeGame() {
        money = config.money; let initBet = parseInt(betInput.value); if(isNaN(initBet)||initBet<1)initBet=1;
        const maxInit = money>0?money:1; if(initBet>maxInit && money>0)initBet=maxInit; else if(money<=0 && initBet>1)initBet=1;
        betInput.value = initBet; currentBet = initBet; autoMode=false; spinning=false; bonusActive=false; clearTimeout(autoSpinTimeout);
        displayMessage("Set your dive depth (bet) and explore the abyss!");
        buildReels(); generateSidePayTable(); updateMoneyDisplay(); clearReelHighlights(); clearPaytableHighlights();
        disableControls(false, money <= 0 && currentBet > 1); autoButton.innerText = "Autosub"; autoButton.style.background = '';
        Object.values(sounds).forEach(s => { if(s && s.load) try{s.load();}catch(e){} });
    }
  </script>
</body>
</html>