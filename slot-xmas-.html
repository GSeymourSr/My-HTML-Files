<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Jingle Reels 5x3 Slots!</title>
  <style>
    :root {
      /* Grid Dimensions */
      --num-reels: 5;
      --num-rows: 3;
      /* Adjusted sizes for 5x3 grid */
      --reel-width: 90px;
      --reel-height: 90px;
      --reel-gap: 10px;
      --symbol-size: 65px; /* Larger symbols for 3 rows */

      /* Layout */
      --lever-width: 40px;
      --lever-offset: 70px;
      --machine-padding: 30px;
      --reels-padding: 20px;
      /* Recalculated for 5x3 */
      --machine-width: calc(var(--num-reels) * var(--reel-width) + (var(--num-reels) - 1) * var(--reel-gap) + 2 * var(--machine-padding));
      --reels-container-height: calc(var(--num-rows) * var(--reel-height) + 2 * var(--reels-padding));


      /* --- Jingle Reels Colors - NEW PALETTE --- */
      --color-bg-start: #a80000; /* Deep Christmas Red */
      --color-bg-end: #600000; /* Darker Red */
      --color-machine-bg1: #f0f0f0; /* Snowy White */
      --color-machine-bg2: #e0e0e0; /* Light Grey/Silver */
      --color-border: #006400; /* Dark Christmas Green */
      --color-accent: #ffd700; /* Gold */
      --color-title-text: #ffffff; /* White Text */
      --color-title-bg1: #c00000; /* Bright Red */
      --color-title-bg2: #a00000; /* Darker Bright Red */
      --color-money: #004d00; /* Dark Green for contrast on light bg */
      --color-reels-bg: #d4e6f1; /* Light Icy Blue */
      --color-reel-bg: #ffffff;
      --color-button-bg1: #d32f2f; /* Red */
      --color-button-bg2: #b71c1c; /* Darker Red */
      --color-button-border: #800000; /* Maroon */
      --color-button-hover-bg1: #e53935;
      --color-button-hover-bg2: #c62828;
      --color-button-hover-border: #600000;
      --color-spin-bg1: #2e7d32; /* Green */
      --color-spin-bg2: #1b5e20; /* Darker Green */
      --color-spin-border: var(--color-accent);
      --color-lever-handle: linear-gradient(to right, #b8860b, #8b4513); /* Gold/Brown Candy Cane-ish */
      --color-lever-ball: radial-gradient(circle at 12px 12px, #ff0000, #cc0000); /* Red Ornament */
      --color-win-line: rgba(255, 215, 0, 0.8); /* Gold Transparent */
      --color-win-shadow: rgba(200, 160, 0, 0.9); /* Dark Gold Shadow */
      --color-message-text: #333333; /* Dark Grey Text */
      --color-message-win: #006400; /* Forest Green */
      --color-message-bigwin: #ff8c00; /* Festive Orange */
      --color-title-screen-text: #f0f0f0; /* Light Grey / White */
    }

    body {
      margin: 0;
      /* Festive Font */
      font-family: 'Lobster', cursive; /* Include link or fallback */
      background: radial-gradient(circle, var(--color-bg-start), var(--color-bg-end));
      color: #fff; /* Light default text for dark bg */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    /* Include Lobster font */
    @import url('https://fonts.googleapis.com/css2?family=Lobster&display=swap');
    /* Fallback font */
    body, button, input {
        font-family: 'Lobster', cursive, 'Arial', sans-serif;
    }
    /* More readable font for specific elements */
    #money-display, #controls label, #controls input, #message, #title-screen p, #start-button, #controls button {
        font-family: 'Arial', sans-serif;
        font-weight: bold;
    }
     #title {
        font-family: 'Lobster', cursive;
        font-weight: normal;
     }


    #game-container {
      position: relative;
      padding-right: calc(var(--lever-width) + var(--lever-offset) - 20px);
    }

    #slot-machine {
      background: linear-gradient(145deg, var(--color-machine-bg1), var(--color-machine-bg2));
      border: 15px solid var(--color-border); /* Thicker Green Border */
      border-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3Epath %7B fill: none; stroke: %23ffd700; stroke-width:5px; %7D%3C/style%3E%3Cpath d='M0 0 L50 50 L0 100' /%3E%3Cpath d='M100 0 L50 50 L100 100' /%3E%3C/svg%3E") 20 / 15px / 0 round; /* Candy cane-ish border - simplified */
      border-radius: 30px;
      padding: var(--machine-padding);
      box-shadow: 0 0 40px rgba(0, 100, 0, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.2); /* Green glow */
      text-align: center;
      width: var(--machine-width);
      position: relative;
      z-index: 1;
      border: 12px ridge var(--color-border); /* Fallback if border-image fails */
    }


    #title {
      font-size: 48px; /* Larger for Lobster */
      color: var(--color-title-text);
      text-shadow: 2px 2px 0px var(--color-border), 4px 4px 0px var(--color-accent); /* Layered shadow */
      background: linear-gradient(to bottom, var(--color-title-bg1), var(--color-title-bg2));
      padding: 20px;
      margin: calc(-1 * var(--machine-padding)) calc(-1 * var(--machine-padding)) 25px calc(-1 * var(--machine-padding));
      border-radius: 18px 18px 0 0;
      border-bottom: 8px solid var(--color-border);
      line-height: 1.1;
      letter-spacing: 1px;
    }
     #title span {
        display: block;
        font-size: 22px;
        margin-top: 8px;
        color: var(--color-accent); /* Gold */
        font-family: 'Arial', sans-serif;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        letter-spacing: 1px;
     }

    #money-display {
      font-size: 28px;
      margin: 20px 0;
      color: var(--color-money);
      text-shadow: 1px 1px 2px rgba(255,255,255, 0.7);
      background-color: rgba(255,255,255,0.8); /* Light background */
      padding: 10px 18px;
      border-radius: 10px;
      display: inline-block;
      border: 3px solid var(--color-money);
    }

    #reels-container {
      display: grid;
      grid-template-columns: repeat(var(--num-reels), var(--reel-width)); /* Uses 5 */
      grid-gap: var(--reel-gap);
      justify-content: center;
      margin-bottom: 25px;
      background: var(--color-reels-bg);
      padding: var(--reels-padding);
      border-radius: 15px;
      border: 4px inset rgba(0, 0, 0, 0.15);
      box-shadow: inset 0 0 15px rgba(0,0,0,0.2);
      overflow: hidden;
      height: var(--reels-container-height); /* Uses 3 rows */
      position: relative;
    }

    .reel {
      width: var(--reel-width);
      height: calc(var(--num-rows) * var(--reel-height)); /* Uses 3 rows */
      overflow: hidden;
      background: var(--color-reel-bg);
      border-radius: 8px;
      position: relative;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.2);
    }

    .symbols-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        transition: transform 0.1s linear;
    }

    .reel.stopping .symbols-container {
      transition: transform 1s cubic-bezier(0.25, 1, 0.5, 1);
    }

    .symbol {
      width: var(--reel-width);
      height: var(--reel-height);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--symbol-size);
      position: relative;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      line-height: 1;
      color: #333;
      user-select: none;
    }

    @keyframes winFlash {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.2); filter: brightness(1.25) drop-shadow(0 0 12px var(--color-accent)); } /* Gold flash */
    }

    .symbol.winning {
      animation: winFlash 0.6s ease-in-out infinite;
      z-index: 10;
    }

    .win-line {
        position: absolute;
        background-color: var(--color-win-line);
        box-shadow: 0 0 10px 4px var(--color-win-shadow);
        z-index: 5;
        display: none;
        pointer-events: none;
        border-radius: 3px;
    }
    .win-line.horizontal {
        height: 6px;
        /* Width calculated dynamically based on win count if needed, or full width */
        width: calc(var(--num-reels) * var(--reel-width) + (var(--num-reels) - 1) * var(--reel-gap));
        left: var(--reels-padding);
    }
    .win-line.diagonal { /* Used for V-shapes, length and rotation set in JS */
        /* Height will be length, width will be thickness */
        width: 6px; /* Thickness of the line */
        /* height will be dynamic */
    }


    #controls {
      margin: 25px 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
    }

    #controls label {
        font-weight: bold;
        color: #d32f2f; /* Red label text */
        font-size: 18px;
        align-self: center;
        margin-right: -5px;
        text-transform: uppercase;
    }

    #controls input, #controls button {
      font-size: 16px;
      padding: 10px 15px;
      margin: 5px;
      border-radius: 20px;
      border: 2px solid var(--color-button-border);
      background: linear-gradient(to bottom, var(--color-button-bg1), var(--color-button-bg2));
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0,0,0,0.2);
      text-transform: uppercase;
      text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
    }
     #controls input {
        width: 70px;
        text-align: center;
        background: #fff;
        color: #555;
        text-transform: none;
        text-shadow: none;
        border: 2px solid #ccc;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
     }

    #controls button:hover:not(:disabled) {
      background: linear-gradient(to bottom, var(--color-button-hover-bg1), var(--color-button-hover-bg2));
      border-color: var(--color-button-hover-border);
      box-shadow: 0 5px 8px rgba(0,0,0,0.25);
      transform: translateY(-2px);
    }
    #controls button:active:not(:disabled) {
        transform: translateY(0px);
        box-shadow: 0 2px 3px rgba(0,0,0,0.2);
        filter: brightness(0.95);
    }
     #controls button:disabled {
         cursor: not-allowed;
         opacity: 0.6;
         filter: grayscale(50%);
         box-shadow: 0 2px 3px rgba(0,0,0,0.15);
     }

    #spin {
        background: linear-gradient(to bottom, var(--color-spin-bg1), var(--color-spin-bg2));
        border-color: var(--color-spin-border);
        color: #fff;
    }
    #spin:hover:not(:disabled) {
        background: linear-gradient(to bottom, #388e3c, #2e7d32); /* Lighter green hover */
        border-color: #a5d6a7;
    }


    #message {
      font-size: 22px;
      margin-top: 20px;
      min-height: 60px;
      padding: 15px;
      background-color: rgba(255,255,255,0.9); /* Light background for message */
      border-radius: 10px;
      color: var(--color-message-text);
      text-shadow: none;
      white-space: pre-line;
      line-height: 1.4;
      border: 1px solid rgba(0,0,0,0.1);
      font-weight: bold;
    }
    #message.win {
        color: var(--color-message-win);
    }
    #message.big-win {
        font-size: 26px;
        color: var(--color-message-bigwin);
        animation: bigWinPulse 0.7s infinite alternate;
    }

    @keyframes bigWinPulse {
        from { transform: scale(1); }
        to { transform: scale(1.03); }
    }

    #lever-container {
        position: absolute;
        top: 150px;
        left: calc(100% - var(--lever-offset) + 30px);
        width: var(--lever-width);
        height: 280px;
        z-index: 2;
    }

    #lever-handle {
        position: absolute;
        bottom: 10px;
        left: 0;
        width: var(--lever-width);
        height: 160px;
        background: var(--color-lever-handle);
        border: 4px solid #5a3405; /* Dark Brown */
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        transition: transform 0.3s ease-out, background 0.3s ease-out;
        transform-origin: bottom center;
        box-shadow: 3px 3px 6px rgba(0,0,0,0.3);
    }
    #lever-handle::after { /* Red Ornament Ball */
        content: '';
        position: absolute;
        top: -18px;
        left: 50%;
        transform: translateX(-50%);
        width: 45px;
        height: 45px;
        background: var(--color-lever-ball);
        border-radius: 50%;
        border: 3px solid #a00000; /* Dark Red border */
        box-shadow: inset -3px -3px 5px rgba(0,0,0,0.3), 1px 1px 2px rgba(255,100,100,0.4);
    }

    #lever-handle.pulled {
        transform: translateY(-60px);
        background: linear-gradient(to right, #daa520, #a0522d); /* Lighter Gold/Brown */
    }

    #lever-handle.disabled {
        cursor: not-allowed;
        opacity: 0.5;
        filter: grayscale(40%);
    }


    /* --- Title Screen (Festive Theme) --- */
    #title-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(180, 0, 0, 0.97), rgba(0, 100, 0, 0.97)); /* Red/Green Gradient */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
      color: var(--color-title-screen-text);
    }
    #title-screen h1 {
      font-size: calc(3.2em + 4vw); /* Large and festive */
      color: #fff;
      text-shadow: 3px 3px 0px var(--color-accent), 5px 5px 0px #005000; /* Gold and Dark Green Shadow */
      margin-bottom: 30px;
      letter-spacing: 2px;
      font-family: 'Lobster', cursive;
    }
     #title-screen p {
         font-size: calc(1em + 0.7vw);
         margin-bottom: 50px;
         max-width: 85%;
         line-height: 1.7;
         color: #e0e0e0; /* Light grey text */
         font-weight: normal;
     }
    #start-button {
      font-size: calc(1.3em + 1.8vw);
      padding: 16px 35px;
      border-radius: 25px;
      background: linear-gradient(to bottom, #ffd700, #f0c000); /* Gold Button */
      border: 4px solid #fff; /* White Border */
      color: #8B0000; /* Dark Red Text */
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 6px 12px rgba(0,0,0,0.25);
      text-transform: uppercase;
      font-weight: bold;
      text-shadow: 1px 1px 1px rgba(255,255,255,0.7);
    }
    #start-button:hover {
      background: linear-gradient(to bottom, #ffea00, #ffd000); /* Lighter Gold */
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
      transform: scale(1.03);
    }

  </style>
</head>
<body>

  <!-- Title Screen -->
  <div id="title-screen">
    <h1>Jingle Reels!</h1>
    <p>Spin for some holiday cheer! Match 3, 4, or 5 festive symbols.<br>Use the SPIN button or give the candy cane LEVER a jolly pull!</p>
    <button id="start-button">Start Spinnin'!</button>
  </div>

  <!-- Main Game Area -->
  <div id="game-container" style="display: none;">
      <div id="slot-machine">
        <div id="title">Jingle Reels<span>5x3 Holiday Slots!</span></div>
        <div id="money-display">$100</div>

        <div id="reels-container">
          <!-- Reels Generated by JS -->
           <!-- Win Line Overlays - 5 lines for 5x3 (3H, 2 Diagonal/V-shape) -->
         <div class="win-line horizontal" id="line-h0"></div> <!-- Top Row -->
         <div class="win-line horizontal" id="line-h1"></div> <!-- Middle Row -->
         <div class="win-line horizontal" id="line-h2"></div> <!-- Bottom Row -->
         <div class="win-line diagonal" id="line-d0"></div> <!-- V-shape -->
         <div class="win-line diagonal" id="line-d1"></div> <!-- ^-shape -->
        </div>

        <div id="controls">
          <label for="bet">Bet:</label>
          <input type="number" id="bet" value="5" min="1">
          <button id="maxBet">Max Bet</button>
          <button id="spin">Spin</button>
          <button id="auto">Auto</button>
          <button id="payTable">Pays</button>
          <button id="reset">Reset</button>
        </div>
        <div id="message">Ready for some Christmas magic?</div>
      </div>

       <div id="lever-container">
           <div id="lever-handle"></div>
       </div>
  </div>

  <!-- Audio Elements (REPLACE PATHS!) -->
  <audio id="spin-sound" src="path/to/jingle_spin.mp3" preload="auto"></audio>
  <audio id="win-sound" src="path/to/festive_chime.mp3" preload="auto"></audio>
  <audio id="big-win-sound" src="path/to/sleighbells_win.mp3" preload="auto"></audio>
  <audio id="reel-stop-sound" src="path/to/soft_thump.mp3" preload="auto"></audio>
  <audio id="button-click-sound" src="path/to/crisp_click.mp3" preload="auto"></audio>
  <audio id="lever-pull-sound" src="path/to/lever_creak_jingle.mp3" preload="auto"></audio>


  <script>
    // --- Configuration ---
    const config = {
        money: 100,
        reelCount: 5,
        rowCount: 3,
        symbolHeight: 90, // Match CSS --reel-height
        reelWidth: 90,    // Match CSS --reel-width
        reelGap: 10,      // Match CSS --reel-gap
        reelsPadding: 20, // Match CSS --reels-padding
        spinDurationBase: 1000,
        spinDurationVariance: 500,
        reelStopDelay: 160,
        autoSpinDelay: 1700,
        leverPullDuration: 400,
        bigWinMultiplierThreshold: 20,

        // --- CHRISTMAS SYMBOLS --- Payouts for 3, 4, 5 of a kind
        symbols: [
            // Lower Value
            { id: 'ornament', emoji: '🔮', payouts: { 3: 2, 4: 4, 5: 8 } }, // Using crystal ball as an ornament
            { id: 'candy-cane', emoji: '🍭', payouts: { 3: 2, 4: 5, 5: 10 } }, // Lolipop as candy cane
            { id: 'snowflake', emoji: '❄️', payouts: { 3: 3, 4: 6, 5: 12 } },
            // Medium Value
            { id: 'bell', emoji: '🔔', payouts: { 3: 4, 4: 8, 5: 18 } },
            { id: 'reindeer', emoji: '🦌', payouts: { 3: 5, 4: 10, 5: 25 } },
            { id: 'present', emoji: '🎁', payouts: { 3: 6, 4: 12, 5: 30 } },
            // Higher Value
            { id: 'tree', emoji: '🎄', payouts: { 3: 8, 4: 18, 5: 40 } },
            { id: 'santa', emoji: '🎅', payouts: { 3: 10, 4: 25, 5: 60 } },
            // Wild Symbol
            { id: 'star', emoji: '🌟', wild: true, payouts: { 3: 15, 4: 40, 5: 100 } } // Star as Wild
        ],
        // --- 5x3 WINNING LINES --- (5 lines: 3 Horizontal, 2 V-shapes)
        // Indices for 5x3 grid:
        // 0  1  2  3  4
        // 5  6  7  8  9
        // 10 11 12 13 14
        winningLines: [
            // Horizontals
            { id: 'line-h0', indices: [0, 1, 2, 3, 4], type: 'horizontal' },   // Top row
            { id: 'line-h1', indices: [5, 6, 7, 8, 9], type: 'horizontal' },   // Middle row
            { id: 'line-h2', indices: [10, 11, 12, 13, 14], type: 'horizontal' },// Bottom row
            // V-shapes (will be drawn as a straight line from path start to path end for simplicity)
            { id: 'line-d0', indices: [0, 6, 12, 8, 4], type: 'diagonal' }, // V-shape
            { id: 'line-d1', indices: [10, 6, 2, 8, 14], type: 'diagonal'} // ^-shape (inverted V)
        ]
    };

    // --- Game State ---
    let money = config.money;
    let currentBet = 5;
    let autoMode = false;
    let spinning = false;
    let reels = [];
    let finalSymbols = []; // Flat array [0-14] of final visible symbols
    let autoSpinTimeout = null;
    let stopPromises = [];

    // --- DOM Elements ---
    const moneyDisplay = document.getElementById('money-display');
    const reelsContainer = document.getElementById('reels-container');
    const betInput = document.getElementById('bet');
    const maxBetButton = document.getElementById('maxBet');
    const spinButton = document.getElementById('spin');
    const autoButton = document.getElementById('auto');
    const payTableButton = document.getElementById('payTable');
    const resetButton = document.getElementById('reset');
    const messageDisplay = document.getElementById('message');
    const titleScreen = document.getElementById('title-screen');
    const startButton = document.getElementById('start-button');
    const gameContainer = document.getElementById('game-container');
    const leverHandle = document.getElementById('lever-handle');
    const winLineElements = {};
    config.winningLines.forEach(line => {
        winLineElements[line.id] = document.getElementById(line.id);
        if (!winLineElements[line.id]) console.error(`Win line element not found: ${line.id}`);
    });


    // --- Audio Elements ---
    const sounds = {
        spin: document.getElementById('spin-sound'),
        win: document.getElementById('win-sound'),
        bigWin: document.getElementById('big-win-sound'),
        reelStop: document.getElementById('reel-stop-sound'),
        click: document.getElementById('button-click-sound'),
        lever: document.getElementById('lever-pull-sound')
    };

    // --- Functions ---

    function playSound(sound) {
        if (sound && typeof sound.play === 'function') {
            sound.currentTime = 0;
            sound.play().catch(e => console.warn("Sound play failed:", e));
        }
    }

    function updateMoneyDisplay() {
      moneyDisplay.innerText = `$${money.toLocaleString()}`;
      betInput.max = money > 0 ? money : 1;
      if (parseInt(betInput.value) > money && money > 0) {
          betInput.value = money;
      } else if (money <= 0 && !spinning) {
            betInput.value = 1;
            betInput.disabled = true;
            maxBetButton.disabled = true;
      } else if (!spinning) {
          betInput.disabled = false;
          maxBetButton.disabled = false;
      }

       if (money <= 0 && !spinning) {
            disableControls(true, true);
            displayMessage("Out of holiday funds! Reset for more cheer?", false, true);
       }
    }


    function disableControls(disable = true, disableLever = disable) {
        spinButton.disabled = disable;
        if (!spinning) {
            autoButton.disabled = disable;
        } else if (!autoMode && disable) {
            autoButton.disabled = true;
        }
        if (leverHandle) {
            leverHandle.classList.toggle('disabled', disableLever);
        }
     }

    function displayMessage(msg, isWin = false, isBigWin = false) {
      messageDisplay.innerText = msg;
      messageDisplay.className = 'message';
      if (isWin) messageDisplay.classList.add('win');
      if (isBigWin) messageDisplay.classList.add('big-win');
    }

    function createSymbolElement(symbolData) {
        const div = document.createElement('div');
        div.classList.add('symbol');
        div.style.height = `${config.symbolHeight}px`;
        div.dataset.symbolId = symbolData.id;
        div.textContent = symbolData.emoji;
        return div;
    }

    function buildReels() {
      reelsContainer.innerHTML = '';
      Object.values(winLineElements).forEach(lineEl => {
            if(lineEl) lineEl.style.display = 'none';
      });
      reels = [];

      for (let i = 0; i < config.reelCount; i++) { // 5 reels
        const reelElement = document.createElement('div');
        reelElement.classList.add('reel');
        reelElement.style.height = `${config.rowCount * config.symbolHeight}px`; // 3 rows high

        const symbolsContainer = document.createElement('div');
        symbolsContainer.classList.add('symbols-container');

        const reelSymbolsData = [];
        const reelSymbolElements = [];
        // Repetitions for 3 rows (can be fewer than for 5 rows)
        for (let k=0; k < 10; k++) { // Adjusted repetitions
            const shuffledSymbols = [...config.symbols].sort(() => Math.random() - 0.5);
            shuffledSymbols.forEach(symbolData => {
                 const symbolElement = createSymbolElement(symbolData);
                 symbolsContainer.appendChild(symbolElement);
                 reelSymbolsData.push(symbolData);
                 reelSymbolElements.push(symbolElement);
            });
        }
        reelElement.appendChild(symbolsContainer);
        document.getElementById('reels-container').appendChild(reelElement);
        reels.push({
            element: reelElement,
            symbolsContainer: symbolsContainer,
            symbols: reelSymbolsData,
            symbolElements: reelSymbolElements,
            finalPosition: 0
        });
      }

      config.winningLines.forEach(line => {
            if (winLineElements[line.id]) {
                 document.getElementById('reels-container').appendChild(winLineElements[line.id]);
            }
      });

      reels.forEach(reel => {
          const randomIndex = Math.floor(Math.random() * reel.symbols.length);
          // Center initial view for 3 rows (target row index 1)
          const initialY = -((randomIndex - 1 + reel.symbols.length) % reel.symbols.length) * config.symbolHeight;
          reel.symbolsContainer.style.transition = 'none';
          reel.symbolsContainer.style.transform = `translateY(${initialY}px)`;
          reel.finalPosition = initialY;
          reel.symbolsContainer.offsetHeight;
          reel.symbolsContainer.style.transition = '';
      });
    }

    function clearHighlights() {
        document.querySelectorAll('.symbol.winning').forEach(el => el.classList.remove('winning'));
        Object.values(winLineElements).forEach(lineEl => {
            if(lineEl) lineEl.style.display = 'none';
        });
        messageDisplay.className = 'message';
    }

    function highlightWins(winningLinesInfo) {
        const containerPadding = config.reelsPadding;
        const symbolCenterY = config.symbolHeight / 2;
        const symbolCenterX = config.reelWidth / 2;
        const lineThickness = 6; // Match CSS .win-line.horizontal height or .win-line.diagonal width

        winningLinesInfo.forEach(winInfo => {
             const indicesToHighlight = winInfo.line.indices.slice(0, winInfo.count);
             indicesToHighlight.forEach(flatIndex => {
                const reelIndex = flatIndex % config.reelCount;
                const visibleRowIndex = Math.floor(flatIndex / config.reelCount);
                if (reelIndex < reels.length) {
                    const reel = reels[reelIndex];
                    const topVisibleIndex = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                    const targetElementIndex = (topVisibleIndex + visibleRowIndex + reel.symbolElements.length) % reel.symbolElements.length;
                    const targetElement = reel.symbolElements[targetElementIndex];
                    if(targetElement) targetElement.classList.add('winning');
                }
            });

            const lineElement = winLineElements[winInfo.line.id];
            if (lineElement) {
                 if (winInfo.line.type === 'horizontal') {
                    const rowIndex = Math.floor(winInfo.line.indices[0] / config.reelCount);
                    lineElement.style.top = `${containerPadding + (rowIndex * config.symbolHeight) + symbolCenterY - (lineThickness / 2)}px`;
                    // Horizontal line width is full width by CSS
                } else if (winInfo.line.type === 'diagonal') { // For V-shapes, draw straight line from path start to path end
                    const firstSymbolPathIndex = winInfo.line.indices[0];
                    const lastSymbolPathIndex = winInfo.line.indices[winInfo.count -1]; // Use winInfo.count for partial V-shape wins

                    const firstReelIdx = firstSymbolPathIndex % config.reelCount;
                    const firstRowIdx = Math.floor(firstSymbolPathIndex / config.reelCount);
                    const firstX = containerPadding + (firstReelIdx * (config.reelWidth + config.reelGap)) + symbolCenterX;
                    const firstY = containerPadding + (firstRowIdx * config.symbolHeight) + symbolCenterY;

                    const lastReelIdx = lastSymbolPathIndex % config.reelCount;
                    const lastRowIdx = Math.floor(lastSymbolPathIndex / config.reelCount);
                    const lastX = containerPadding + (lastReelIdx * (config.reelWidth + config.reelGap)) + symbolCenterX;
                    const lastY = containerPadding + (lastRowIdx * config.symbolHeight) + symbolCenterY;

                    const dX = lastX - firstX;
                    const dY = lastY - firstY;
                    const length = Math.sqrt(dX * dX + dY * dY);
                    const angle = Math.atan2(dY, dX) * (180 / Math.PI);

                    lineElement.style.height = `${length}px`; // Use height for length for rotated line
                    lineElement.style.width = `${lineThickness}px`; // CSS var for thickness
                    lineElement.style.top = `${firstY}px`; // Top-left of line is first symbol's center
                    lineElement.style.left = `${firstX}px`;
                    lineElement.style.transform = `rotate(${angle}deg)`;
                    lineElement.style.transformOrigin = `0 ${lineThickness / 2}px`; // Rotate around the line's vertical center
                }
                lineElement.style.display = 'block';
            }
        });
    }


    function evaluateResult() {
        let totalWinnings = 0;
        let winningLinesInfo = [];
        let isBigWinOverall = false;
        let highestMultiplierAchieved = 0;

        finalSymbols = []; // Grid is 5x3 = 15 symbols (0-14)
        for (let r = 0; r < config.rowCount; r++) { // 0-2
            for (let c = 0; c < config.reelCount; c++) { // 0-4
                const reel = reels[c];
                const topVisibleIndex = Math.round(Math.abs(reel.finalPosition) / config.symbolHeight);
                const symbolIndexInReel = (topVisibleIndex + r + reel.symbols.length) % reel.symbols.length;
                finalSymbols.push(reel.symbols[symbolIndexInReel]);
            }
        }

        config.winningLines.forEach(line => {
            const symbolsOnLineData = line.indices.map(index => finalSymbols[index]);
            if (!symbolsOnLineData.length || !symbolsOnLineData[0]) return;

            let lineSymbolToMatch = null;
            let wildCountStart = 0;
            let firstNonWildIndex = -1;

            for(let i = 0; i < symbolsOnLineData.length; i++) {
                if (symbolsOnLineData[i] && !symbolsOnLineData[i].wild) {
                    lineSymbolToMatch = symbolsOnLineData[i];
                    firstNonWildIndex = i;
                    break;
                } else if (symbolsOnLineData[i] && symbolsOnLineData[i].wild) {
                     wildCountStart++;
                } else { break; }
            }

            if (!lineSymbolToMatch && wildCountStart > 0) {
                 lineSymbolToMatch = symbolsOnLineData[0];
                 firstNonWildIndex = 0;
            }
            if (!lineSymbolToMatch) return;

            let matchCount = 0;
            for (let i = firstNonWildIndex; i < symbolsOnLineData.length; i++) {
                 const currentSymbol = symbolsOnLineData[i];
                 if (currentSymbol && (currentSymbol.id === lineSymbolToMatch.id || currentSymbol.wild)) {
                     matchCount++;
                 } else { break; }
            }
            matchCount += wildCountStart;

            if (matchCount >= 3) { // Payouts for 3, 4, or 5
                 const symbolData = config.symbols.find(s => s.id === lineSymbolToMatch.id);
                 if (symbolData && symbolData.payouts && symbolData.payouts[matchCount]) {
                    const multiplier = symbolData.payouts[matchCount];
                    const winAmount = currentBet * multiplier;
                    totalWinnings += winAmount;
                    winningLinesInfo.push({ line: line, amount: winAmount, symbolId: lineSymbolToMatch.id, count: matchCount });
                    if (multiplier > highestMultiplierAchieved) highestMultiplierAchieved = multiplier;
                }
             }
        });

        spinning = false;
        if (totalWinnings > 0) {
            money += totalWinnings;
            if (highestMultiplierAchieved >= config.bigWinMultiplierThreshold) {
                 playSound(sounds.bigWin);
                 displayMessage(`!!! MERRY BIG WIN !!!\n$${totalWinnings.toLocaleString()}`, true, true);
             } else {
                 playSound(sounds.win);
                 displayMessage(`WIN! $${totalWinnings.toLocaleString()}`, true, false);
             }
            highlightWins(winningLinesInfo);
        } else {
            displayMessage("No gifts this spin... Try again!");
        }
        updateMoneyDisplay();
        disableControls(false, false);
        spinButton.innerText = "Spin";

         if (autoMode) {
             if (money >= currentBet && money > 0) {
                autoSpinTimeout = setTimeout(startSpin, config.autoSpinDelay);
             } else {
                 autoMode = false;
                 autoButton.innerText = "Auto";
                 autoButton.style.background = ''; autoButton.classList.remove('active');
                 displayMessage(money <= 0 ? "Out of funds! Auto stopped." : "Can't afford bet. Auto stopped.", false, money <= 0);
                 updateMoneyDisplay(); disableControls(money <= 0, money <= 0);
             }
         }
    }

    function startSpin() {
        if (spinning) return;
        clearTimeout(autoSpinTimeout); clearHighlights();

        currentBet = parseInt(betInput.value);
        if (isNaN(currentBet) || currentBet <= 0) {
            displayMessage("Please enter a valid bet > 0.");
            if(autoMode) { autoMode = false; autoButton.innerText = "Auto"; autoButton.style.background = ''; autoButton.classList.remove('active');}
            return;
        }
        if (currentBet > money) {
            displayMessage("Not enough holiday funds for this bet!");
             if(autoMode) { autoMode = false; autoButton.innerText = "Auto"; autoButton.style.background = ''; autoButton.classList.remove('active');}
            return;
        }

        spinning = true; money -= currentBet;
        updateMoneyDisplay(); disableControls(true, true);
        spinButton.innerText = "Spinning...";
        displayMessage("Jingle bells, jingle reels...");
        playSound(sounds.spin);
        stopPromises = [];

        reels.forEach((reel, index) => {
            const symbolsContainer = reel.symbolsContainer;
            const currentY = reel.finalPosition || 0;
            const extraRevolutions = 3 + Math.floor(Math.random() * 3); // Fewer for 3 rows
            const totalSymbolsHeight = reel.symbols.length * config.symbolHeight;

            reel.element.classList.remove('stopping'); symbolsContainer.classList.remove('stopping');
            const dynamicSpinDuration = (config.spinDurationBase + index * (config.reelStopDelay / 2)) / 1000;
            symbolsContainer.style.transition = `transform ${dynamicSpinDuration}s linear`;
            const spinTargetY = currentY - (extraRevolutions * totalSymbolsHeight) - (Math.random() * totalSymbolsHeight);
            symbolsContainer.offsetHeight; symbolsContainer.style.transform = `translateY(${spinTargetY}px)`;

             const stopDelay = config.spinDurationBase + (index * config.reelStopDelay) + (Math.random() * config.spinDurationVariance);
             const stopPromise = new Promise(resolve => {
                 setTimeout(() => {
                    const randomSymbolIndex = Math.floor(Math.random() * reel.symbols.length);
                    // For 3 rows, middle row is index 1.
                    const finalY = -((randomSymbolIndex - 1 + reel.symbols.length) % reel.symbols.length) * config.symbolHeight;
                    reel.finalPosition = finalY;
                    reel.element.classList.add('stopping'); symbolsContainer.classList.add('stopping');
                    symbolsContainer.style.transform = `translateY(${finalY}px)`;
                    playSound(sounds.reelStop);

                    const transitionEndHandler = (event) => {
                        if (event.target === symbolsContainer && event.propertyName === 'transform') {
                            symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                            reel.element.classList.remove('stopping'); symbolsContainer.classList.remove('stopping');
                            resolve();
                        }
                    };
                    symbolsContainer.addEventListener('transitionend', transitionEndHandler);
                    setTimeout(() => { // Failsafe
                        symbolsContainer.removeEventListener('transitionend', transitionEndHandler);
                        resolve();
                    }, 1200);
                 }, stopDelay);
             });
             stopPromises.push(stopPromise);
        });

        Promise.all(stopPromises).then(() => {
             setTimeout(evaluateResult, 200);
        }).catch(error => {
            console.error("Error during reel stopping:", error);
            spinning = false; updateMoneyDisplay(); disableControls(false, false);
            displayMessage("Spin cycle hit a blizzard! Try again.", false);
        });
    }


    // --- Event Listeners & Init ---
    startButton.addEventListener('click', () => {
        playSound(sounds.click);
        titleScreen.style.display = 'none';
        gameContainer.style.display = 'block';
        initializeGame();
    });

    spinButton.addEventListener('click', () => {
         if (!spinning && money >= (parseInt(betInput.value) || 1) ) { playSound(sounds.click); startSpin(); }
         else if (!spinning && money < (parseInt(betInput.value) || 1)) { playSound(sounds.click); displayMessage("Not enough funds for this spin!");}
    });

    leverHandle.addEventListener('click', () => {
        if (!spinning && !leverHandle.classList.contains('disabled') && money >= (parseInt(betInput.value) || 1)) {
             playSound(sounds.lever); leverHandle.classList.add('pulled'); startSpin();
             setTimeout(() => { leverHandle.classList.remove('pulled'); }, config.leverPullDuration);
        } else if (!spinning && money < (parseInt(betInput.value) || 1)) {
            playSound(sounds.click); displayMessage("Not enough funds to pull the lever!");
        }
    });

    maxBetButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (!spinning) { betInput.value = money > 0 ? money : 1; currentBet = parseInt(betInput.value); }
    });

    autoButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (spinning && autoMode) { // Stop auto
             autoMode = false; clearTimeout(autoSpinTimeout); autoButton.innerText = "Auto";
             autoButton.style.background = ''; autoButton.classList.remove('active'); autoButton.disabled = false;
             displayMessage("Auto-spin unwrapping...");
        } else if (!spinning) { // Toggle auto
             if (money <= 0 || money < (parseInt(betInput.value) || 1)) {
                 displayMessage(money <=0 ? "No funds for auto-spin!" : "Not enough for current bet! Auto cancelled."); return;
             }
            autoMode = !autoMode;
             if (autoMode) { // Start auto
                 autoButton.innerText = "Stop Auto"; autoButton.style.background = 'linear-gradient(to bottom, #ff6b6b, #ee3838)';
                 autoButton.classList.add('active'); displayMessage("Auto-spin spreading cheer!"); startSpin();
             } else { // Stop auto (when idle)
                 autoButton.innerText = "Auto"; autoButton.style.background = ''; autoButton.classList.remove('active');
                 displayMessage("Auto-spin packed away.");
             }
        }
    });

    payTableButton.addEventListener('click', () => {
        playSound(sounds.click);
        let table = "JINGLE PAYOUTS (Bet x Multiplier):\n\n";
        table += "Symbol        | x3  | x4  | x5  \n";
        table += "----------------------------------\n";
        config.symbols.forEach(s => {
            if (s.payouts) {
                 const idPad = (s.id + (s.wild ? ' (WILD)' : '')).padEnd(13, ' ');
                 const p3 = (s.payouts[3] ? s.payouts[3] + 'x' : '-').padStart(3, ' ');
                 const p4 = (s.payouts[4] ? s.payouts[4] + 'x' : '-').padStart(3, ' ');
                 const p5 = (s.payouts[5] ? s.payouts[5] + 'x' : '-').padStart(3, ' ');
                 table += `${s.emoji} ${idPad}| ${p3} | ${p4} | ${p5}\n`;
            }
        });
         table += "\n🌟 Wild substitutes for all symbols.";
         table += "\nLines: 3 Horizontal, 2 V-Shape.";
        alert(table);
    });

    resetButton.addEventListener('click', () => {
        playSound(sounds.click);
        if (confirm("Reset game and start with fresh holiday funds ($100)?")) {
             autoMode = false; clearTimeout(autoSpinTimeout); initializeGame();
        }
    });

    betInput.addEventListener('input', () => {
        let v = parseInt(betInput.value.replace(/[^0-9]/g, '')) || 1; v = Math.max(1, v);
        betInput.value = v; currentBet = v;
    });
     betInput.addEventListener('change', () => {
         let v = parseInt(betInput.value) || 1; v = Math.max(1, v);
         betInput.value = v; currentBet = v;
     });

     function initializeGame() {
        money = config.money; currentBet = parseInt(betInput.value) || 5;
        currentBet = Math.max(1, currentBet); betInput.value = currentBet;
        spinning = false; autoMode = false; clearTimeout(autoSpinTimeout);
        displayMessage("Ready for some Christmas magic?");
        buildReels(); updateMoneyDisplay(); clearHighlights();
        disableControls(false, false); if (money <=0) disableControls(true, true);
        autoButton.innerText = "Auto"; autoButton.style.background = '';
        autoButton.classList.remove('active'); autoButton.disabled = (money <= 0);
        if(leverHandle) {
            leverHandle.classList.remove('disabled', 'pulled');
            leverHandle.classList.toggle('disabled', money <= 0);
        }
     }
  </script>
</body>
</html>