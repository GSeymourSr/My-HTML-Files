<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spider Weaver Simulation (Guaranteed Completion)</title>
    
    <!-- ======================= CSS STYLES ======================= -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Georgia', 'Times New Roman', serif;
        }
        #simulation-canvas { display: block; }
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 10;
            transition: opacity 0.5s ease-out;
        }
        .start-text { text-align: center; color: #ecf0f1; }
        .start-text h1 { font-size: 4em; margin-bottom: 0.2em; }
        .start-text p { font-size: 1.5em; font-style: italic; }
        .start-text p.timer-info { font-size: 1em; margin-top: 2em; opacity: 0.7; }
    </style>
</head>
<body>
    <!-- ======================= HTML CONTENT ======================= -->
    <div id="start-overlay">
        <div class="start-text">
            <h1>Spider Weaver</h1>
            <p>By Greg Seymour AI</p>
            <p class.timer-info">(Wait 5 seconds! Enjoy)</p>
        </div>
    </div>
    <canvas id="simulation-canvas"></canvas>

    <!-- ================= JAVASCRIPT SIMULATION ================== -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('simulation-canvas');
            const ctx = canvas.getContext('2d');
            const startOverlay = document.getElementById('start-overlay');

            let screenWidth, screenHeight;
            let spiders = [], butterflies = [], webs = [];
            let animationFrameId, autoStartTimer, isStarted = false;

            const MAX_BUTTERFLIES = 50, MAX_SPIDERS = 100, MAX_BUILDERS_PER_WEB = 10;
            let spiderSpawnCooldown = 1;

            const BRIGHT_COLORS = ['#FF1493', '#00BFFF', '#32CD32', '#FFD700', '#FFA500', '#EE82EE', '#00FA9A', '#FF4500', '#1E90FF', '#DA70D6', '#FF69B4', '#7FFF00'];
            const colorManager = { available: [...BRIGHT_COLORS], used: [], getColor() { if (this.available.length === 0) { return BRIGHT_COLORS[Math.floor(Math.random() * BRIGHT_COLORS.length)]; } const colorIndex = Math.floor(Math.random() * this.available.length); const color = this.available.splice(colorIndex, 1)[0]; this.used.push(color); return color; }, returnColor(color) { const usedIndex = this.used.indexOf(color); if (usedIndex > -1) { this.used.splice(usedIndex, 1); this.available.push(color); } } };

            function getRandom(min, max) { return Math.random() * (max - min) + min; }
            function getRandomHSLA() { const hue = Math.random() * 360; const s = getRandom(70, 100); const l = getRandom(55, 75); return `hsla(${hue}, ${s}%, ${l}%, 1)`; }
            function resizeCanvas() { screenWidth = window.innerWidth; screenHeight = window.innerHeight; canvas.width = screenWidth; canvas.height = screenHeight; }
            
            class Butterfly { /* ... No changes to Butterfly class ... */
                constructor() { this.state = 'FLYING'; this.wrapProgress = 0; this.stuckInWeb = null; const margin = 150; const side = Math.floor(Math.random() * 4); switch (side) { case 0: this.x = getRandom(0, screenWidth); this.y = -margin; break; case 1: this.x = screenWidth + margin; this.y = getRandom(0, screenHeight); break; case 2: this.x = getRandom(0, screenWidth); this.y = screenHeight + margin; break; case 3: this.x = -margin; this.y = getRandom(0, screenHeight); break; } this.size = getRandom(4, 9); this.speed = getRandom(1.5, 3.2); this.angle = Math.random() * Math.PI * 2; this.target = { x: getRandom(50, screenWidth - 50), y: getRandom(50, screenHeight - 50) }; this.turnSpeed = 0.04; this.frontWingColor = getRandomHSLA(); this.backWingColor = getRandomHSLA(); this.frontWingAngle = Math.random() * Math.PI * 2; this.backWingAngle = Math.random() * Math.PI * 2; this.frontWingFlapSpeed = getRandom(0.1, 0.4); this.backWingFlapSpeed = getRandom(0.1, 0.4); }
                findNewTarget() { this.target = { x: getRandom(50, screenWidth - 50), y: getRandom(50, screenHeight - 50) }; }
                update() { if (this.state === 'FLYING') { this.frontWingAngle += this.frontWingFlapSpeed; this.backWingAngle += this.backWingFlapSpeed; const dx = this.target.x - this.x, dy = this.target.y - this.y; if (Math.sqrt(dx * dx + dy * dy) < 50) { this.findNewTarget(); } const targetAngle = Math.atan2(dy, dx); let angleDiff = targetAngle - this.angle; while (angleDiff < -Math.PI) angleDiff += Math.PI * 2; while (angleDiff > Math.PI) angleDiff -= Math.PI * 2; this.angle += angleDiff * this.turnSpeed; this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed; } }
                draw() { if (this.state === 'EATEN') return; let alpha = this.stuckInWeb ? this.stuckInWeb.alpha / 255.0 : 1.0; if (alpha <= 0) return; ctx.globalAlpha = alpha; ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle + Math.PI / 2); const backFlap = Math.sin(this.backWingAngle) * (Math.PI / 12); const frontFlap = Math.sin(this.frontWingAngle) * (Math.PI / 8); ctx.fillStyle = this.backWingColor; const backWingY = this.size * 0.8; ctx.beginPath(); ctx.moveTo(0, backWingY); ctx.rotate(backFlap); ctx.bezierCurveTo(this.size * 4, this.size * 2.5, this.size * 3.5, -this.size * 1.5, 0, backWingY); ctx.fill(); ctx.rotate(-backFlap); ctx.beginPath(); ctx.moveTo(0, backWingY); ctx.rotate(-backFlap); ctx.bezierCurveTo(-this.size * 4, this.size * 2.5, -this.size * 3.5, -this.size * 1.5, 0, backWingY); ctx.fill(); ctx.rotate(backFlap); ctx.fillStyle = this.frontWingColor; const frontWingY = -this.size * 0.1; ctx.beginPath(); ctx.moveTo(0, frontWingY); ctx.rotate(frontFlap); ctx.bezierCurveTo(this.size * 4.5, -this.size * 4, this.size * 4, this.size * 3, 0, frontWingY); ctx.fill(); ctx.rotate(-frontFlap); ctx.beginPath(); ctx.moveTo(0, frontWingY); ctx.rotate(-frontFlap); ctx.bezierCurveTo(-this.size * 4.5, -this.size * 4, -this.size * 4, this.size * 3, 0, frontWingY); ctx.fill(); ctx.rotate(frontFlap); ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.ellipse(0, this.size * 0.6, this.size * 0.3, this.size * 1.3, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#6B4F35'; ctx.lineWidth = 1.5; const antennaStartY = -this.size * 0.5; ctx.beginPath(); ctx.moveTo(0, antennaStartY); ctx.quadraticCurveTo(-this.size, -this.size * 2, -this.size * 0.8, -this.size * 2.2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, antennaStartY); ctx.quadraticCurveTo(this.size, -this.size * 2, this.size * 0.8, -this.size * 2.2); ctx.stroke(); ctx.restore(); if (this.state === 'WRAPPED') { ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`; ctx.lineWidth = 1; for (let i = 0; i < this.wrapProgress; i++) { const angle = i * (Math.PI / 3), wrapSize = this.size * 1.5; ctx.beginPath(); ctx.moveTo(this.x - Math.cos(angle) * wrapSize, this.y - Math.sin(angle) * wrapSize); ctx.lineTo(this.x + Math.cos(angle) * wrapSize, this.y + Math.sin(angle) * wrapSize); ctx.stroke(); } } ctx.globalAlpha = 1.0; }
            }

            class Web {
                constructor(center, ownerSpider, maxRadius) {
                    this.center = { ...center }; this.builders = [ownerSpider];
                    this.numSpokes = Math.floor(25 + Math.random() * 6); this.maxRadius = maxRadius; this.isComplete = false;
                    this.spokeLengths = Array.from({ length: this.numSpokes }, () => this.maxRadius * (0.99 + Math.random() * 0.35));
                    this.spokeAngles = Array.from({ length: this.numSpokes }, (_, i) => (2 * Math.PI * i / this.numSpokes) + (Math.random() - 0.9) * 0.2).sort();
                    this.spokes = []; this.spirals = [];
                    this.isFading = false; this.fadeStartTime = 0; this.fadeDuration = 4 + Math.random() * 4;
                    this.alpha = 255; this.caughtButterflies = [];
                    this.spokesBuilt = Array(this.numSpokes).fill(false); this.allSpokesDone = false;
                    const maxRings = Math.floor((this.maxRadius - 20) / 25) + 1;
                    this.spiralRingClaimed = Array(maxRings > 0 ? maxRings : 0).fill(false);
                }
                addBuilder(spider) { if (!this.builders.includes(spider)) { spider.builderId = this.builders.length; this.builders.push(spider); } }
                removeBuilder(spider) { const index = this.builders.indexOf(spider); if (index > -1) this.builders.splice(index, 1); if (this.builders.length === 0) this.startFading(); }
                startFading() { if (!this.isFading) { this.isFading = true; this.fadeStartTime = performance.now(); } }
                update(currentTime) { if (this.isFading) { const elapsed = (currentTime - this.fadeStartTime) / 1000; this.alpha = Math.max(0, 255 * (1 - (elapsed / this.fadeDuration))); } if (!this.allSpokesDone && this.spokesBuilt.every(s => s === true)) { this.allSpokesDone = true; } }
                draw() { if(this.alpha<=0)return;ctx.globalAlpha=this.alpha/255.0;ctx.lineWidth=0.8;this.spokes.forEach(line=>{ctx.strokeStyle=line.color;ctx.beginPath();ctx.moveTo(line.start.x,line.start.y);ctx.lineTo(line.end.x,line.end.y);ctx.stroke()});this.spirals.forEach(line=>{ctx.strokeStyle=line.color;ctx.beginPath();ctx.moveTo(line.start.x,line.start.y);ctx.lineTo(line.end.x,line.end.y);ctx.stroke()});ctx.globalAlpha=1.0}
                checkCollision(butterfly) { if (!this.isComplete || butterfly.state !== 'FLYING') return; const dist = Math.hypot(butterfly.x - this.center.x, butterfly.y - this.center.y); if (dist > 20 && dist < this.maxRadius) { if (Math.random() < (1.0 - (dist / this.maxRadius)) * 0.05) { butterfly.state = 'CAUGHT'; butterfly.stuckInWeb = this; this.caughtButterflies.push(butterfly); } } }
            }

            class Spider {
                constructor() {
                    const side = ['top', 'bottom', 'left', 'right'][Math.floor(Math.random() * 4)]; let pos = { x: 0, y: 0 }; if (side === 'top') pos = { x: Math.random() * screenWidth, y: -30 }; else if (side === 'bottom') pos = { x: Math.random() * screenWidth, y: screenHeight + 30 }; else if (side === 'left') pos = { x: -30, y: Math.random() * screenHeight }; else pos = { x: screenWidth + 30, y: Math.random() * screenHeight }; this.position = pos;
                    this.color = colorManager.getColor(); this.detailColor = this.getDarkerColor(this.color);
                    this.radius = 6 + Math.random() * 16; this.legLength = this.radius * 2.0; this.legThickness = Math.max(1, this.radius / 5); this.baseSpeed = 4.5; this.speed = this.baseSpeed;
                    this.direction = Math.random() * 2 * Math.PI; this.animationTimer = Math.random() * 2 * Math.PI; this.animationSpeed = 0.25;
                    this.state = 'ENTERING';
                    this.wanderTimer = 400 + Math.floor(Math.random() * 400); this.buildTarget = { x: screenWidth * 0.2 + Math.random() * screenWidth * 0.6, y: screenHeight * 0.2 + Math.random() * screenHeight * 0.6 };
                    this.web = null;
                    
                    this.builderId = 0; this.currentTaskIndex = 0;
                    this.spokeBuildState = 'TRAVELING_OUT'; this.lastSpiralPoint = null;
                    this.activeSpoke = null; this.activeRingIndex = -1;

                    this.butterfliesEaten = 0; this.butterfliesToEat = 7;
                    this.targetButterfly = null; this.wrapTimer = 0;
                }
                
                getDarkerColor(hex) { let r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16);r=Math.floor(r*0.6);g=Math.floor(g*0.6);b=Math.floor(b*0.6);return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`}

                update(allSpiders, allWebs) {
                    if (this.web && this.web.isComplete && this.state.includes('BUILDING')) {
                        this.state = 'RETURNING_TO_CENTER'; this.buildTarget = this.web.center; this.activeSpoke = null;
                    }
                    if (this.state !== 'IDLING_IN_WEB') { this.animationTimer += this.animationSpeed; }
                    switch (this.state) {
                        case 'ENTERING': if (this.moveTowardsTarget()) { this.state = 'WANDERING'; this.buildTarget = null; } break;
                        case 'WANDERING': this.wander(); this.wanderTimer--; this.checkForCollaboration(allSpiders); if (this.wanderTimer <= 0) this.findBuildSite(allWebs); break;
                        case 'TRAVELING_TO_SITE': if (this.moveTowardsTarget()) this.startBuilding(allWebs); break;
                        case 'TRAVELING_TO_HELP': if (this.moveTowardsTarget()) this.findNextTask(); break;
                        
                        case 'BUILDING_MY_SPOKES': this.buildMySpokes(); break;
                        case 'BUILDING_MY_SPIRAL': this.buildMySpiralRing(); break;
                        
                        case 'WAITING_FOR_SPOKES_FINISH':
                            this.moveTowardsTarget();
                            if (this.web.allSpokesDone) { this.findNextTask(); }
                            break;

                        case 'IDLING_IN_WEB': if (this.web && this.web.caughtButterflies.length > 0) { this.targetButterfly = this.web.caughtButterflies.shift(); this.state = 'HUNTING'; } break;
                        case 'HUNTING': this.buildTarget=this.targetButterfly;if(this.moveTowardsTarget(true)){this.state='WRAPPING_FLY';this.targetButterfly.state='WRAPPED';this.wrapTimer=90}break;
                        case 'WRAPPING_FLY': this.wrapTimer--;if(this.wrapTimer%15===0&&this.targetButterfly.wrapProgress<6){this.targetButterfly.wrapProgress++}if(this.wrapTimer<=0){this.butterfliesEaten++;this.targetButterfly.state='EATEN';this.targetButterfly=null;if(this.butterfliesEaten>=this.butterfliesToEat){this.state='LEAVING';this.buildTarget={x:Math.random()>0.5?-50:screenWidth+50,y:Math.random()>0.5?-50:screenHeight+50}}else{this.state='RETURNING_TO_CENTER'}}break;
                        case 'RETURNING_TO_CENTER': this.buildTarget=this.web.center;if(this.moveTowardsTarget())this.state='IDLING_IN_WEB';break;
                        case 'LEAVING': this.wander(); break;
                    }
                }
                
                checkForCollaboration(allSpiders) { if (this.state !== 'WANDERING' || Math.random() > 0.01) return; for (const otherSpider of allSpiders) { if (otherSpider.web && !otherSpider.web.isComplete && otherSpider.web.builders.length < MAX_BUILDERS_PER_WEB) { this.state = 'TRAVELING_TO_HELP'; this.web = otherSpider.web; this.web.addBuilder(this); this.buildTarget = { ...this.web.center }; break; } } }
                findBuildSite(allWebs) { for(let i=0;i<50;i++){let isClear=!0;const pRad=100+Math.random()*150,pCen={x:pRad+Math.random()*(screenWidth-2*pRad),y:pRad+Math.random()*(screenHeight-2*pRad)};for(const web of allWebs){if(web.center&&Math.hypot(pCen.x-web.center.x,pCen.y-web.center.y)<pRad+web.maxRadius+50){isClear=!1;break}}if(isClear){this.state='TRAVELING_TO_SITE';this.buildTarget=pCen;return}}this.wanderTimer=100+Math.floor(Math.random()*600)}
                startBuilding(allWebs) { this.web = new Web(this.position, this, 100 + Math.random() * 150); allWebs.push(this.web); this.findNextTask(); }
                moveTowardsTarget(isButterflyTarget = false) { if (!this.buildTarget) return false; const targetX = isButterflyTarget ? this.buildTarget.x : this.buildTarget.x; const targetY = isButterflyTarget ? this.buildTarget.y : this.buildTarget.y; const dist = Math.hypot(this.position.x - targetX, this.position.y - targetY); if (dist < this.speed) { this.position = { x: targetX, y: targetY }; return true; } this.direction = Math.atan2(targetY - this.position.y, targetX - this.position.x); this.position.x += Math.cos(this.direction) * this.speed; this.position.y += Math.sin(this.direction) * this.speed; return false; }
                wander() { this.direction+=(Math.random()-0.5)*0.2;this.position.x+=Math.cos(this.direction)*this.speed;this.position.y+=Math.sin(this.direction)*this.speed;if(this.state!=='LEAVING'&&this.state!=='ENTERING'){if(this.position.x<this.radius||this.position.x>screenWidth-this.radius){this.direction=Math.PI-this.direction}if(this.position.y<this.radius||this.position.y>screenHeight-this.radius){this.direction=-this.direction}}}
                getSpokeEnd(index) { return { x: this.web.center.x + this.web.spokeLengths[index] * Math.cos(this.web.spokeAngles[index]), y: this.web.center.y + this.web.spokeLengths[index] * Math.sin(this.web.spokeAngles[index]) }; }
                getSpiralPoint(spokeIndex, radius) { return { x: this.web.center.x + radius * Math.cos(this.web.spokeAngles[spokeIndex]), y: this.web.center.y + radius * Math.sin(this.web.spokeAngles[spokeIndex]) }; }
                
                findNextTask() {
                    let taskFound = false;
                    if (!this.web.allSpokesDone) {
                        for (let i = 0; i < this.web.numSpokes; i++) {
                            if (!this.web.spokesBuilt[i] && (i % this.web.builders.length === this.builderId)) {
                                this.currentTaskIndex = i; this.state = 'BUILDING_MY_SPOKES';
                                this.spokeBuildState = 'TRAVELING_OUT'; this.buildTarget = this.getSpokeEnd(i);
                                this.activeSpoke = { start: this.web.center, end: this.web.center, color: this.color };
                                this.web.spokes.push(this.activeSpoke);
                                taskFound = true; break;
                            }
                        }
                        if (!taskFound) {
                            this.state = 'WAITING_FOR_SPOKES_FINISH';
                            this.buildTarget = this.web.center;
                        }
                    } else {
                        for (let i = 0; i < this.web.spiralRingClaimed.length; i++) {
                            if (!this.web.spiralRingClaimed[i]) {
                                const radius = 20 + i * 25;
                                if (radius > this.web.maxRadius) { break; } // Check boundary BEFORE claiming
                                
                                this.web.spiralRingClaimed[i] = true;
                                this.activeRingIndex = i;
                                this.currentTaskIndex = 0;
                                this.state = 'BUILDING_MY_SPIRAL';
                                this.buildTarget = this.getSpiralPoint(0, radius);
                                taskFound = true; break;
                            }
                        }
                        if (!taskFound) {
                            this.web.isComplete = true; this.state = 'RETURNING_TO_CENTER'; this.buildTarget = this.web.center;
                        }
                    }
                }
                
                buildMySpokes() {
                    if (this.activeSpoke && this.spokeBuildState === 'TRAVELING_OUT') { this.activeSpoke.end = { ...this.position }; }
                    if (this.moveTowardsTarget()) {
                        if (this.spokeBuildState === 'TRAVELING_OUT') {
                            this.activeSpoke = null; this.spokeBuildState = 'TRAVELING_IN';
                            this.buildTarget = this.web.center;
                        } else {
                            this.web.spokesBuilt[this.currentTaskIndex] = true;
                            this.findNextTask();
                        }
                    }
                }
                
                buildMySpiralRing() {
                    if (this.moveTowardsTarget()) {
                        // Use the remembered activeRingIndex to ensure consistent radius
                        const radius = 20 + this.activeRingIndex * 25;
                        if (this.currentTaskIndex > 0) {
                            this.web.spirals.push({ start: this.lastSpiralPoint, end: { ...this.position }, color: this.color });
                        }
                        this.currentTaskIndex++;
                        if (this.currentTaskIndex > this.web.numSpokes) {
                            this.activeRingIndex = -1; // Release the claim on this ring
                            this.findNextTask();
                        } else {
                            this.lastSpiralPoint = { ...this.position };
                            const nextSpoke = this.currentTaskIndex % this.web.numSpokes;
                            this.buildTarget = this.getSpiralPoint(nextSpoke, radius);
                        }
                    }
                }
                draw() { const{x:centerX,y:centerY}=this.position;const swing1=Math.sin(this.animationTimer)*0.4,swing2=Math.sin(this.animationTimer+Math.PI)*0.4;ctx.strokeStyle=this.detailColor;ctx.lineWidth=this.legThickness;for(let i=0;i<4;i++){const swing=i%2===0?swing1:swing2,oppSwing=i%2===0?swing2:swing1;for(const sign of[1,-1]){const angle=this.direction+sign*(Math.PI/2+[0.6,1.0,-0.6,-1.0][i]);const startX=centerX+Math.cos(angle)*this.radius,startY=centerY+Math.sin(angle)*this.radius;const currentSwing=sign===1?swing:oppSwing;const endX=startX+Math.cos(angle+currentSwing)*this.legLength,endY=startY+Math.sin(angle+currentSwing)*this.legLength;ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(endX,endY);ctx.stroke()}} ctx.fillStyle=this.detailColor;ctx.beginPath();ctx.arc(centerX,centerY,this.radius,0,2*Math.PI);ctx.fill();ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(centerX,centerY,this.radius*0.7,0,2*Math.PI);ctx.fill();for(const sign of[-1,1]){const eyeAngle=this.direction+sign*0.5;const eyePosX=centerX+Math.cos(eyeAngle)*this.radius*0.5,eyePosY=centerY+Math.sin(eyeAngle)*this.radius*0.5;ctx.fillStyle='black';ctx.beginPath();ctx.arc(eyePosX,eyePosY,3,0,2*Math.PI);ctx.fill();ctx.fillStyle='white';ctx.beginPath();ctx.arc(eyePosX+1,eyePosY-1,1,0,2*Math.PI);ctx.fill()}}
            }
            
            function spawnSpiders() { spiderSpawnCooldown--; if (spiderSpawnCooldown <= 0 && spiders.length < MAX_SPIDERS) { spiders.push(new Spider()); spiderSpawnCooldown = 100 + Math.random() * 800; } }

            function gameLoop(currentTime) {
                animationFrameId = requestAnimationFrame(gameLoop);
                ctx.clearRect(0, 0, screenWidth, screenHeight);
                spawnSpiders();
                
                webs.forEach((web, i) => { web.update(currentTime); if (web.alpha <= 0) webs.splice(i, 1); else web.draw(); });
                butterflies.forEach((b, i) => { b.update(); if (b.state === 'EATEN') butterflies.splice(i, 1); else b.draw(); });
                webs.forEach(web => { if (!web.isFading) { butterflies.forEach(b => web.checkCollision(b)); } });

                for (let i = spiders.length - 1; i >= 0; i--) {
                    const spider = spiders[i];
                    spider.update(spiders, webs);
                    spider.draw();
                    if ((spider.state === 'IDLING_IN_WEB') && butterflies.length < MAX_BUTTERFLIES && Math.random() < 0.03) {
                        butterflies.push(new Butterfly());
                    }
                    if (spider.state === 'LEAVING') {
                        const { x, y } = spider.position;
                        if (x < -spider.radius * 2 || x > screenWidth + spider.radius * 2 || y < -spider.radius * 2 || y > screenHeight + spider.radius * 2) {
                            if (spider.web) spider.web.removeBuilder(spider);
                            colorManager.returnColor(spider.color);
                            spiders.splice(i, 1);
                        }
                    }
                }
            }

            function startSimulation() {
                if (isStarted) return; isStarted = true; clearTimeout(autoStartTimer); 
                startOverlay.style.opacity = '0';
                setTimeout(() => startOverlay.style.display = 'none', 500);
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                spiders.push(new Spider());
                for (let i = 0; i < 5; i++) { butterflies.push(new Butterfly()); }
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            startOverlay.addEventListener('click', startSimulation, { once: true });
            autoStartTimer = setTimeout(startSimulation, 5000);
        });
    </script>
</body>
</html>